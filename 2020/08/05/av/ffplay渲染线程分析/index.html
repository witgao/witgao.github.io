<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"witgao.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="视频渲染线程视频渲染线程实际就是main线程。 初始化初始化SDL12345678&#x2F;&#x2F; SDL初始化flags &#x3D; SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;if (SDL_Init(flags)) &amp;#123;  av_log(NULL, AV_LOG_FATAL, &quot;Could not initialize SDL - %s\n">
<meta property="og:type" content="article">
<meta property="og:title" content="ffplay渲染线程分析">
<meta property="og:url" content="https://witgao.com/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="富贵山庄">
<meta property="og:description" content="视频渲染线程视频渲染线程实际就是main线程。 初始化初始化SDL12345678&#x2F;&#x2F; SDL初始化flags &#x3D; SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;if (SDL_Init(flags)) &amp;#123;  av_log(NULL, AV_LOG_FATAL, &quot;Could not initialize SDL - %s\n">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-04T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-31T03:26:51.051Z">
<meta property="article:author" content="高振宇">
<meta property="article:tag" content="FFmpeg">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://witgao.com/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://witgao.com/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/","path":"2020/08/05/av/ffplay渲染线程分析/","title":"ffplay渲染线程分析"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ffplay渲染线程分析 | 富贵山庄</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">富贵山庄</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">恒者行远，思者常新</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">视频渲染线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96SDL"><span class="nav-number">1.1.1.</span> <span class="nav-text">初始化SDL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAWindow%E5%92%8CRenderer"><span class="nav-number">1.1.2.</span> <span class="nav-text">创建Window和Renderer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AE%E8%AF%A2"><span class="nav-number">1.2.</span> <span class="nav-text">轮询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%B7%E6%96%B0%E8%A7%86%E9%A2%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">刷新视频</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E8%A7%86%E9%A2%91"><span class="nav-number">1.2.2.</span> <span class="nav-text">显示视频</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%BA%B9%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">更新纹理数据</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9F%B3%E9%A2%91%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">音频渲染线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">回调函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E9%87%87%E6%A0%B7"><span class="nav-number">2.1.1.</span> <span class="nav-text">重采样</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="高振宇"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">高振宇</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/witgao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;witgao" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:witgao328@gmail.com" title="E-Mail → mailto:witgao328@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://witgao.com/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="高振宇">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="富贵山庄">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ffplay渲染线程分析 | 富贵山庄">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ffplay渲染线程分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-08-05T00:00:00+08:00">2020-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/" itemprop="url" rel="index"><span itemprop="name">音视频</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="视频渲染线程"><a href="#视频渲染线程" class="headerlink" title="视频渲染线程"></a>视频渲染线程</h1><p>视频渲染线程实际就是main线程。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化SDL"><a href="#初始化SDL" class="headerlink" title="初始化SDL"></a>初始化SDL</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SDL初始化</span></span><br><span class="line">flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;</span><br><span class="line"><span class="keyword">if</span> (SDL_Init(flags)) &#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>,</span><br><span class="line">         SDL_GetError());</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;(Did you set the DISPLAY variable?)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="创建Window和Renderer"><a href="#创建Window和Renderer" class="headerlink" title="创建Window和Renderer"></a>创建Window和Renderer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (borderless)</span><br><span class="line">  flags |= SDL_WINDOW_BORDERLESS;  <span class="comment">// 去掉窗口状态栏</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  flags |= SDL_WINDOW_RESIZABLE;  <span class="comment">// 窗口是否可缩放</span></span><br><span class="line"><span class="comment">// 创建SDL窗口</span></span><br><span class="line">window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                          SDL_WINDOWPOS_UNDEFINED, default_width,</span><br><span class="line">                          default_height, flags);</span><br><span class="line">SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, <span class="string">&quot;linear&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (window) &#123;</span><br><span class="line">  <span class="comment">// 创建SDL渲染器，SDL_RENDERER_ACCELERATED 使用硬件加速</span></span><br><span class="line">  renderer = SDL_CreateRenderer(</span><br><span class="line">      window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line">  <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;</span>,</span><br><span class="line">           SDL_GetError());</span><br><span class="line">    <span class="comment">// 如果创建SDL渲染器失败，则去掉标记再重试，可能是当前设备不支持该标记</span></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    <span class="comment">// 输出渲染器信息</span></span><br><span class="line">    <span class="keyword">if</span> (!SDL_GetRendererInfo(renderer, &amp;renderer_info))</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_VERBOSE, <span class="string">&quot;Initialized %s renderer.\n&quot;</span>,</span><br><span class="line">             renderer_info.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!window || !renderer || !renderer_info.num_texture_formats) &#123;</span><br><span class="line">  <span class="comment">// 如果窗口或者渲染器创建失败，或者渲染器中可用的纹理格式为0，则退出</span></span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to create window or renderer: %s&quot;</span>,</span><br><span class="line">         SDL_GetError());</span><br><span class="line">  do_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>主线程在开启解复用线程后，就会开始轮询处理SDL事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_loop</span><span class="params">(VideoState *cur_stream)</span> &#123;</span><br><span class="line">  SDL_Event event;</span><br><span class="line">  <span class="type">double</span> incr, pos, frac;</span><br><span class="line">  <span class="comment">// 开始轮询SDL消息</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="comment">// 获取事件，如果有，则执行下面的switch，如果没有，则会尝试刷新视频渲染</span></span><br><span class="line">    refresh_loop_wait_event(cur_stream, &amp;event);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在refresh_loop_wait_event中，会尝试获取SDL事件，如果获取成功，则返回，如果获取失败，则会执行while中的视频刷新操作。SDL事件会优先处理，在没有SDL事件的时候，就会轮询刷新视频</p>
<p>remaining_time的时间默认是0.01，当video_refresh刷新时，如果继续显示当前帧，则remaining_time的值等于当前帧结束的时间差，如果是显示下一帧，则不改变remaining_time的值，依旧是0.01。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">double</span> remaining_time = <span class="number">0.0</span>;</span><br><span class="line">  SDL_PumpEvents();</span><br><span class="line">  <span class="comment">// 如果获取到事件，则会直接返回，不会进入while</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">      !SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">    <span class="comment">// 如果没有获取到事件，则会尝试更新视频渲染</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cursor_hidden &amp;&amp;</span><br><span class="line">        av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">      SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">      cursor_hidden = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二次之后刷新时，就会先睡个一定时间，这个时间由音视频同步机制计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>) av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));</span><br><span class="line">    <span class="comment">// 默认刷新间隔是0.01s</span></span><br><span class="line">    remaining_time = REFRESH_RATE;</span><br><span class="line">    <span class="comment">// 如果当前是显示视频模式，并且 当前没有暂停或者当前强制刷新</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">      video_refresh(is, &amp;remaining_time); <span class="comment">// 刷新视频</span></span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h3 id="刷新视频"><a href="#刷新视频" class="headerlink" title="刷新视频"></a>刷新视频</h3><p>主要逻辑是计算当前显示的帧是否显示结束，如果显示结束，那么下一帧是否应该显示，根据音视频同步机制，进行丢帧或者对当前帧的结束时间进行缩短和增长。</p>
<p>音视频同步机制就是通过两个时钟的差值，来调整当前显示帧的结束时间，也就是frame_timer的值，进而调整remaining_time的值，也就是线程等待的时间。当视频时钟慢，则减小当前帧显示的时间，当视频时钟快，则加大当前帧显示的时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span> &#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">double</span> time;</span><br><span class="line"></span><br><span class="line">  Frame *sp, *sp2;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">  retry:</span><br><span class="line">    <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前Frame队列中没有数据，则什么也不干</span></span><br><span class="line">      <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">      Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* dequeue the picture */</span></span><br><span class="line">      <span class="comment">// 获取当前已经在显示的帧，可以认为是上一帧</span></span><br><span class="line">      lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 获取当前帧</span></span><br><span class="line">      vp = frame_queue_peek(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 如果当前帧的序号不符合，则丢弃</span></span><br><span class="line">      <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;</span><br><span class="line">        <span class="comment">// 读取移动到下一位，并重试</span></span><br><span class="line">        frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果上一帧与当前帧的序号不符合，重新更新播放时间frame_timer为当前系统时间</span></span><br><span class="line">      <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)</span><br><span class="line">        is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">      <span class="comment">// 如果暂停了，则继续显示当前显示的帧</span></span><br><span class="line">      <span class="keyword">if</span> (is-&gt;paused) <span class="keyword">goto</span> display;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">      <span class="comment">// 获取上一帧要显示的时长</span></span><br><span class="line">      last_duration = vp_duration(is, lastvp, vp);</span><br><span class="line">      <span class="comment">// 计算音视频同步的延迟时差</span></span><br><span class="line">      delay = compute_target_delay(last_duration, is);</span><br><span class="line"></span><br><span class="line">      time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">      <span class="comment">// frame_timer 当前显示的帧要结束的时间</span></span><br><span class="line">      <span class="comment">// frame_timer + delay = 当前显示的帧真正要结束的时间</span></span><br><span class="line">      <span class="comment">// 如果上一帧还没有结束，则继续显示上一帧</span></span><br><span class="line">      <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;</span><br><span class="line">        <span class="comment">// frame_timer + delay - time 就是当前显示的帧结束的时间与当前时间的差值，也就是线程要wait的时间</span></span><br><span class="line">        *remaining_time =</span><br><span class="line">            FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">        <span class="keyword">goto</span> display;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果上一帧帧的显示时间已经过去了</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新frame_timer，指向的是当前显示的帧结束的时间</span></span><br><span class="line">      is-&gt;frame_timer += delay;</span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">        is-&gt;frame_timer = time; <span class="comment">// 与系统时间偏离太大，则更新为系统时间</span></span><br><span class="line"></span><br><span class="line">      SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">      <span class="keyword">if</span> (!isnan(vp-&gt;pts)) update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">      SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line">      <span class="comment">// 如果队列中还有剩余的帧</span></span><br><span class="line">      <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个帧</span></span><br><span class="line">        Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">        <span class="comment">// 计算当前帧的显示时长</span></span><br><span class="line">        duration = vp_duration(is, vp, nextvp);</span><br><span class="line">        <span class="comment">// time &gt; is-&gt;frame_timer + duration</span></span><br><span class="line">        <span class="comment">// 如果下一帧的时间还没有过去，则丢弃当前帧，队列读索引向后移动一位，重试</span></span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;step &amp;&amp;</span><br><span class="line">            (framedrop &gt; <span class="number">0</span> ||</span><br><span class="line">             (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp;</span><br><span class="line">            time &gt; is-&gt;frame_timer + duration) &#123;</span><br><span class="line">          is-&gt;frame_drops_late++;</span><br><span class="line">          frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 队列向后移动一位</span></span><br><span class="line">      frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 强制刷新</span></span><br><span class="line">      is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused) stream_toggle_pause(is);</span><br><span class="line">    &#125;</span><br><span class="line">  display:</span><br><span class="line">    <span class="comment">/* display picture */</span></span><br><span class="line">    <span class="comment">// 显示当前帧</span></span><br><span class="line">    <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp;</span><br><span class="line">        is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">      video_display(is);</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;force_refresh = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示视频"><a href="#显示视频" class="headerlink" title="显示视频"></a>显示视频</h3><p>更新纹理数据，刷新屏幕</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_display</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!is-&gt;width) video_open(is);</span><br><span class="line">  <span class="comment">// 设置颜色 黑色</span></span><br><span class="line">  SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="comment">// 使用黑色清空缓冲区</span></span><br><span class="line">  SDL_RenderClear(renderer);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (is-&gt;audio_st &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">    video_audio_display(is); <span class="comment">// 如果是音频播放模式，显示音频声波图</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;video_st)</span><br><span class="line">    video_image_display(is);<span class="comment">// 更新纹理数据</span></span><br><span class="line">  <span class="comment">// 将渲染的内容刷新到屏幕上</span></span><br><span class="line">  SDL_RenderPresent(renderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新纹理数据"><a href="#更新纹理数据" class="headerlink" title="更新纹理数据"></a>更新纹理数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_image_display</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  Frame *vp;</span><br><span class="line">  Frame *sp = <span class="literal">NULL</span>;</span><br><span class="line">  SDL_Rect rect;</span><br><span class="line">  <span class="comment">// 从视频原始数据队列中取出一帧，这里没有调用frame_queue_peek</span></span><br><span class="line">  <span class="comment">// 是因为更新纹理有两种情况：一种是继续显示当前帧，这种使用frame_queue_peek_last正好，另一种是显示下一帧，在这种情况下，会提前调用frame_queue_next移动，所以这里直接调用frame_queue_peek_last，不管哪种情况都是合适的。</span></span><br><span class="line">  vp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算显示的矩阵</span></span><br><span class="line">  calculate_display_rect(&amp;rect, is-&gt;xleft, is-&gt;ytop, is-&gt;width, is-&gt;height,</span><br><span class="line">                         vp-&gt;width, vp-&gt;height, vp-&gt;sar);</span><br><span class="line">  <span class="comment">// 重复显示当前在显示的帧时，没必要重复上传数据到纹理中</span></span><br><span class="line">  <span class="keyword">if</span> (!vp-&gt;uploaded) &#123;</span><br><span class="line">    <span class="comment">// 如果视频帧还有没更新到纹理上</span></span><br><span class="line">    <span class="keyword">if</span> (upload_texture(&amp;is-&gt;vid_texture, vp-&gt;frame, &amp;is-&gt;img_convert_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 标记已经更新</span></span><br><span class="line">    vp-&gt;uploaded = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    vp-&gt;flip_v = vp-&gt;frame-&gt;linesize[<span class="number">0</span>] &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置YUV转换RGB的转换公式</span></span><br><span class="line">  set_sdl_yuv_conversion_mode(vp-&gt;frame);</span><br><span class="line">  <span class="comment">// 将纹理上的内容拷贝到渲染器的默认渲染目标上</span></span><br><span class="line">  SDL_RenderCopyEx(renderer, is-&gt;vid_texture, <span class="literal">NULL</span>, &amp;rect, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">                   vp-&gt;flip_v ? SDL_FLIP_VERTICAL : <span class="number">0</span>);</span><br><span class="line">  set_sdl_yuv_conversion_mode(<span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="音频渲染线程"><a href="#音频渲染线程" class="headerlink" title="音频渲染线程"></a>音频渲染线程</h1><p>音频渲染线程是由SDL创建的，会在该线程中执行我们设置的回调函数。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在回调函数中主要处理两件事，一件就是从FrameQueue中取出len长度的数据放入到stream中，交给音频设备进行播放；另一件事就是更新音频时钟。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频渲染线程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果audio_buf中数据已经全部读完，则说明需要加入更多的数据</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">      <span class="comment">// 获取buffer到 is-&gt;audio_buf 中，返回获取的buffer大小</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE /</span><br><span class="line">                             is-&gt;audio_tgt.frame_size *</span><br><span class="line">                             is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        <span class="comment">// 读取的buffer大小  </span></span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 已经读取的buffer位置重置</span></span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算还未读取的字节大小</span></span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    <span class="comment">// 如果为读取的字节大小大于音频设备想要的大小，则使用音频设备想要的大小</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len) len1 = len;</span><br><span class="line">    <span class="comment">// 将audio_buf中的数据copy到stream中</span></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">        SDL_MixAudioFormat(stream,</span><br><span class="line">                           (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index,</span><br><span class="line">                           AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去已经传递给音频设备的buffer大小，如果剩下的还有，则再次读取传递</span></span><br><span class="line">    len -= len1;</span><br><span class="line">    <span class="comment">// stream加上偏移量</span></span><br><span class="line">    stream += len1;</span><br><span class="line">    <span class="comment">// 更新audio_buf的偏移量</span></span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录audio_buf中还剩余的大小</span></span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="comment">// 更新音频时钟</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">    <span class="comment">// 音频时钟中保存的是当前audio_buf开始的时间+时长，也就是结束的时间</span></span><br><span class="line">    <span class="comment">// 真正播放的准确时间应该要减去缓冲区中未使用的数据的时长，才是真正当前播放的时长</span></span><br><span class="line">    <span class="comment">// 缓冲区中未使用的字节大小 = 2 * is-&gt;audio_hw_buf_size 音频设备的缓冲区大小 + is-&gt;audio_write_buf_size audio_buf中还剩余的大小</span></span><br><span class="line">    <span class="comment">// 缓冲区中未使用的时长 = 缓冲区中未使用的字节大小 / （音频设备）1s数据的字节大小</span></span><br><span class="line">    <span class="comment">// 音频时钟准确时间 = 当前音频包结束时长 - 音频缓冲中剩余的数据时长</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                 is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size +</span><br><span class="line">                                            is-&gt;audio_write_buf_size) /</span><br><span class="line">                                       is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                 is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>如果音频数据参数与开启音频设备的参数不一致，那么是无法播放的，需要进行重采样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  <span class="type">int</span> data_size, resampled_data_size;</span><br><span class="line">  <span class="type">int64_t</span> dec_channel_layout;</span><br><span class="line">  av_unused <span class="type">double</span> audio_clock0;</span><br><span class="line">  <span class="type">int</span> wanted_nb_samples;</span><br><span class="line">  Frame *af;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;paused) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 循环从音频原始数据列表中获取一个可读帧，如果帧的序号与音频编码数据队列中的序号不一样，则丢帧</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从音频原始数据列表中获取一个可读帧</span></span><br><span class="line">    <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 队列移动到下一个可读帧</span></span><br><span class="line">    frame_queue_next(&amp;is-&gt;sampq);</span><br><span class="line">  &#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial);</span><br><span class="line">  <span class="comment">// 根据音频参数计算一帧的字节大小  </span></span><br><span class="line">  data_size = av_samples_get_buffer_size(</span><br><span class="line">      <span class="literal">NULL</span>, af-&gt;frame-&gt;channels, af-&gt;frame-&gt;nb_samples, af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  dec_channel_layout =</span><br><span class="line">      (af-&gt;frame-&gt;channel_layout &amp;&amp;</span><br><span class="line">       af-&gt;frame-&gt;channels ==</span><br><span class="line">           av_get_channel_layout_nb_channels(af-&gt;frame-&gt;channel_layout))</span><br><span class="line">          ? af-&gt;frame-&gt;channel_layout</span><br><span class="line">          : av_get_default_channel_layout(af-&gt;frame-&gt;channels);</span><br><span class="line">  wanted_nb_samples = synchronize_audio(is, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">  <span class="comment">// 如果音频数据的参数发生了变化， audio_src 默认是音频设备开启时的参数</span></span><br><span class="line">  <span class="comment">// 只有当音频数据参数发生了变化才会重新创建重采样上下文</span></span><br><span class="line">  <span class="keyword">if</span> (af-&gt;frame-&gt;format != is-&gt;audio_src.fmt ||</span><br><span class="line">      dec_channel_layout != is-&gt;audio_src.channel_layout ||</span><br><span class="line">      af-&gt;frame-&gt;sample_rate != is-&gt;audio_src.freq ||</span><br><span class="line">      (wanted_nb_samples != af-&gt;frame-&gt;nb_samples &amp;&amp; !is-&gt;swr_ctx)) &#123;</span><br><span class="line">    swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">    <span class="comment">// 创建重采样上下文，将音频重采样成音频设备开启的参数</span></span><br><span class="line">    is-&gt;swr_ctx = swr_alloc_set_opts(<span class="literal">NULL</span>, is-&gt;audio_tgt.channel_layout,</span><br><span class="line">                                     is-&gt;audio_tgt.fmt, is-&gt;audio_tgt.freq,</span><br><span class="line">                                     dec_channel_layout, af-&gt;frame-&gt;format,</span><br><span class="line">                                     af-&gt;frame-&gt;sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录当前帧的参数作为音频源的参数，如果后面的帧的参数发生了变化，则会重新创建重采样上下文</span></span><br><span class="line">    is-&gt;audio_src.channel_layout = dec_channel_layout;</span><br><span class="line">    is-&gt;audio_src.channels = af-&gt;frame-&gt;channels;</span><br><span class="line">    is-&gt;audio_src.freq = af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    is-&gt;audio_src.fmt = af-&gt;frame-&gt;format;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重采样</span></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> **in = (<span class="type">const</span> <span class="type">uint8_t</span> **)af-&gt;frame-&gt;extended_data;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">uint8_t</span> **out = &amp;is-&gt;audio_buf1;</span><br><span class="line">    <span class="comment">// 计算重采样后AVFrame中具体有几帧数据</span></span><br><span class="line">    <span class="type">int</span> out_count = (<span class="type">int64_t</span>)wanted_nb_samples * is-&gt;audio_tgt.freq /</span><br><span class="line">                        af-&gt;frame-&gt;sample_rate +</span><br><span class="line">                    <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 计算重采样后的数据大小</span></span><br><span class="line">    <span class="type">int</span> out_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, is-&gt;audio_tgt.channels,</span><br><span class="line">                                              out_count, is-&gt;audio_tgt.fmt, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> len2;</span><br><span class="line">    <span class="keyword">if</span> (out_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size() failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果想要的帧数和AVFrame中的帧数不符合</span></span><br><span class="line">    <span class="keyword">if</span> (wanted_nb_samples != af-&gt;frame-&gt;nb_samples) &#123;</span><br><span class="line">      <span class="keyword">if</span> (swr_set_compensation(is-&gt;swr_ctx,</span><br><span class="line">                               (wanted_nb_samples - af-&gt;frame-&gt;nb_samples) *</span><br><span class="line">                                   is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                               wanted_nb_samples * is-&gt;audio_tgt.freq /</span><br><span class="line">                                   af-&gt;frame-&gt;sample_rate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_set_compensation() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配输出buffer的内存</span></span><br><span class="line">    av_fast_malloc(&amp;is-&gt;audio_buf1, &amp;is-&gt;audio_buf1_size, out_size);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;audio_buf1) <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">    <span class="comment">// 重采样</span></span><br><span class="line">    len2 = swr_convert(is-&gt;swr_ctx, out, out_count, in, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">    <span class="keyword">if</span> (len2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_convert() failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len2 == out_count) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;audio buffer is probably too small\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>) swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取buffer</span></span><br><span class="line">    is-&gt;audio_buf = is-&gt;audio_buf1;</span><br><span class="line">    <span class="comment">// 计算重采样后数据大小</span></span><br><span class="line">    resampled_data_size = len2 * is-&gt;audio_tgt.channels *</span><br><span class="line">                          av_get_bytes_per_sample(is-&gt;audio_tgt.fmt);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要重采样，则直接使用AVFrame中的data</span></span><br><span class="line">    <span class="comment">// 获取buffer</span></span><br><span class="line">    is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取buffer大小</span></span><br><span class="line">    resampled_data_size = data_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_clock0 = is-&gt;audio_clock;</span><br><span class="line">  <span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line">  <span class="comment">// 更新音频时钟，音频时钟 = 当前帧的PTS + （样本数量 / 每秒采样率） 也就是这些数据时长是多少秒</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">    is-&gt;audio_clock =</span><br><span class="line">        af-&gt;pts + (<span class="type">double</span>)af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    is-&gt;audio_clock = NAN;</span><br><span class="line">  <span class="comment">// 更新音频时钟序号</span></span><br><span class="line">  is-&gt;audio_clock_serial = af-&gt;serial;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resampled_data_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>高振宇
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://witgao.com/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/" title="ffplay渲染线程分析">https://witgao.com/2020/08/05/av/ffplay渲染线程分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/FFmpeg/" rel="tag"><i class="fa fa-tag"></i> FFmpeg</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/08/04/av/ffplay%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/" rel="prev" title="ffplay解码线程分析">
                  <i class="fa fa-chevron-left"></i> ffplay解码线程分析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/07/07/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bnew%E5%92%8Cdelete/" rel="next" title="libc++源码分析之new和delete">
                  libc++源码分析之new和delete <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">高振宇</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">76k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:37</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
