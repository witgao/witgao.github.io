<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android图形架构总览</title>
    <url>/2019/10/15/av/Android%E5%9B%BE%E5%BD%A2%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h1 id="图形渲染流程"><a href="#图形渲染流程" class="headerlink" title="图形渲染流程"></a>图形渲染流程</h1><p>​	在Android中，所有的渲染都是将内容绘制到对应的Surface上，Surface作为BufferQueue的生产方，每当发生入队操作时，都会通知BufferQueue创建者进行消费，也就是SurfaceFlinger，由SurfaceFlinger进行合并，然后发送到显示器进行显示。</p>
<p>下面这张图描述了关键组件的工作流程:</p>
<p><img src="/2019/10/15/av/Android%E5%9B%BE%E5%BD%A2%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88/ape_fwk_graphics.png" alt="工作流程"></p>
<span id="more"></span>

<ol>
<li><p>当前一个可见的界面被创建时，会通过WindowManager去创建一个Window对象，而每一个Window对象中都会包含一个Surface对象，该对象由WindowManager向SurfaceFlinger请求创建。Surface中包含一个BufferQueue，它由SurfaceFlinger向HAL层调用Gralloc对其进行内存分配。</p>
</li>
<li><p>应用获取到该Window对象后，通过Surface对象创建EGLSurface对象，然后在View的draw方法中使用Canvas进行绘制，此时使用的Canvas是一个OpenGL ES Canvas，也就是会通过OpenGL ES对View进行绘制，GLES渲染完成后，通过EGL的swapBuffers方法将绘制的缓冲区加入到EGLSurface连接的Surface所拥有的BufferQueue上。</p>
</li>
<li><p>SurfaceFlinger接收HAL层发送来的VSYNC事件进行刷新，SurfaceFlinger从每个Surface的BufferQueue中获取新的缓冲区，释放掉其之前的缓冲区，如果获取不到新的，则继续使用之前的缓冲区。</p>
</li>
<li><p>将所有要显示的Surface传入到HAL层进行查询，哪些需要进行合并，然后根据返回的标记，对需要进行合并的Surface进行合并（使用OpenGL ES将两个缓冲区合并到第三个缓冲区中），然后将处理后的所有Surface交给显示器，由显示器进行叠加层显示。参考下图</p>
</li>
</ol>
<p><img src="/2019/10/15/av/Android%E5%9B%BE%E5%BD%A2%E6%9E%B6%E6%9E%84%E6%80%BB%E8%A7%88/graphics_pipeline.png" alt="合并流程"></p>
<hr>
<h1 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h1><p>​	BufferQueue用来连接缓冲区生产方和缓冲区消费方。</p>
<p>​	生产方向BufferQueue请求一个可用的缓冲区（dequeueBuffer），然后向该缓冲区中写入数据后将其返回到队列中（queueBuffer），消费方从队列中获取该缓冲区并使用它（acquireBuffer），消费方使用完毕后将该缓冲区释放并重新返回到队列中（releaseBuffer）。</p>
<hr>
<h1 id="SurfaceFlinger"><a href="#SurfaceFlinger" class="headerlink" title="SurfaceFlinger"></a>SurfaceFlinger</h1><p>​	SurfaceFlinger负责创建Surface，并消费其创建的Surface。应用想要显示一个界面，都必须通过WindowManager向SurfaceFlinger请求一个Surface，然后将显示的内容交给Surface传递给SurfaceFlinger。</p>
<p>​	SurfaceFlinger仅仅在显示器刷新的时候才会进行处理，而不是应用更新了Surface中的缓冲队列就立马处理，这样可以减少内存的使用。显示器的刷新是通过VSYNC信号发送到SurfaceFlinger上的。</p>
<p>​	当SurfaceFlinger接收到VSYNC信号，SurfaceFlinger会遍历所有可见Surface，获取每个Surface最新的缓冲区，如果获取到了释放之前的缓冲区，如果没有获取到最新的缓冲区，则继续使用之前的缓冲区。如果该Surface自始至终都没有过缓冲区，则忽略该Surface。</p>
<p>​	SurfaceFlinger收集了所有可见Surface的最新缓冲区后，会询问HWC层硬件将如果处理合成，然后将HWC层标记为SurfaceFlinger合成的全部合成为一个缓冲区，最后将剩下的所有缓冲区传递给HWC层进行显示。</p>
<hr>
<h1 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h1><p>​	WindowManager控制Window对象，Window是View对象的容器。WindowManager监视生命周期，输入和焦点事件，屏幕方向，过渡，动画，位置，变换，z顺序以及窗口的许多其他方面。WindowManager将所有窗口元数据发送到SurfaceFlinger，以便SurfaceFlinger可以使用该数据进行合成、显示。</p>
<hr>
<h1 id="屏幕叠加层"><a href="#屏幕叠加层" class="headerlink" title="屏幕叠加层"></a>屏幕叠加层</h1><p>​	上面说到过SurfaceFlinger在收集了所有可见Surface的最新缓冲区后，需要询问HWC层，那是因为显示器一般都有叠加层支持，也就是显示器并不是只能显示一个缓冲区，它可以同时显示多个缓冲区，可以从不同的缓冲区读取屏幕上不同位置的数据。这样做可以非常显著的提高效率，避免了SurfaceFlinger在不停的合并（SurfaceFlinger的合并是通过GPU来合成，这会抢占应用使用GPU渲染的时间），只有在Surface的个数大于叠加层的个数的时候才会由SurfaceFlinger来合并。</p>
<p>所以SurfaceFlinger维护的Surface的数量会对能耗和性能产生很大影响。</p>
<p>叠加层最少有4个：</p>
<ul>
<li>状态栏</li>
<li>系统导航栏</li>
<li>应用</li>
<li>壁纸</li>
</ul>
<hr>
<h1 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h1><p>​	Surface是一个接口，维护了一个对BufferQueue的连接，用于将缓冲区从生产方流动都消费方。</p>
<p>向Surface中绘制有两种方式:</p>
<h2 id="GPU渲染"><a href="#GPU渲染" class="headerlink" title="GPU渲染"></a>GPU渲染</h2><p>一般使用OpenGL ES或者Vulkan渲染，View的draw方法使用的就是这种方式</p>
<h2 id="CPU渲染"><a href="#CPU渲染" class="headerlink" title="CPU渲染"></a>CPU渲染</h2><p>使用lockCanvas或者new Canvas，这种方式都是使用CPU渲染</p>
<p><strong>使用lockCanvas时需要注意，一旦使用CPU渲染的Canvas向Surface中进行了绘制，那么CPU渲染程序会连接到Surface中的BufferQueue上，直到Surface被销毁才会断开连接，因为连接无法断开。所以此后该Surface将无法接受GPU渲染程序的连接。（新版本中使用lockHardwareCanvas方法可以返回一个使用GPU进行渲染的Canvas）</strong></p>
<hr>
<h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><p>​	SurfaceView &#x3D; Surface + 特殊的View</p>
<p>​	SurfaceView在View体系中只是一个透明的占位符，与View本身的渲染毫无关系，是独立的。SurfaceView在即将显示的时候会去SurfaceFlinger那请求一个单独的Surface，通过SurfaceHolder异步获取到Surface后，对该Surface进行渲染。SurfaceView的Surface在SurfaceFlinger中默认是放置在应用界面Surface的后面。</p>
<p>​	采用单独Surface对性能会有很大的提升，因为缓冲区将直接由SurfaceFlinger进行合并然后发送给显示器，不受应用本身绘制的影响，也不会导致应用重绘。但是缺点也很明显，SurfaceView并不是一个真正的View，对它进行大小位置的变动会非常麻烦，因为每次变动都需要通知SurfaceFlinger来改变Surface的大小位置。</p>
<p>​	在使用的过程中一般都会在异步线程中对SurfaceView进行渲染。</p>
<!-- more -->

<hr>
<!-- more -->

<h1 id="GLSurfaceView"><a href="#GLSurfaceView" class="headerlink" title="GLSurfaceView"></a>GLSurfaceView</h1><p>​	GLSurfaceView &#x3D; SurfaceView + EGL</p>
<p>​	GLSurfaceView会创建一个单独的渲染线程（因为GLES的状态机是和线程绑定的），然后会初始化EGL上下文，封装Render作为GLES的生命回调。</p>
<hr>
<h1 id="SurfaceTexture"><a href="#SurfaceTexture" class="headerlink" title="SurfaceTexture"></a>SurfaceTexture</h1><p>​	SurfaceTexture &#x3D; Consumer + GLES外部纹理</p>
<p>​	SurfaceTexture拥有一个BufferQueue，可以用于缓冲区的流动。将SurfaceTexture发送给生产方（例如Camera），生产方会将缓冲区写入到队列中，通过SurfaceTexture的onFrameAvailable方法可以获得通知。</p>
<p>​	SurfaceTexture的另一个特点是其在创建BufferQueue的时候，会添加GRALLOC_USAGE_HW_TEXTURE标记，这样gralloc创建的缓冲区就可以被GLES使用。所以SurfaceTexture可以绑定一个OES纹理，通过updateTexImage方法可以从BufferQueue中获取新的缓冲区给OES纹理使用。</p>
<p>​	BufferQueue传递的不仅仅只是缓冲区数据，还有一些附加参数，比如缓冲区的时间戳、转换矩阵。获取附加参数一般在updateTexImage方法后，通过getTransformMatrix方法可以获取前面出队的缓冲区的转换矩阵，之所以传递转换矩阵，而不是将数据在传递前就转换，是因为在真正使用的过程中，数据可能会经过多次流动，会产生多次转换，传递转换矩阵可以使多次转换合并，降低开销；通过getTimestamp获取该缓冲区生产的时间戳，采用生产的时间戳而不是用消费的时间戳是因为有些场景（比如录像）对时间非常敏感。</p>
<p>SurfaceTexture可以认为是GLConsumer，是一个BufferQueue的所有方和消费方；通过SurfaceTexture创建Surface对象，实际上是创建了一个BufferQueue的生产方。</p>
<hr>
<h1 id="TextureView"><a href="#TextureView" class="headerlink" title="TextureView"></a>TextureView</h1><p>TextureView &#x3D; SurfaceTexture + View</p>
<p>TextureView是一个真正意义上的View，受应用绘制体系控制，不是独立的。TextureView内部会创建一个SurfaceTexture，并将它交给应用的View体系，然后对SurfaceTexture设置onFrameAvailable监听，当BufferQueue中有变动时，先通过updateTexImage方法从SurfaceTexture中获取到最新的缓冲区，然后调用invalidate方法通知应用的View体系将缓冲区合并到应用本身的Surface上。</p>
<p>与SurfaceView相比，TextureView是一个真正的View，对它进行大小位置的变动会很简单高效。但是缺点也很明显，需要先将TextureView上的缓冲区合并到应用的缓冲区（会对TextureView上层的View造成重绘），然后再由SurfaceFlinger对所有Surface进行合并，这样TextureView的内容实际上是被合并了两次，相比SurfaceView，性能消耗比较大。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android录制视频</title>
    <url>/2020/07/21/av/Android%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>FFmpeg对于Android平台的视频输入设备API有一定的支持，但是比较局限，只支持Android N以上的版本，低版本无法使用。</p>
<p>其原因是因为FFmpeg采用的是Android N推出的native层camera API来实现的(NDK中的libcamera2ndk.so），而并非采用JNI的方式来调用Java层camera API。</p>
<h1 id="Android平台视频录制API"><a href="#Android平台视频录制API" class="headerlink" title="Android平台视频录制API"></a>Android平台视频录制API</h1><p>对于视频录制API，Android平台上有两套API实现，一套是老版的Camera1，另一套是Android L之后推出的Camera2。</p>
<p>Camera1使用起来较为简单，但是功能相对较少，不支持多纹理输出。Camera2的API功能上虽然更加强大，但是API设计的非常底层化，不利于理解，并且YUV_420_888的数据格式，国内各大产商在实现上留下的坑太多。</p>
<p>Jetpack组件中，Google推出了全新的CameraX组件，对Camera1和Camera2进行了统一的封装，使得API更加简单易用。</p>
<span id="more"></span>

<h2 id="Camera1"><a href="#Camera1" class="headerlink" title="Camera1"></a>Camera1</h2><h3 id="获取Camera设备信息"><a href="#获取Camera设备信息" class="headerlink" title="获取Camera设备信息"></a>获取Camera设备信息</h3><ul>
<li>Camera.getNumberOfCameras() : 获取Camera设备数量 </li>
<li>index : 索引就是后续会使用的CameraID</li>
<li>Camera.CameraInfo : Camera设备信息  </li>
<li>Camera.getCameraInfo(index, info) : 获取指定索引的Camera设备信息，存储到info对象中</li>
<li>Camera.CameraInfo.facing : 相机面对的方向，前置还是后置 CAMERA_FACING_BACK or CAMERA_FACING_FRONT.</li>
<li>Camera.CameraInfo.orientation : 相机图像的方向，获取到的图像需要顺时针旋转该角度才能正常显示。值为0、90、180、270。（因为我们拿手机一般是竖着拿，但是摄像头可能是向左横着或向右横着被安装的）</li>
<li>Camera.open : 获取指定索引位置的Camera设备实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历所有的camera设备</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; android.hardware.Camera.getNumberOfCameras(); ++index) &#123;</span><br><span class="line">  <span class="comment">// 获取camera设备信息</span></span><br><span class="line">  android.hardware.Camera.<span class="type">CameraInfo</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">android</span>.hardware.Camera.CameraInfo();</span><br><span class="line">  android.hardware.Camera.getCameraInfo(index, info);</span><br><span class="line">  <span class="type">String</span> <span class="variable">facing</span> <span class="operator">=</span></span><br><span class="line">        (info.facing == android.hardware.Camera.CameraInfo.CAMERA_FACING_FRONT) ? <span class="string">&quot;front&quot;</span> : <span class="string">&quot;back&quot;</span>; </span><br><span class="line">  <span class="keyword">final</span> android.hardware.Camera camera;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 开启camera设备，获取camera实例</span></span><br><span class="line">      camera = android.hardware.Camera.open(cameraId);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      callback.onFailure(FailureType.ERROR, e.getMessage());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="设置采集参数"><a href="#设置采集参数" class="headerlink" title="设置采集参数"></a>设置采集参数</h3><p>设置采集的尺寸、格式、对焦、闪光灯、白平衡等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取相机设备的参数集</span></span><br><span class="line"><span class="keyword">final</span> android.hardware.Camera.<span class="type">Parameters</span> <span class="variable">parameters</span> <span class="operator">=</span> camera.getParameters();</span><br><span class="line"><span class="comment">// 获取手机支持的对焦模式（为了应对各手机厂商的差异，一般在设置某个功能时，先判断当前手机是否支持该功能）</span></span><br><span class="line"><span class="keyword">final</span> List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();</span><br><span class="line"><span class="comment">// 设置FPS的区间</span></span><br><span class="line">parameters.setPreviewFpsRange(framerate.min, framerate.max);</span><br><span class="line"><span class="comment">// 设置预览尺寸</span></span><br><span class="line">parameters.setPreviewSize(width, height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置预览数据的像素格式，一般设置NV21</span></span><br><span class="line">parameters.setPreviewFormat(ImageFormat.NV21);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频稳像</span></span><br><span class="line"><span class="keyword">if</span> (parameters.isVideoStabilizationSupported()) &#123;</span><br><span class="line">  parameters.setVideoStabilization(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前手机支持，则设置对焦模式为 FOCUS_MODE_CONTINUOUS_VIDEO</span></span><br><span class="line"><span class="keyword">if</span> (focusModes.contains(android.hardware.Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO)) &#123;</span><br><span class="line">  parameters.setFocusMode(android.hardware.Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置参数，重启相机才生效</span></span><br><span class="line">camera.setParameters(parameters);</span><br><span class="line"><span class="comment">// 设置相机预览显示的图像方向</span></span><br><span class="line">camera.setDisplayOrientation(<span class="number">0</span> <span class="comment">/* degrees */</span>);</span><br></pre></td></tr></table></figure>

<p>下面的代码就是设置相机预览显示的图像角度根据activity显示的方向来调整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCameraDisplayOrientation</span><span class="params">(Activity activity,</span></span><br><span class="line"><span class="params">      <span class="type">int</span> cameraId, android.hardware.Camera camera)</span> &#123;</span><br><span class="line">  android.hardware.Camera.<span class="type">CameraInfo</span> <span class="variable">info</span> <span class="operator">=</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">android</span>.hardware.Camera.CameraInfo();</span><br><span class="line">  android.hardware.Camera.getCameraInfo(cameraId, info);</span><br><span class="line"> <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> activity.getWindowManager().getDefaultDisplay()</span><br><span class="line">          .getRotation();</span><br><span class="line">  <span class="type">int</span> <span class="variable">degrees</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (rotation) &#123;</span><br><span class="line">      <span class="keyword">case</span> Surface.ROTATION_0: degrees = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Surface.ROTATION_90: degrees = <span class="number">90</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Surface.ROTATION_180: degrees = <span class="number">180</span>; <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Surface.ROTATION_270: degrees = <span class="number">270</span>; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) &#123;</span><br><span class="line">      <span class="comment">// 前置相机是镜像的</span></span><br><span class="line">      result = (info.orientation + degrees) % <span class="number">360</span>;</span><br><span class="line">      result = (<span class="number">360</span> - result) % <span class="number">360</span>;  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">      <span class="comment">// 后置相机</span></span><br><span class="line">      result = (info.orientation - degrees + <span class="number">360</span>) % <span class="number">360</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  camera.setDisplayOrientation(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h3 id="设置输出"><a href="#设置输出" class="headerlink" title="设置输出"></a>设置输出</h3><p>获取输出数据有两种方式，一种是设置一个SurfaceTexture采用纹理进行接收；另一种是通过设置回调直接接收byte array数据。</p>
<h4 id="Texture格式"><a href="#Texture格式" class="headerlink" title="Texture格式"></a>Texture格式</h4><p>SurfaceTexture有两种方式获取，一种是通过系统的SurfaceView或者TextureView来获取，另一种就是自建OES纹理，通过构造函数new。</p>
<ul>
<li>通过系统的View来获取的SurfaceTexture，相机设备将数据写入后，系统View会自动取出数据更新显示。</li>
<li>自己创建的SurfaceTexture可以通过设置OnFrameAvailableListener来监听数据的变更，当相机设备写入数据时，会触发回调，在回调中使用updateTexImage从队列中取出一个数据绑定到OES纹理中，使用OES纹理来进行绘制显示或者编码输入等操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  camera.setPreviewTexture(getSurfaceTexture());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">  camera.release();</span><br><span class="line">  callback.onFailure(FailureType.ERROR, e.getMessage());</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ByteArray格式"><a href="#ByteArray格式" class="headerlink" title="ByteArray格式"></a>ByteArray格式</h4><p>对于ByteArray格式的回调设置，又有两种方式，一种是setPreviewCallback方法，另一种是setPreviewCallbackWithBuffer方法。</p>
<ul>
<li>第一种onPreviewFrame回调方法会在每一帧数据准备好了就调用，回调时机是不可控的。</li>
<li>第二种方式是在需要在前一帧的onPreviewFrame方法中调用addCallbackBuffer方法，下一帧的onPreviewFrame才会调用，同时addCallbackBuffer方法的参数的byte数据就是每一帧的原数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置回调</span></span><br><span class="line">camera.setPreviewCallback(<span class="keyword">new</span> <span class="title class_">Camera</span>.PreviewCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPreviewFrame</span><span class="params">(<span class="type">byte</span>[] data, Camera camera)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">frameSize</span> <span class="operator">=</span> captureFormat.frameSize();</span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(frameSize);</span><br><span class="line"><span class="comment">// 设置数据回调的buffer</span></span><br><span class="line">camera.addCallbackBuffer(buffer.array());</span><br><span class="line"><span class="comment">// 设置回调</span></span><br><span class="line">camera.setPreviewCallbackWithBuffer(<span class="keyword">new</span> <span class="title class_">android</span>.hardware.Camera.PreviewCallback() &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onPreviewFrame</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, android.hardware.Camera callbackCamera)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取下一个回调</span></span><br><span class="line">    camera.addCallbackBuffer(data);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h3><ul>
<li>startPreview : 开启预览，数据开始回调，更改采集参数后需要重新开启预览才生效</li>
<li>stopPreview : 停止预览<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  camera.startPreview();</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">camera.stopPreview();</span><br><span class="line">camera.release();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h2><h3 id="获取Camera设备信息-1"><a href="#获取Camera设备信息-1" class="headerlink" title="获取Camera设备信息"></a>获取Camera设备信息</h3><p>Camera设备的获取需要通过系统服务来操作。</p>
<ul>
<li>getCameraIdList : 获取camera设备列表</li>
<li>getCameraCharacteristics : 获取指定camera设备参数集，通过对应的KEY从参数集中获取到各种参数值</li>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line"></span><br><span class="line">String[] cameraIdList = cameraManager.getCameraIdList();</span><br><span class="line"><span class="keyword">for</span> (String cameraId : cameraIdList) &#123;</span><br><span class="line">    <span class="type">CameraCharacteristics</span> <span class="variable">characteristics</span> <span class="operator">=</span> cameraManager.getCameraCharacteristics(cameraId);</span><br><span class="line">    <span class="comment">// 获取相机面对的方向，CameraMetadata.LENS_FACING_BACK or CameraMetadata.LENS_FACING_FRONT</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">facing</span> <span class="operator">=</span> characteristics.get(CameraCharacteristics.LENS_FACING) == CameraMetadata.LENS_FACING_BACK;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 开启camera设备，设置开启回调，以及指定camera回调执行的线程</span></span><br><span class="line">      cameraManager.openCamera(cameraId, <span class="keyword">new</span> <span class="title class_">CameraStateCallback</span>(), cameraThreadHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
camera设备状态回调，在回调中可以开启一次会话，在会话中可以进行数据的请求<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CameraStateCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraDevice</span>.StateCallback &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getErrorDescription</span><span class="params">(<span class="type">int</span> errorCode)</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span> (errorCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> CameraDevice.StateCallback.ERROR_CAMERA_DEVICE:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Camera device has encountered a fatal error.&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> CameraDevice.StateCallback.ERROR_CAMERA_DISABLED:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Camera device could not be opened due to a device policy.&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> CameraDevice.StateCallback.ERROR_CAMERA_IN_USE:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Camera device is in use already.&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> CameraDevice.StateCallback.ERROR_CAMERA_SERVICE:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Camera service has encountered a fatal error.&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> CameraDevice.StateCallback.ERROR_MAX_CAMERAS_IN_USE:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Camera device could not be opened because&quot;</span></span><br><span class="line">              + <span class="string">&quot; there are too many other open camera devices.&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;Unknown camera error: &quot;</span> + errorCode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDisconnected</span><span class="params">(CameraDevice camera)</span> &#123;</span><br><span class="line">      <span class="comment">// camera设备断开连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(CameraDevice camera, <span class="type">int</span> errorCode)</span> &#123;</span><br><span class="line">      <span class="comment">// 发生错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpened</span><span class="params">(CameraDevice camera)</span> &#123;</span><br><span class="line">      <span class="comment">// camera设备成功开启</span></span><br><span class="line">      cameraDevice = camera;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建采集会话，设置采集输出的Surface集合，可同时输出到多个Surface中</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        camera.createCaptureSession(</span><br><span class="line">            Arrays.asList(surface), <span class="keyword">new</span> <span class="title class_">CaptureSessionCallback</span>(), cameraThreadHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(CameraDevice camera)</span> &#123;</span><br><span class="line">      <span class="comment">// camera设备关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置采集参数-1"><a href="#设置采集参数-1" class="headerlink" title="设置采集参数"></a>设置采集参数</h3><p>采集会话创建成功后，可以设置采集的参数，然后创建采集请求，进行数据的采集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CaptureSessionCallback</span> <span class="keyword">extends</span> <span class="title class_">CameraCaptureSession</span>.StateCallback &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigureFailed</span><span class="params">(CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="comment">// 配置失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onConfigured</span><span class="params">(CameraCaptureSession session)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置采集参数</span></span><br><span class="line">      captureSession = session;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建视频采集请求构建器，设置采集的参数</span></span><br><span class="line">        <span class="keyword">final</span> CaptureRequest.<span class="type">Builder</span> <span class="variable">captureRequestBuilder</span> <span class="operator">=</span></span><br><span class="line">            cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">        <span class="comment">// 设置FPS的区间</span></span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Range</span>&lt;Integer&gt;(framerate.min,framerate.max));</span><br><span class="line">        <span class="comment">// 设置闪光灯模式</span></span><br><span class="line">        captureRequestBuilder.set(</span><br><span class="line">            CaptureRequest.CONTROL_AE_MODE, CaptureRequest.CONTROL_AE_MODE_ON);</span><br><span class="line">        captureRequestBuilder.set(CaptureRequest.CONTROL_AE_LOCK, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置视频稳像</span></span><br><span class="line">        chooseStabilizationMode(captureRequestBuilder);</span><br><span class="line">        <span class="comment">// 设置对焦模式</span></span><br><span class="line">        chooseFocusMode(captureRequestBuilder);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加采集输出目标，可添加多个，添加的目标必须在createCaptureSession的集合中</span></span><br><span class="line">        captureRequestBuilder.addTarget(surface);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重复发送请求，开始采集</span></span><br><span class="line">        session.setRepeatingRequest(</span><br><span class="line">            captureRequestBuilder.build(), <span class="keyword">new</span> <span class="title class_">CameraCaptureCallback</span>(), cameraThreadHandler);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        reportError(<span class="string">&quot;Failed to start capture request. &quot;</span> + e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先采用光学稳像，其次采用软件稳像</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">chooseStabilizationMode</span><span class="params">(CaptureRequest.Builder captureRequestBuilder)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span>[] availableOpticalStabilization = cameraCharacteristics.get(</span><br><span class="line">          CameraCharacteristics.LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION);</span><br><span class="line">      <span class="keyword">if</span> (availableOpticalStabilization != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mode : availableOpticalStabilization) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mode == CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON) &#123;</span><br><span class="line">            captureRequestBuilder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,</span><br><span class="line">                CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_ON);</span><br><span class="line">            captureRequestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,</span><br><span class="line">                CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_OFF);</span><br><span class="line">            Logging.d(TAG, <span class="string">&quot;Using optical stabilization.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// If no optical mode is available, try software.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span>[] availableVideoStabilization = cameraCharacteristics.get(</span><br><span class="line">          CameraCharacteristics.CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> mode : availableVideoStabilization) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode == CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON) &#123;</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE,</span><br><span class="line">              CaptureRequest.CONTROL_VIDEO_STABILIZATION_MODE_ON);</span><br><span class="line">          captureRequestBuilder.set(CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE,</span><br><span class="line">              CaptureRequest.LENS_OPTICAL_STABILIZATION_MODE_OFF);</span><br><span class="line">          Logging.d(TAG, <span class="string">&quot;Using video stabilization.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Logging.d(TAG, <span class="string">&quot;Stabilization not available.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置对焦模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">chooseFocusMode</span><span class="params">(CaptureRequest.Builder captureRequestBuilder)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span>[] availableFocusModes =</span><br><span class="line">          cameraCharacteristics.get(CameraCharacteristics.CONTROL_AF_AVAILABLE_MODES);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> mode : availableFocusModes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mode == CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO) &#123;</span><br><span class="line">          captureRequestBuilder.set(</span><br><span class="line">              CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_VIDEO);</span><br><span class="line">          Logging.d(TAG, <span class="string">&quot;Using continuous video auto-focus.&quot;</span>);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Logging.d(TAG, <span class="string">&quot;Auto-focus is not available.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置输出-1"><a href="#设置输出-1" class="headerlink" title="设置输出"></a>设置输出</h3><p>Camera2中数据的输出都是通过设置Surface来接收，可以同时设置多个Surface，Surface可以通过SurfaceTexture来创建。</p>
<ul>
<li>采用系统的SurfaceView、TextureView生成的Surface，设置给Camera，对相机采集的数据进行预览显示</li>
<li>采用系统的ImageReader生成的Surface来接收指定格式的图像数据</li>
<li>采用自己创建的SurfaceTexture来接收数据，通过设置OnFrameAvailableListener来监听数据的变更，当相机设备写入数据时，会触发回调，在回调中使用updateTexImage从队列中取出一个数据绑定到OES纹理中，使用OES纹理来进行绘制显示或者编码输入等操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建采集会话，设置采集输出的Surface集合，可同时输出到多个Surface中</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  camera.createCaptureSession(</span><br><span class="line">      Arrays.asList(surface), <span class="keyword">new</span> <span class="title class_">CaptureSessionCallback</span>(), cameraThreadHandler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会话创建成功后，在创建采集请求时，添加对应的输出目标就可以将采集请求到的数据传入到目标中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加采集输出目标，可添加多个，添加的目标必须在createCaptureSession的集合中</span></span><br><span class="line">captureRequestBuilder.addTarget(surface);</span><br><span class="line"><span class="comment">// 重复请求，开始采集</span></span><br><span class="line">session.setRepeatingRequest(</span><br><span class="line">      captureRequestBuilder.build(), <span class="keyword">new</span> <span class="title class_">CameraCaptureCallback</span>(), cameraThreadHandler);</span><br></pre></td></tr></table></figure>

<h4 id="ImageReader"><a href="#ImageReader" class="headerlink" title="ImageReader"></a>ImageReader</h4><p>ImageReader是跟随Camera2出来的，用来接收相机采集的数据，在拍照时可以设置ImageFormat.JPEG格式，如果想要获取原始数据，则需要设置成ImageFormat.YUV_420_888。</p>
<p>ImageFormat.YUV_420_888格式，是指YUV_420格式，其内部具体格式可以是NV12、NV21、YV12、I420中的任何一种，也就是说如果设置的是YUV_420_888格式，则设备返回的数据格式需要根据其返回的具体数据去判断。（这点在国内手机上各不相同，有些个别低端手机给的数据不符合官方文档上的要求）</p>
<p>对于ImageReader来说，最最重要的就是理解好YUV_420_888格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建ImageReader对象，指定接收的数据尺寸和数据格式以及缓冲区大小</span></span><br><span class="line"><span class="type">ImageReader</span> <span class="variable">imageReader</span> <span class="operator">=</span> ImageReader.newInstance(width, height, ImageFormat.JPEG, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 获取Surface，添加到会话请求的目标中作为输出</span></span><br><span class="line"><span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> imageReader.getSurface();</span><br><span class="line"><span class="comment">// 设置数据回调</span></span><br><span class="line">imageReader.setOnImageAvailableListener(<span class="keyword">new</span> <span class="title class_">ImageReader</span>.OnImageAvailableListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onImageAvailable</span><span class="params">(ImageReader reader)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取采集到的数据</span></span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> reader.acquireNextImage();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放</span></span><br><span class="line">        image.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, mCameraHandler);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android录制音频</title>
    <url>/2020/07/20/av/Android%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<p>由于FFmpeg一直都没有支持Android平台的音频输入设备API，所以无法使用FFmpeg在Android上录制音频。</p>
<h1 id="Android平台音频录制API"><a href="#Android平台音频录制API" class="headerlink" title="Android平台音频录制API"></a>Android平台音频录制API</h1><p>Android上音频输入的API比较繁琐，有多套实现。有Java层的实现AudioRecord，也有native层实现OpenSLES，在 Android O之后又推出了新的native层实现AAudio，并且提供了Oboe库，对OpenSLES和AAudio进行了封装。</p>
<p>下面来详细的介绍下每套API的使用</p>
<h2 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a>AudioRecord</h2><p>AudioRecord是Android平台提供的录制音频的Java层API，使用起来非常简单。通过设置采集参数就可以创建一个AudioRecord对象，调用了start方法后，就可以开始读取数据了，通过read方法将数据读取到指定的缓冲区中，调用stop后就停止采集。</p>
<span id="more"></span>

<h3 id="创建AudioRecord"><a href="#创建AudioRecord" class="headerlink" title="创建AudioRecord"></a>创建AudioRecord</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个音频帧的字节大小 = 声道数 *（位数 /8）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">bytesPerFrame</span> <span class="operator">=</span> channels * (BITS_PER_SAMPLE / <span class="number">8</span>);</span><br><span class="line"><span class="comment">// BUFFERS_PER_SECOND = 100，预测一秒钟回调100次</span></span><br><span class="line"><span class="comment">// 那么44100的采样率，每次回调应该给的数据帧个数为4410个</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">framesPerBuffer</span> <span class="operator">=</span> sampleRate / BUFFERS_PER_SECOND;</span><br><span class="line"><span class="comment">// 一次回调给的总数据字节大小 = 一次给的数据帧个数 * 一个数据帧的字节大小</span></span><br><span class="line"><span class="comment">// 创建一个buffer用来接收回调数据，使用堆外内存，在通过JNI传递的时候避免内存拷贝</span></span><br><span class="line">byteBuffer = ByteBuffer.allocateDirect(bytesPerFrame * framesPerBuffer);</span><br><span class="line">   </span><br><span class="line">emptyBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.capacity()];</span><br><span class="line"><span class="comment">// 避免每次读取数据都需要传递buffer到JNI层，这里提前将buffer的地址保存在JNI层</span></span><br><span class="line">nativeCacheDirectBufferAddress(byteBuffer, nativeAudioRecord);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">channelConfig</span> <span class="operator">=</span> channelCountToConfiguration(channels);</span><br><span class="line"><span class="comment">// 根据音频参数(采样率，声道数，位数)得到系统最小需要的缓冲区大小，创建AudioRecord时设置的缓冲区大小必须大于这个值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minBufferSize</span> <span class="operator">=</span></span><br><span class="line">    AudioRecord.getMinBufferSize(sampleRate, channelConfig, AudioFormat.ENCODING_PCM_16BIT); </span><br><span class="line"></span><br><span class="line"><span class="comment">// BUFFER_SIZE_FACTOR = 2</span></span><br><span class="line"><span class="comment">// 缓冲区一般要大一点，所以下面比较了两倍的最小缓冲区和我们自己计算的缓冲区大小</span></span><br><span class="line"><span class="comment">// 也就是说设置的缓冲区大小最小也要是最小缓冲区的两倍。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">bufferSizeInBytes</span> <span class="operator">=</span> Math.max(BUFFER_SIZE_FACTOR * minBufferSize, byteBuffer.capacity());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 根据音频参数创建AudioRecord，audioSource是指音频采集的来源</span></span><br><span class="line">  audioRecord = <span class="keyword">new</span> <span class="title class_">AudioRecord</span>(audioSource, sampleRate, channelConfig,</span><br><span class="line">      AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (audioRecord == <span class="literal">null</span> || audioRecord.getState() != AudioRecord.STATE_INITIALIZED) &#123;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始后才可以读取数据</span></span><br><span class="line">audioRecord.startRecording();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 循环读取数据</span></span><br><span class="line"><span class="keyword">while</span> (keepAlive) &#123;</span><br><span class="line">  <span class="comment">// 将数据读取到之前创建的buffer中，返回读取的字节大小</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">bytesRead</span> <span class="operator">=</span> audioRecord.read(byteBuffer, byteBuffer.capacity());</span><br><span class="line">  <span class="keyword">if</span> (bytesRead == byteBuffer.capacity()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将读取的字节大小通知给JNI层，因为前面在创建的时候已经将buffer的地址保存在JNI层中，所以这里传递读取的字节大小就行</span></span><br><span class="line">    <span class="keyword">if</span> (keepAlive) &#123;</span><br><span class="line">      nativeDataIsRecorded(bytesRead, nativeAudioRecord);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (audioSamplesReadyCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 拷贝整个数据回调出去</span></span><br><span class="line">      <span class="type">byte</span>[] data = Arrays.copyOf(byteBuffer.array(), byteBuffer.capacity());</span><br><span class="line">      audioSamplesReadyCallback.onWebRtcAudioRecordSamplesReady(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">AudioSamples</span>(audioRecord, data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 读取错误</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止后不能再读取数据</span></span><br><span class="line">audioRecord.stop();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="获取设备音频相关信息"><a href="#获取设备音频相关信息" class="headerlink" title="获取设备音频相关信息"></a>获取设备音频相关信息</h3><p>通过AudioManager可以获取到当前设备默认的采样率以及最小缓冲区大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AudioManager</span> <span class="variable">myAudioMgr</span> <span class="operator">=</span> (AudioManager) getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line"><span class="type">String</span> <span class="variable">nativeParam</span> <span class="operator">=</span> myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);</span><br><span class="line">nativeParam = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER);</span><br></pre></td></tr></table></figure>

<!-- more -->

<h3 id="AudioSource音频来源"><a href="#AudioSource音频来源" class="headerlink" title="AudioSource音频来源"></a>AudioSource音频来源</h3><ul>
<li>DEFAULT：默认为MIC</li>
<li>MIC：麦克风</li>
<li>VOICE_UPLINK：电话录音上行线路，系统权限不允许第三方app使用 </li>
<li>VOICE_DOWNLINK：电话录音下行线路，系统权限不允许第三方app使用 </li>
<li>VOICE_CALL：电话录音上下线路，系统权限不允许第三方app使用 </li>
<li>CAMCORDER：摄像头的麦克风</li>
<li>VOICE_RECOGNITION：语音识别</li>
<li>VOICE_COMMUNICATION：网络电话</li>
<li>REMOTE_SUBMIX：传输到远程的音频混合流，默认情况下如果用该项录音，本地扬声器或者耳机的声音将会被截走，系统权限不允许第三方app使用</li>
</ul>
<h2 id="OpenSL-ES"><a href="#OpenSL-ES" class="headerlink" title="OpenSL-ES"></a>OpenSL-ES</h2><p>OpenSL-ES是Android平台上提供的高性能音频的API，相对Java层API有着一定的低延迟性。由于是C库，所以使用起来API相对繁琐一些。</p>
<h3 id="配置数据参数"><a href="#配置数据参数" class="headerlink" title="配置数据参数"></a>配置数据参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SLDataFormat_PCM format;</span><br><span class="line"><span class="comment">// PCM数据格式</span></span><br><span class="line">format.formatType = SL_DATAFORMAT_PCM;</span><br><span class="line"><span class="comment">// 声道数</span></span><br><span class="line">format.numChannels = <span class="built_in">static_cast</span>&lt;SLuint32&gt;(channels);</span><br><span class="line"><span class="comment">// 设置采样率</span></span><br><span class="line"><span class="keyword">switch</span> (sample_rate) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_8;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">16000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_16;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">22050</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_22_05;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">32000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_32;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">44100</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_44_1;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">48000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_48;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">64000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_64;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">88200</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_88_2;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">96000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_96;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unsupported sample rate: &quot;</span> &lt;&lt; sample_rate;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置位数</span></span><br><span class="line">format.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line"><span class="comment">// 小端</span></span><br><span class="line">format.endianness = SL_BYTEORDER_LITTLEENDIAN;</span><br><span class="line"><span class="keyword">if</span> (format.numChannels == <span class="number">1</span>) &#123;</span><br><span class="line">  format.channelMask = SL_SPEAKER_FRONT_CENTER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (format.numChannels == <span class="number">2</span>) &#123;</span><br><span class="line">  format.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unsupported number of channels: &quot;</span></span><br><span class="line">                   &lt;&lt; format.numChannels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建引擎"><a href="#创建引擎" class="headerlink" title="创建引擎"></a>创建引擎</h3><p>在OpenSLES中，任何API接口对象都要由引擎来创建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程安全模式</span></span><br><span class="line"><span class="type">const</span> SLEngineOption option[] = &#123;</span><br><span class="line">    &#123;SL_ENGINEOPTION_THREADSAFE, <span class="built_in">static_cast</span>&lt;SLuint32&gt;(SL_BOOLEAN_TRUE)&#125;&#125;;</span><br><span class="line"><span class="comment">// 创建引擎接口</span></span><br><span class="line">SLresult result =</span><br><span class="line">    <span class="built_in">slCreateEngine</span>(engine_object_, <span class="number">1</span>, option, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置引擎实现模式为同步模式</span></span><br><span class="line">result = engine_object_-&gt;<span class="built_in">Realize</span>(engine_object_, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据引擎接口获取到隐藏的引擎实现</span></span><br><span class="line"><span class="keyword">if</span> ((*engine_object)</span><br><span class="line">            -&gt;<span class="built_in">GetInterface</span>(engine_object, SL_IID_ENGINE, &amp;engine_)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建录制器"><a href="#创建录制器" class="headerlink" title="创建录制器"></a>创建录制器</h3><p>在OpenSLES中，录制需要通过录制器对象来进行，而数据的获取是通过回调的方式来获取，但是并非将采集的数据放在回调函数的参数中进行传递，回调函数仅仅只是一个通知的意义，真正的数据是在Enqueue函数中传入的buffer中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置IO设备</span></span><br><span class="line">SLDataLocator_IODevice mic_locator = &#123;SL_DATALOCATOR_IODEVICE,</span><br><span class="line">                                      SL_IODEVICE_AUDIOINPUT,</span><br><span class="line">                                      SL_DEFAULTDEVICEID_AUDIOINPUT, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="comment">// 设置数据源</span></span><br><span class="line">SLDataSource audio_source = &#123;&amp;mic_locator, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue buffer_queue = &#123;</span><br><span class="line">    SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;SLuint32&gt;(kNumOfOpenSLESBuffers)&#125;;</span><br><span class="line"><span class="comment">// 设置数据接收器的缓冲队列和数据参数    </span></span><br><span class="line">SLDataSink audio_sink = &#123;&amp;buffer_queue, &amp;pcm_format_&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">const</span> SLInterfaceID interface_id[] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">                                      SL_IID_ANDROIDCONFIGURATION&#125;;</span><br><span class="line"><span class="type">const</span> SLboolean interface_required[] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"><span class="comment">// 通过引擎实现创建录制器接口</span></span><br><span class="line"><span class="keyword">if</span> ((*engine_)-&gt;<span class="built_in">CreateAudioRecorder</span>(</span><br><span class="line">        engine_, recorder_object_, &amp;audio_source, &amp;audio_sink,</span><br><span class="line">        <span class="built_in">arraysize</span>(interface_id), interface_id, interface_required)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过录制器接口创建录制器配置实现，用来设置相关录制配置参数</span></span><br><span class="line">SLAndroidConfigurationItf recorder_config;</span><br><span class="line"><span class="keyword">if</span> ((recorder_object_-&gt;<span class="built_in">GetInterface</span>(recorder_object_,</span><br><span class="line">                                                 SL_IID_ANDROIDCONFIGURATION,</span><br><span class="line">                                                 &amp;recorder_config))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置音频采集源</span></span><br><span class="line">SLint32 stream_type = SL_ANDROID_RECORDING_PRESET_VOICE_COMMUNICATION;</span><br><span class="line"><span class="keyword">if</span> (((*recorder_config)</span><br><span class="line">                      -&gt;<span class="built_in">SetConfiguration</span>(recorder_config,</span><br><span class="line">                                         SL_ANDROID_KEY_RECORDING_PRESET,</span><br><span class="line">                                         &amp;stream_type, <span class="built_in">sizeof</span>(SLint32)))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置录制器实现模式为同步模式</span></span><br><span class="line"><span class="keyword">if</span> ((recorder_object_-&gt;<span class="built_in">Realize</span>(recorder_object_,</span><br><span class="line">                                            SL_BOOLEAN_FALSE))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过录制器接口创建录制器实现，用来采集数据</span></span><br><span class="line"><span class="keyword">if</span> ((recorder_object_-&gt;<span class="built_in">GetInterface</span>(</span><br><span class="line">        recorder_object_, SL_IID_RECORD, &amp;recorder_))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过录制器接口创建缓冲队列实现，用来传递数据</span></span><br><span class="line"><span class="keyword">if</span> ((recorder_object_-&gt;<span class="built_in">GetInterface</span>(</span><br><span class="line">        recorder_object_.<span class="built_in">Get</span>(), SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">        &amp;simple_buffer_queue_))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册在缓冲队列上的回调，通过回调来获取到数据，SimpleBufferQueueCallback就是回调函数，this是回调参数的context参数</span></span><br><span class="line"><span class="keyword">if</span> (((*simple_buffer_queue_)</span><br><span class="line">                      -&gt;<span class="built_in">RegisterCallback</span>(simple_buffer_queue_,</span><br><span class="line">                                         SimpleBufferQueueCallback, <span class="keyword">this</span>))) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="采集数据"><a href="#采集数据" class="headerlink" title="采集数据"></a>采集数据</h3><p>每调用一次Enqueue函数都会触发一次数据回调，如果需要循环采集，则需要在回调函数中递归调用Enqueue函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次调用Enqueue方法设置一个buffer入队，数据就会被采集到该buffer中，然后通过回调函数通知，在回调函数中才该buffer中获取对应数据</span></span><br><span class="line"><span class="comment">// 第一个参数就是缓冲队列实现对象，第二个参数就是buffer，第三个参数是采集的数据字节大小</span></span><br><span class="line">SLresult err =</span><br><span class="line">      (*simple_buffer_queue_)</span><br><span class="line">          -&gt;<span class="built_in">Enqueue</span>(</span><br><span class="line">              simple_buffer_queue_,</span><br><span class="line">              <span class="built_in">reinterpret_cast</span>&lt;SLint8*&gt;(audio_buffers_[buffer_index_].<span class="built_in">get</span>()),</span><br><span class="line">              audio_parameters_.<span class="built_in">GetBytesPerBuffer</span>());</span><br><span class="line">  <span class="keyword">if</span> (SL_RESULT_SUCCESS != err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenSLESRecorder::SimpleBufferQueueCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SLAndroidSimpleBufferQueueItf buffer_queue,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据回调函数，context就是在设置回调时设置的this</span></span><br><span class="line">  OpenSLESRecorder* stream = <span class="built_in">static_cast</span>&lt;OpenSLESRecorder*&gt;(context);</span><br><span class="line">  <span class="comment">// 接收到数据采集成功回调，从缓冲队列中读取数据</span></span><br><span class="line">  stream-&gt;<span class="built_in">ReadBufferQueue</span>();</span><br><span class="line">  <span class="comment">// Enqueue()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android播放视频</title>
    <url>/2020/07/23/av/Android%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>图像的显示最终都是由显示器完成的，显示器通过接收到的颜色矩阵来进行对应的显示。而颜色矩阵的产生一般有两种，一种是通过GPU来进行渲染生成，另一种是通过CPU来进行渲染生成。其中GPU比较适合来处理这件事情，所以其效率高。（硬件加速也就是指使用GPU来进行渲染加速）</p>
<p>在Android平台上，GPU渲染的API有两套，一套就是OpenGL-ES，另一套就是7.0后推出的Vulkan。目前使用最多的还是OpenGL-ES。</p>
<span id="more"></span>

<p>整个渲染流程中主要节点如下:<br>SurfaceFlinger &lt;- SurfaceView &lt;- Surface &lt;- EGLSurface &lt;- EGLContext &lt;- OpenGL-ES</p>
<h1 id="接入原生渲染体系"><a href="#接入原生渲染体系" class="headerlink" title="接入原生渲染体系"></a>接入原生渲染体系</h1><p>Android原生平台上封装了一整套View体系用来进行图像的渲染和显示，所以任何的渲染都必须基于这个体系才能正确的显示出来。</p>
<p>View系统中提供了两个View可以用来进行自定义渲染，一个是SurfaceView，另一个是TextureView。（关于SurfaceView和TextureView可以看我之前写的<a href="">Android图形架构总览</a>。</p>
<p>只要将图形数据写入到SurfaceView或TextureView的Surface中，那么最终SurfaceFlinger服务就会将图形内容显示到显卡上。</p>
<p>所以对于播放视频来说，就是要将视频每一帧的图像数据写入到SurfaceView或TextureView的Surface中即可。</p>
<p>SurfaceView可以通过addCallback来接收来自原生渲染的生命周期回调，通过getSurface来获取内部的Surface对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.getHolder().addCallback();</span><br><span class="line"><span class="built_in">this</span>.getHolder().getSurface()</span><br></pre></td></tr></table></figure>

<p>TextureView可以通过setSurfaceTextureListener来接收生命周期回调，通过getSurfaceTexture可以获取到SurfaceTexture。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setSurfaceTextureListener();</span><br><span class="line"><span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Surface</span>(getSurfaceTexture());</span><br></pre></td></tr></table></figure>

<h1 id="Surface与EGLSurface"><a href="#Surface与EGLSurface" class="headerlink" title="Surface与EGLSurface"></a>Surface与EGLSurface</h1><p>一个Surface对象，可以关联一个EGLSurface对象（window_surface)，window_surface可以通过swap方法将其内部图像缓冲数据传入到Surface中（其它类型的EGLSurface是不可以的）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个提供给opengl-es绘制的surface（display，配置，原生window，指定属性）</span></span><br><span class="line"><span class="keyword">if</span> (!(eglSurface = <span class="built_in">eglCreateWindowSurface</span>(display, config, aNativeWindow, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// android中创建NativeWindow</span></span><br><span class="line">ANativeWindow *pNativeWindow = <span class="built_in">ANativeWindow_fromSurface</span>(jenv, surface);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="EGLSurface与EGLContext"><a href="#EGLSurface与EGLContext" class="headerlink" title="EGLSurface与EGLContext"></a>EGLSurface与EGLContext</h1><p>EGLContext是与线程相关的，一个线程中只能激活一个EGLContext，激活的EGLContext关联一个EGLSurface，激活后，在当前线程调用OpenGL-ES的API都将作用到EGLSurface的缓冲区中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建context，在context中保存了opengl-es的状态信息 （display，配置，共享context的handle 一般设为null，属性）</span></span><br><span class="line"><span class="comment">// 一个display可以创建多个context</span></span><br><span class="line"><span class="keyword">if</span> (!(context = <span class="built_in">eglCreateContext</span>(display, config, <span class="number">0</span>, context_attribs))) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将上面创建的context绑定到当前线程上，并将context与surface进行关联。当makeCurrent执行后，就可以调用opengl-es的api对context中的状态集进行设定，</span></span><br><span class="line"><span class="comment">// 然后进而向surface中绘制内容，再把surface中的内容读取出来。</span></span><br><span class="line"><span class="comment">// 一个线程中enable状态的context只能有一个，如果当前线程已经有了一个enable状态的context，那么会先执行其flush操作，将没有执行完成的命令全部执行完成，然后将其改为disable状态，将新传入的context改为enable状态。</span></span><br><span class="line"><span class="comment">// 如果想要释放当前的context,也就是将当前的context disable,那么将第二个和第三个参数设置为 EGL_NO_SURFACE,第四个参数设置为 EGL_NO_CONTEXT即可。</span></span><br><span class="line"><span class="comment">// context enable后，视口大小和裁剪大小都会被设置为surface的尺寸</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglMakeCurrent</span>(display, eglSurface, eglSurface, context)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="OpenGL-ES渲染纹理"><a href="#OpenGL-ES渲染纹理" class="headerlink" title="OpenGL-ES渲染纹理"></a>OpenGL-ES渲染纹理</h1><p>当我们准备好了EGLSurface和EGLContext后，那么接下来就是创建OpenGL—ES的Program进行纹理的绘制了。</p>
<h2 id="创建Program"><a href="#创建Program" class="headerlink" title="创建Program"></a>创建Program</h2><h3 id="创建Vertex着色器"><a href="#创建Vertex着色器" class="headerlink" title="创建Vertex着色器"></a>创建Vertex着色器</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">attribute</span> <span class="keyword">highp</span> <span class="type">vec4</span> aPosition;</span><br><span class="line"><span class="keyword">attribute</span> <span class="keyword">highp</span> <span class="type">vec2</span> aTextureCoord;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoordinate;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="built_in">gl_Position</span>  = aPosition;</span><br><span class="line">    textureCoordinate = aTextureCoord.xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建Fragment着色器"><a href="#创建Fragment着色器" class="headerlink" title="创建Fragment着色器"></a>创建Fragment着色器</h3><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"><span class="keyword">varying</span> <span class="keyword">highp</span> <span class="type">vec2</span> textureCoordinate;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">lowp</span> <span class="type">sampler2D</span> inputTextureY;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">lowp</span> <span class="type">sampler2D</span> inputTextureU;</span><br><span class="line"><span class="keyword">uniform</span> <span class="keyword">lowp</span> <span class="type">sampler2D</span> inputTextureV;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec3</span> yuv;</span><br><span class="line">    <span class="type">vec3</span> rgb;</span><br><span class="line">    yuv.r = <span class="built_in">texture2D</span>(inputTextureY, textureCoordinate).r - (<span class="number">16.0</span> / <span class="number">255.0</span>);</span><br><span class="line">    yuv.g = <span class="built_in">texture2D</span>(inputTextureU, textureCoordinate).r - <span class="number">0.5</span>;</span><br><span class="line">    yuv.b = <span class="built_in">texture2D</span>(inputTextureV, textureCoordinate).r - <span class="number">0.5</span>;</span><br><span class="line">    rgb = <span class="type">mat3</span>(<span class="number">1.164</span>,  <span class="number">1.164</span>,  <span class="number">1.164</span>,</span><br><span class="line">               <span class="number">0.0</span>,   <span class="number">-0.213</span>,  <span class="number">2.112</span>,</span><br><span class="line">               <span class="number">1.793</span>, <span class="number">-0.533</span>,    <span class="number">0.0</span>) * yuv;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(rgb, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- more -->

<h3 id="创建Program-1"><a href="#创建Program-1" class="headerlink" title="创建Program"></a>创建Program</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Program</span></span><br><span class="line">programHandle = OpenGLUtils::<span class="built_in">createProgram</span>(vertexShader, fragmentShader);</span><br><span class="line"><span class="comment">// 获取顶点坐标变量</span></span><br><span class="line">positionHandle = <span class="built_in">glGetAttribLocation</span>(programHandle, <span class="string">&quot;aPosition&quot;</span>);</span><br><span class="line"><span class="comment">// 获取纹理坐标变量</span></span><br><span class="line">texCoordinateHandle = <span class="built_in">glGetAttribLocation</span>(programHandle, <span class="string">&quot;aTextureCoord&quot;</span>);</span><br><span class="line"><span class="comment">// 获取YUV纹理变量</span></span><br><span class="line">inputTextureHandle[<span class="number">0</span>] = <span class="built_in">glGetUniformLocation</span>(programHandle, <span class="string">&quot;inputTextureY&quot;</span>);</span><br><span class="line">inputTextureHandle[<span class="number">1</span>] = <span class="built_in">glGetUniformLocation</span>(programHandle, <span class="string">&quot;inputTextureU&quot;</span>);</span><br><span class="line">inputTextureHandle[<span class="number">2</span>] = <span class="built_in">glGetUniformLocation</span>(programHandle, <span class="string">&quot;inputTextureV&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Program</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(programHandle);</span><br><span class="line"><span class="comment">// 创建三个纹理，用来接收YUV数据</span></span><br><span class="line"><span class="keyword">if</span> (textures[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">glGenTextures</span>(<span class="number">3</span>, textures);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i);</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="built_in">glUniform1i</span>(inputTextureHandle[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="设置坐标"><a href="#设置坐标" class="headerlink" title="设置坐标"></a>设置坐标</h2><p>对于图像来说，首先创建一个平面矩形，然后在其上贴上纹理即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 矩形坐标，原点在屏幕中心，x、y轴为(-1,1)</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span>  <span class="type">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">-1.0f</span>, <span class="number">-1.0f</span>,  <span class="comment">// left,  bottom</span></span><br><span class="line">        <span class="number">1.0f</span>,  <span class="number">-1.0f</span>,  <span class="comment">// right, bottom</span></span><br><span class="line">        <span class="number">-1.0f</span>,  <span class="number">1.0f</span>,  <span class="comment">// left,  top</span></span><br><span class="line">        <span class="number">1.0f</span>,   <span class="number">1.0f</span>,  <span class="comment">// right, top</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 纹理坐标，原点在屏幕左上角，x、y轴为(0,1)</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">float</span> texture_vertices[] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="comment">// left, top</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="comment">// right, top</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="comment">// left, bottom</span></span><br><span class="line">        <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="comment">// right, bottom</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定顶点坐标</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(positionHandle, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, vertices);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(positionHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定纹理坐标</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(texCoordinateHandle, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">0</span>, texture_vertices);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(texCoordinateHandle);</span><br></pre></td></tr></table></figure>

<h2 id="设置纹理"><a href="#设置纹理" class="headerlink" title="设置纹理"></a>设置纹理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新绑定纹理的数据</span></span><br><span class="line"><span class="comment">// 这里处理的是YUV420p格式的数据，所以UV是Y的一半</span></span><br><span class="line"><span class="type">const</span> GLsizei heights[<span class="number">3</span>] = &#123; texture-&gt;height, texture-&gt;height / <span class="number">2</span>, texture-&gt;height / <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 激活前面创建的YUV纹理</span></span><br><span class="line">    <span class="built_in">glActiveTexture</span>(GL_TEXTURE0 + i);</span><br><span class="line">    <span class="comment">// 绑定纹理</span></span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, textures[i]);</span><br><span class="line">    <span class="comment">// 将对应的YUV数据设置到纹理上</span></span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D,</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 GL_LUMINANCE,</span><br><span class="line">                 texture-&gt;pitches[i],</span><br><span class="line">                 heights[i],</span><br><span class="line">                 <span class="number">0</span>,</span><br><span class="line">                 GL_LUMINANCE,</span><br><span class="line">                 GL_UNSIGNED_BYTE,</span><br><span class="line">                 <span class="comment">// 具体数据</span></span><br><span class="line">                 texture-&gt;pixels[i]);</span><br><span class="line">    <span class="comment">// 设置纹理变量对应的纹理单元层</span></span><br><span class="line">    <span class="built_in">glUniform1i</span>(inputTextureHandle[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制平面矩形</span></span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLE_STRIP, <span class="number">0</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>将OpenGL-ES生成的图像数据加入到EGLSurface绑定的Surface中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当opengl-es将内容绘制完成，调用该方法将该缓冲区加入到Surface的BufferQueue中</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglSwapBuffers</span>(display, eglSurface)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android播放音频</title>
    <url>/2020/07/22/av/Android%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<p>SDL是一个跨平台的音视频渲染库，是支持Android平台的，所以可以直接使用SDL库进行音频的播放。</p>
<p>但是SDL库在Android平台上的实现只有一种，就是通过JNI来调用Java层的AudioTrack来进行播放。所以如果你有其它的需求不想使用SDL库，那么可以直接使用Android平台原生API来播放音频。</p>
<h1 id="Android平台音频播放API"><a href="#Android平台音频播放API" class="headerlink" title="Android平台音频播放API"></a>Android平台音频播放API</h1><p>前面录制的时候讲过，Android上音频输出的API比较繁琐，有多套实现。有Java层的实现AudioTrack，也有native层实现OpenSLES，在 Android O上又推出了新的native层实现AAudio，并且提供了Oboe库，对OpenSLES和AAudio进行了封装。</p>
<span id="more"></span>

<p>下面来详细的介绍下每套API的使用</p>
<h2 id="AudioTrack"><a href="#AudioTrack" class="headerlink" title="AudioTrack"></a>AudioTrack</h2><p>AudioTrack是Android平台提供的播放音频的Java层API，使用起来非常简单。通过设置待播放音频参数就可以创建一个AudioTrack对象，调用了play方法后，就可以开始写入数据了，通过write方法将数据写入，调用stop后就停止播放。</p>
<p>需要注意的是，在创建AudioTrack的时候，对于待播放的音频数据格式都已经设定好了，也就是说这个创建的AudioTrack只能播放这种格式的音频数据。所以一般在获取到音频流解码后，都需要将PCM数据进行重采样，重采样成和AudioTrack一样的数据格式，才能交给AudioTrack播放。</p>
<h3 id="创建AudioTrack"><a href="#创建AudioTrack" class="headerlink" title="创建AudioTrack"></a>创建AudioTrack</h3><p>AudioTrack的构造函数有两套，新的一套是在Android L推出的，老的一套已经被标记为deprecated。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据指定采样率、声道数、位数获取最小需要的缓冲区大小，后续再创建AudioTrack时设置的缓冲区大小必须大于这个值</span></span><br><span class="line"><span class="comment">// 如果想要将缓冲区设大一点，比如 bufferSizeFactor = 1.5</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">minBufferSizeInBytes</span> <span class="operator">=</span> (<span class="type">int</span>) (AudioTrack.getMinBufferSize(sampleRate, channelConfig,</span><br><span class="line">                                                AudioFormat.ENCODING_PCM_16BIT) * bufferSizeFactor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个音频帧的字节大小 = 声道数 *（位数 /8）  </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">bytesPerFrame</span> <span class="operator">=</span> channels * (BITS_PER_SAMPLE / <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建buffer用来存放每一次要写入的数据，使用堆外内存，避免JNI内存拷贝</span></span><br><span class="line"><span class="comment">// BUFFERS_PER_SECOND = 100，预测一秒钟回调100次</span></span><br><span class="line"><span class="comment">// 那么44100的采样率，每次回调应该给的数据帧个数为4410个</span></span><br><span class="line">byteBuffer = ByteBuffer.allocateDirect(bytesPerFrame * (sampleRate / BUFFERS_PER_SECOND));</span><br><span class="line">    </span><br><span class="line">AudioTrack audioTrack;</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">    <span class="comment">// AudioFormat是对音频的格式进行封装，包括采样率、声道数、位数等。</span></span><br><span class="line">    <span class="comment">// AudioAttributes是对播放内容的描述</span></span><br><span class="line">    audioTrack = <span class="keyword">new</span> <span class="title class_">AudioTrack</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AudioAttributes</span>.Builder()</span><br><span class="line">                    <span class="comment">// 音频的用途</span></span><br><span class="line">                    .setUsage(usageAttribute)</span><br><span class="line">                    <span class="comment">// 音频内容的类型</span></span><br><span class="line">                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)</span><br><span class="line">                    .build(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AudioFormat</span>.Builder()</span><br><span class="line">                    <span class="comment">// 位数</span></span><br><span class="line">                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)</span><br><span class="line">                    <span class="comment">// 采样率</span></span><br><span class="line">                    .setSampleRate(sampleRateInHz)</span><br><span class="line">                    <span class="comment">// 声道数</span></span><br><span class="line">                    .setChannelMask(channelConfig)</span><br><span class="line">                    .build(),</span><br><span class="line">            bufferSizeInBytes,<span class="comment">// 缓冲区大小</span></span><br><span class="line">            AudioTrack.MODE_STREAM,<span class="comment">// 模式</span></span><br><span class="line">            <span class="comment">// 生成新的会话ID</span></span><br><span class="line">            AudioManager.AUDIO_SESSION_ID_GENERATE );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造参数：</span></span><br><span class="line">    <span class="comment">//      音频流类型</span></span><br><span class="line">    <span class="comment">//      采样率</span></span><br><span class="line">    <span class="comment">//      声道数</span></span><br><span class="line">    <span class="comment">//      位数</span></span><br><span class="line">    <span class="comment">//      缓冲区大小</span></span><br><span class="line">    <span class="comment">//      模式 : MODE_STATIC 预先将需要播放的音频数据读取到内存中，然后才开始播放。MODE_STREAM 边读边播，不会将数据直接加载到内存</span></span><br><span class="line">    audioTrack = <span class="keyword">new</span> <span class="title class_">AudioTrack</span>(AudioManager.STREAM_VOICE_CALL, sampleRateInHz, channelConfig,</span><br><span class="line">            AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes, AudioTrack.MODE_STREAM);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (audioTrack == <span class="literal">null</span> || audioTrack.getState() != AudioTrack.STATE_INITIALIZED) &#123;</span><br><span class="line">    <span class="comment">// 创建失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="播放模式"><a href="#播放模式" class="headerlink" title="播放模式"></a>播放模式</h4><p>AudioTrack支持两种模式，MODE_STATIC和 MODE_STREAM</p>
<ul>
<li>MODE_STREAM : 预先将需要播放的音频数据读取到内存中,所以如果使用这种模式，那么在创建AudioTrack的时候，传入的缓冲区大小就必须是整个播放文件的大小，AudioTrack只会播放这么多数据。</li>
<li>MODE_STREAM : 边读边播，不会将数据直接加载到内存，如果使用这种模式，需要注意<strong>每次写入的数据大小，需要确保小于或者等于创建时传入的缓冲区大小</strong>。一般使用这种模式。</li>
</ul>
<h4 id="音频流类型"><a href="#音频流类型" class="headerlink" title="音频流类型"></a>音频流类型</h4><ul>
<li>AudioManager.STREAM_VOICE_CALL : 电话</li>
<li>AudioManager.STREAM_SYSTEM : 系统</li>
<li>AudioManager.STREAM_RING : 响铃和消息</li>
<li>AudioManager.STREAM_MUSIC : 音乐</li>
<li>AudioManager.STREAM_ALARM : 闹钟</li>
<li>AudioManager.STREAM_NOTIFICATION : 通知</li>
<li>AudioManager.STREAM_BLUETOOTH_SCO : 蓝牙</li>
<li>AudioManager.STREAM_SYSTEM_ENFORCED : 强制系统声音</li>
<li>AudioManager.STREAM_DTMF : 双音多频</li>
<li>AudioManager.STREAM_TTS : 语音</li>
</ul>
<!-- more -->

<h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 开始播放</span></span><br><span class="line">audioTrack.play();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据，使用阻塞模式WRITE_BLOCKING，如果缓冲区满了，则阻塞等待</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用Buffer来传递到Native层，buffer创建时分配堆外内存，这样在JNI传递时避免了内存拷贝</span></span><br><span class="line">    audioTrack.write(byteBuffer, sizeInBytes, AudioTrack.WRITE_BLOCKING);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用byte array来传递到Native层，需要内存拷贝</span></span><br><span class="line">    audioTrack.write(byteBuffer.array(), byteBuffer.arrayOffset(), sizeInBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止播放</span></span><br><span class="line">audioTrack.stop();</span><br></pre></td></tr></table></figure>

<h2 id="OpenSL-ES"><a href="#OpenSL-ES" class="headerlink" title="OpenSL-ES"></a>OpenSL-ES</h2><p>OpenSL-ES是Android平台上提供的高性能音频的API，相对Java层API有着一定的低延迟性。由于是C库，所以使用起来API相对繁琐一些。</p>
<h3 id="配置数据参数"><a href="#配置数据参数" class="headerlink" title="配置数据参数"></a>配置数据参数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">// 创建播放数据格式  </span></span><br><span class="line">SLDataFormat_PCM format;</span><br><span class="line"><span class="comment">// 数据格式</span></span><br><span class="line">format.formatType = SL_DATAFORMAT_PCM;</span><br><span class="line"><span class="comment">// 声道数</span></span><br><span class="line">format.numChannels = <span class="built_in">static_cast</span>&lt;SLuint32&gt;(channels);</span><br><span class="line"><span class="comment">// 采样率</span></span><br><span class="line"><span class="keyword">switch</span> (sample_rate) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_8;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">16000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_16;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">22050</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_22_05;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">32000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_32;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">44100</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_44_1;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">48000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_48;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">64000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_64;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">88200</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_88_2;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">96000</span>:</span><br><span class="line">    format.samplesPerSec = SL_SAMPLINGRATE_96;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">RTC_CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unsupported sample rate: &quot;</span> &lt;&lt; sample_rate;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 位数</span></span><br><span class="line">format.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line">format.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;</span><br><span class="line"><span class="comment">// 小端</span></span><br><span class="line">format.endianness = SL_BYTEORDER_LITTLEENDIAN;</span><br><span class="line"><span class="keyword">if</span> (format.numChannels == <span class="number">1</span>) &#123;</span><br><span class="line">  format.channelMask = SL_SPEAKER_FRONT_CENTER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (format.numChannels == <span class="number">2</span>) &#123;</span><br><span class="line">  format.channelMask = SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(<span class="literal">false</span>) &lt;&lt; <span class="string">&quot;Unsupported number of channels: &quot;</span></span><br><span class="line">                   &lt;&lt; format.numChannels;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建引擎"><a href="#创建引擎" class="headerlink" title="创建引擎"></a>创建引擎</h3><p>在OpenSLES中，任何API接口对象都要由引擎来创建</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置线程安全模式</span></span><br><span class="line"><span class="type">const</span> SLEngineOption option[] = &#123;</span><br><span class="line">    &#123;SL_ENGINEOPTION_THREADSAFE, <span class="built_in">static_cast</span>&lt;SLuint32&gt;(SL_BOOLEAN_TRUE)&#125;&#125;;</span><br><span class="line"><span class="comment">// 创建引擎接口</span></span><br><span class="line">SLresult result =</span><br><span class="line">    <span class="built_in">slCreateEngine</span>(engine_object_, <span class="number">1</span>, option, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置引擎实现模式为同步模式</span></span><br><span class="line">result = engine_object_-&gt;<span class="built_in">Realize</span>(engine_object_, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (result != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据引擎接口获取到隐藏的引擎实现</span></span><br><span class="line"><span class="keyword">if</span> ((*engine_object)</span><br><span class="line">            -&gt;<span class="built_in">GetInterface</span>(engine_object, SL_IID_ENGINE, &amp;engine_)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建播放器"><a href="#创建播放器" class="headerlink" title="创建播放器"></a>创建播放器</h3><p>在OpenSLES中，播放需要通过播放器对象来进行，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过引擎实现创建混音器接口</span></span><br><span class="line">(*engine_)-&gt;<span class="built_in">CreateOutputMix</span>(engine_, output_mix_, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置混音器实现模式为同步模式</span></span><br><span class="line">output_mix_-&gt;<span class="built_in">Realize</span>(output_mix_.<span class="built_in">Get</span>(), SL_BOOLEAN_FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置缓冲队列大小</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue simple_buffer_queue = &#123;</span><br><span class="line">    SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">    <span class="built_in">static_cast</span>&lt;SLuint32&gt;(kNumOfOpenSLESBuffers)&#125;;</span><br><span class="line"><span class="comment">// 设置数据源的缓冲队列和数据格式</span></span><br><span class="line">SLDataSource audio_source = &#123;&amp;simple_buffer_queue, &amp;pcm_format_&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置输出混音器</span></span><br><span class="line">SLDataLocator_OutputMix locator_output_mix = &#123;SL_DATALOCATOR_OUTPUTMIX,</span><br><span class="line">                                              output_mix_&#125;;</span><br><span class="line"><span class="comment">// 设置数据接收器的混音器                                              </span></span><br><span class="line">SLDataSink audio_sink = &#123;&amp;locator_output_mix, <span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">const</span> SLInterfaceID interface_ids[] = &#123;SL_IID_ANDROIDCONFIGURATION,</span><br><span class="line">                                       SL_IID_BUFFERQUEUE, SL_IID_VOLUME&#125;;</span><br><span class="line"><span class="type">const</span> SLboolean interface_required[] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE,</span><br><span class="line">                                        SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引擎实现创建播放器接口</span></span><br><span class="line">(*engine_)-&gt;<span class="built_in">CreateAudioPlayer</span>(</span><br><span class="line">        engine_, player_object_, &amp;audio_source, &amp;audio_sink,</span><br><span class="line">        <span class="built_in">arraysize</span>(interface_ids), interface_ids, interface_required);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过播放器接口创建播放器配置实现，用来设置相关播放配置参数</span></span><br><span class="line">SLAndroidConfigurationItf player_config;</span><br><span class="line">player_object_-&gt;<span class="built_in">GetInterface</span>(player_object_,</span><br><span class="line">                                 SL_IID_ANDROIDCONFIGURATION, &amp;player_config);</span><br><span class="line"><span class="comment">// 设置音频流类型</span></span><br><span class="line">SLint32 stream_type = SL_ANDROID_STREAM_VOICE;</span><br><span class="line"><span class="comment">// 设置参数</span></span><br><span class="line">(*player_config)-&gt;<span class="built_in">SetConfiguration</span>(player_config, SL_ANDROID_KEY_STREAM_TYPE,</span><br><span class="line">                           &amp;stream_type, <span class="built_in">sizeof</span>(SLint32));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置播放器实现模式为同步模式</span></span><br><span class="line">player_object_-&gt;<span class="built_in">Realize</span>(player_object_, SL_BOOLEAN_FALSE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过播放器接口创建播放器实现，用来播放数据</span></span><br><span class="line">player_object_-&gt;<span class="built_in">GetInterface</span>(player_object_, SL_IID_PLAY, &amp;player_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过播放器接口创建缓冲队列实现，用来传递数据</span></span><br><span class="line">player_object_-&gt;<span class="built_in">GetInterface</span>(player_object_, SL_IID_BUFFERQUEUE,</span><br><span class="line">                                 &amp;simple_buffer_queue_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册在缓冲队列上的回调，通过回调来通知写入数据，SimpleBufferQueueCallback就是回调函数，this是回调参数的context参数</span></span><br><span class="line"><span class="comment">// 当回调触发，则说明播放器需要数据，将数据写入到缓冲队列中即可</span></span><br><span class="line">(*simple_buffer_queue_)-&gt;<span class="built_in">RegisterCallback</span>(simple_buffer_queue_,</span><br><span class="line">                                       SimpleBufferQueueCallback, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过播放器接口创建音量实现，用来控制音量</span></span><br><span class="line">player_object_-&gt;<span class="built_in">GetInterface</span>(player_object_, SL_IID_VOLUME, &amp;volume_);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="写入数据-1"><a href="#写入数据-1" class="headerlink" title="写入数据"></a>写入数据</h3><p>每次回调函数被触发，则说明播放器需要数据，通过调用Enqueue函数将数据写入到缓冲队列中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenSLESPlayer::SimpleBufferQueueCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    SLAndroidSimpleBufferQueueItf caller,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据回调函数，context就是在设置回调时设置的this</span></span><br><span class="line">  OpenSLESPlayer* stream = <span class="built_in">reinterpret_cast</span>&lt;OpenSLESPlayer*&gt;(context);</span><br><span class="line">  <span class="comment">// 写入数据，Enqueue（缓冲队列，buffer数据，数据size）</span></span><br><span class="line">  SLresult err = (*simple_buffer_queue_)-&gt;<span class="built_in">Enqueue</span>(simple_buffer_queue_, audio_ptr8,</span><br><span class="line">                               audio_parameters_.<span class="built_in">GetBytesPerBuffer</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android硬件解封装</title>
    <url>/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<h1 id="硬件解封装"><a href="#硬件解封装" class="headerlink" title="硬件解封装"></a>硬件解封装</h1><p>Android平台针对音视频封装提供了<strong>MediaMuxer API</strong>，支持.mp4格式的封装；针对解封装提供了<strong>MediaExtractor API</strong>，支持.mp4等格式。</p>
<h1 id="API架构"><a href="#API架构" class="headerlink" title="API架构"></a>API架构</h1><p>在 <strong>frameworks&#x2F;base&#x2F;media</strong> 文件夹中提供了所有音视频相关的Java层API，本文中讲述的解封装API都定义在该处。而具体的服务实现都在 <strong>frameworks&#x2F;av</strong> 文件夹中</p>
<p><img src="/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/android_muxer_demuxer.jpg"></p>
<p>自7.0开始，MediaService被拆分成多个服务，每个服务都运行在各自的进程中。</p>
<span id="more"></span>

<h1 id="MediaExtractor-解封装"><a href="#MediaExtractor-解封装" class="headerlink" title="MediaExtractor 解封装"></a>MediaExtractor 解封装</h1><p>MediaExtractor类是官方提供的音视频解封装类。其官方使用Demo如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建解封装器 </span></span><br><span class="line"><span class="type">MediaExtractor</span> <span class="variable">extractor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaExtractor</span>();</span><br><span class="line"><span class="comment">// 设置数据源</span></span><br><span class="line"> extractor.setDataSource(...);</span><br><span class="line"><span class="comment">// 遍历所有轨道</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">numTracks</span> <span class="operator">=</span> extractor.getTrackCount();</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numTracks; ++i) &#123;</span><br><span class="line">   <span class="type">MediaFormat</span> <span class="variable">format</span> <span class="operator">=</span> extractor.getTrackFormat(i);</span><br><span class="line">   <span class="type">String</span> <span class="variable">mime</span> <span class="operator">=</span> format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">   <span class="comment">// 根据轨道类型选择想要的轨道</span></span><br><span class="line">   <span class="keyword">if</span> (weAreInterestedInThisTrack) &#123;</span><br><span class="line">     extractor.selectTrack(i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">ByteBuffer</span> <span class="variable">inputBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(...)</span><br><span class="line"> <span class="comment">// 读取选中轨道的样本数据</span></span><br><span class="line"> <span class="keyword">while</span> (extractor.readSampleData(inputBuffer, ...) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">trackIndex</span> <span class="operator">=</span> extractor.getSampleTrackIndex();</span><br><span class="line">   <span class="type">long</span> <span class="variable">presentationTimeUs</span> <span class="operator">=</span> extractor.getSampleTime();</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// 下一个样本</span></span><br><span class="line">   extractor.advance();</span><br><span class="line"> &#125;</span><br><span class="line"> extractor.release();</span><br><span class="line"> extractor = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h2 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h2><p><img src="/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/media_extractor_support.png"></p>
<h2 id="注册解封装器"><a href="#注册解封装器" class="headerlink" title="注册解封装器"></a>注册解封装器</h2><p>在<strong>MediaExtractorService</strong>被创建的时候，会注册所有的Extractor实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libDirPath 有两个，一个是 /apex/com.android.media/lib/extractors/ ，另一个是/system/lib/extractors/ </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MediaExtractorFactory::RegisterExtractors</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *libDirPath, <span class="type">const</span> android_dlextinfo* dlextinfo,</span></span><br><span class="line"><span class="params">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;sp&lt;ExtractorPlugin&gt;&gt; &amp;pluginList)</span> &#123;</span><br><span class="line">    DIR *libDir = opendir(libDirPath);</span><br><span class="line">    <span class="keyword">if</span> (libDir) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">libEntry</span>;</span></span><br><span class="line">        <span class="keyword">while</span> ((libEntry = readdir(libDir))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (libEntry-&gt;d_name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String8 libPath = String8(libDirPath) + <span class="string">&quot;/&quot;</span> + libEntry-&gt;d_name;</span><br><span class="line">            <span class="keyword">if</span> (!libPath.contains(<span class="string">&quot;extractor.so&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 加载 extractor.so</span></span><br><span class="line">            <span class="type">void</span> *libHandle = android_dlopen_ext(</span><br><span class="line">                    libPath.<span class="built_in">string</span>(),</span><br><span class="line">                    RTLD_NOW | RTLD_LOCAL, dlextinfo);</span><br><span class="line">         </span><br><span class="line">            <span class="comment">// 查找GETEXTRACTORDEF函数</span></span><br><span class="line">            GetExtractorDef getDef =</span><br><span class="line">                (GetExtractorDef) dlsym(libHandle, <span class="string">&quot;GETEXTRACTORDEF&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行GETEXTRACTORDEF函数，获取到解封装器配置，创建一个Plugin，加入到list中</span></span><br><span class="line">            RegisterExtractor(</span><br><span class="line">                    new ExtractorPlugin(getDef(), libHandle, libPath), pluginList);</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(libDir);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;couldn&#x27;t opendir(%s)&quot;</span>, libDirPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<p>MPEG-4的GETEXTRACTORDEF函数，其中的 Sniff方法就是创建对象的构造器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ExtractorDef <span class="title function_">GETEXTRACTORDEF</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        EXTRACTORDEF_VERSION,</span><br><span class="line">        UUID(<span class="string">&quot;27575c67-4417-4c54-8d3d-8e626985a164&quot;</span>),</span><br><span class="line">        <span class="number">2</span>, <span class="comment">// version</span></span><br><span class="line">        <span class="string">&quot;MP4 Extractor&quot;</span>,</span><br><span class="line">        &#123; .v3 = &#123;Sniff, extensions&#125; &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="创建解封装器"><a href="#创建解封装器" class="headerlink" title="创建解封装器"></a>创建解封装器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sp&lt;IMediaExtractor&gt; <span class="title function_">MediaExtractorFactory::CreateFromService</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">const</span> <span class="type">char</span> *mime)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上面注册的Sniff函数，获取最合适的解封装器的CreateExtractor函数。</span></span><br><span class="line">    creator = sniff(source, &amp;confidence, &amp;meta, &amp;freeMeta, plugin, &amp;creatorVersion);</span><br><span class="line">    <span class="keyword">if</span> (!creator) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;FAILED to autodetect media content.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MediaExtractor *ex = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (creatorVersion == EXTRACTORDEF_VERSION_NDK_V1 ||</span><br><span class="line">            creatorVersion == EXTRACTORDEF_VERSION_NDK_V2) &#123;</span><br><span class="line">        <span class="comment">// 创建具体的解封装器实例</span></span><br><span class="line">        CMediaExtractor *ret = ((CreatorFunc)creator)(source-&gt;wrap(), meta);</span><br><span class="line">        <span class="keyword">if</span> (meta != nullptr &amp;&amp; freeMeta != nullptr) &#123;</span><br><span class="line">            freeMeta(meta);</span><br><span class="line">        &#125;</span><br><span class="line">        ex = ret != nullptr ? new MediaExtractorCUnwrapper(ret) : nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CreateIMediaExtractorFromMediaExtractor(ex, source, plugin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择最合适的解封装器实例"><a href="#选择最合适的解封装器实例" class="headerlink" title="选择最合适的解封装器实例"></a>选择最合适的解封装器实例</h3><p>选择具体格式的封装器是通过将DataSource依次给所有已经注册的解封装器的Sniff函数进行尝试，每次尝试都会有一个分数返回，保存在confidence中，最终会选择分数最大的做为最终的解封装器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">MediaExtractorFactory::sniff</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> sp&lt;DataSource&gt; &amp;source, <span class="type">float</span> *confidence, <span class="type">void</span> **meta,</span></span><br><span class="line"><span class="params">        FreeMetaFunc *freeMeta, sp&lt;ExtractorPlugin&gt; &amp;plugin, <span class="type">uint32_t</span> *creatorVersion)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始分数为0</span></span><br><span class="line">  	*confidence = <span class="number">0.0f</span>;</span><br><span class="line">    *meta = nullptr;</span><br><span class="line">    <span class="comment">// 所有注册的解封装器实例</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">list</span>&lt;sp&lt;ExtractorPlugin&gt;&gt;&gt; plugins;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock <span class="title function_">autoLock</span><span class="params">(gPluginMutex)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!gPluginsRegistered) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        plugins = gPlugins;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="type">void</span> *bestCreator = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = plugins-&gt;begin(); it != plugins-&gt;end(); ++it) &#123;</span><br><span class="line">        ALOGV(<span class="string">&quot;sniffing %s&quot;</span>, (*it)-&gt;def.extractor_name);</span><br><span class="line">        <span class="type">float</span> newConfidence;</span><br><span class="line">        <span class="type">void</span> *newMeta = nullptr;</span><br><span class="line">        FreeMetaFunc newFreeMeta = nullptr;</span><br><span class="line">        <span class="comment">// 执行对应实例的Sniff函数</span></span><br><span class="line">        <span class="type">void</span> *curCreator = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*it)-&gt;def.def_version == EXTRACTORDEF_VERSION_NDK_V1) &#123;</span><br><span class="line">            curCreator = (<span class="type">void</span>*) (*it)-&gt;def.u.v2.sniff(</span><br><span class="line">                    source-&gt;wrap(), &amp;newConfidence, &amp;newMeta, &amp;newFreeMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((*it)-&gt;def.def_version == EXTRACTORDEF_VERSION_NDK_V2) &#123;</span><br><span class="line">            curCreator = (<span class="type">void</span>*) (*it)-&gt;def.u.v3.sniff(</span><br><span class="line">                    source-&gt;wrap(), &amp;newConfidence, &amp;newMeta, &amp;newFreeMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果实例创建成功</span></span><br><span class="line">        <span class="keyword">if</span> (curCreator) &#123;</span><br><span class="line">            <span class="comment">// 则对比分数，分数大于上次的则将该实例作为最合适实例；</span></span><br><span class="line">            <span class="keyword">if</span> (newConfidence &gt; *confidence) &#123;</span><br><span class="line">                *confidence = newConfidence;</span><br><span class="line">                <span class="keyword">if</span> (*meta != nullptr &amp;&amp; *freeMeta != nullptr) &#123;</span><br><span class="line">                    (*freeMeta)(*meta);</span><br><span class="line">                &#125;</span><br><span class="line">                *meta = newMeta;</span><br><span class="line">                *freeMeta = newFreeMeta;</span><br><span class="line">                plugin = *it;</span><br><span class="line">                bestCreator = curCreator;</span><br><span class="line">                *creatorVersion = (*it)-&gt;def.def_version;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 小于则释放</span></span><br><span class="line">                <span class="keyword">if</span> (newMeta != nullptr &amp;&amp; newFreeMeta != nullptr) &#123;</span><br><span class="line">                    newFreeMeta(newMeta);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回分数最高的实例</span></span><br><span class="line">    <span class="keyword">return</span> bestCreator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WAV解封装器"><a href="#WAV解封装器" class="headerlink" title="WAV解封装器"></a>WAV解封装器</h3><p>下面就是WAV格式的解封装器的Sniff函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> CreatorFunc <span class="title function_">Sniff</span><span class="params">(</span></span><br><span class="line"><span class="params">        CDataSource *source,</span></span><br><span class="line"><span class="params">        <span class="type">float</span> *confidence,</span></span><br><span class="line"><span class="params">        <span class="type">void</span> **,</span></span><br><span class="line"><span class="params">        FreeMetaFunc *)</span> &#123;</span><br><span class="line">    DataSourceHelper *helper = new DataSourceHelper(source);</span><br><span class="line">    <span class="type">char</span> header[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">if</span> (helper-&gt;readAt(<span class="number">0</span>, header, <span class="keyword">sizeof</span>(header)) &lt; (<span class="type">ssize_t</span>)<span class="keyword">sizeof</span>(header)) &#123;</span><br><span class="line">        delete helper;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(header, <span class="string">&quot;RIFF&quot;</span>, <span class="number">4</span>) || <span class="built_in">memcmp</span>(&amp;header[<span class="number">8</span>], <span class="string">&quot;WAVE&quot;</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        delete helper;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WAVExtractor *extractor = new WAVExtractor(helper); <span class="comment">// extractor owns the helper</span></span><br><span class="line">    <span class="type">int</span> numTracks = extractor-&gt;countTracks();</span><br><span class="line">    delete extractor;</span><br><span class="line">    <span class="keyword">if</span> (numTracks == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *confidence = <span class="number">0.3f</span>;</span><br><span class="line">    <span class="keyword">return</span> CreateExtractor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重要方法详解"><a href="#重要方法详解" class="headerlink" title="重要方法详解"></a>重要方法详解</h2><h3 id="setDataSource"><a href="#setDataSource" class="headerlink" title="setDataSource"></a>setDataSource</h3><p>​	方法很简单，就是设置数据源，对于数据源的协议目前只支持本地文件和HTTP、HTTPS。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sp&lt;DataSource&gt; <span class="title function_">DataSourceFactory::CreateFromURI</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> sp&lt;MediaHTTPService&gt; &amp;httpService,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *uri,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> KeyedVector&lt;String8, String8&gt; *headers,</span></span><br><span class="line"><span class="params">        String8 *contentType,</span></span><br><span class="line"><span class="params">        HTTPBase *httpSource)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *contentType = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;DataSource&gt; source;</span><br><span class="line">    <span class="keyword">if</span> (!strncasecmp(<span class="string">&quot;file://&quot;</span>, uri, <span class="number">7</span>)) &#123;</span><br><span class="line">        <span class="comment">// 本地文件</span></span><br><span class="line">        source = CreateFileSource(uri + <span class="number">7</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(<span class="string">&quot;http://&quot;</span>, uri, <span class="number">7</span>) || !strncasecmp(<span class="string">&quot;https://&quot;</span>, uri, <span class="number">8</span>)) &#123;</span><br><span class="line">      	<span class="comment">// HTTP HTTPS</span></span><br><span class="line">        sp&lt;HTTPBase&gt; mediaHTTP = httpSource;</span><br><span class="line">        <span class="keyword">if</span> (mediaHTTP == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mediaHTTP = static_cast&lt;HTTPBase *&gt;(CreateMediaHTTP(httpService).get());</span><br><span class="line">        &#125;</span><br><span class="line">        String8 cacheConfig;</span><br><span class="line">        <span class="type">bool</span> disconnectAtHighwatermark = <span class="literal">false</span>;</span><br><span class="line">        KeyedVector&lt;String8, String8&gt; nonCacheSpecificHeaders;</span><br><span class="line">        <span class="keyword">if</span> (headers != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            nonCacheSpecificHeaders = *headers;</span><br><span class="line">            NuCachedSource2::RemoveCacheSpecificHeaders(</span><br><span class="line">                    &amp;nonCacheSpecificHeaders,</span><br><span class="line">                    &amp;cacheConfig,</span><br><span class="line">                    &amp;disconnectAtHighwatermark);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mediaHTTP-&gt;connect(uri, &amp;nonCacheSpecificHeaders) != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">&quot;Failed to connect http source!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *contentType = mediaHTTP-&gt;getMIMEType();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source = NuCachedSource2::Create(</span><br><span class="line">                mediaHTTP,</span><br><span class="line">                cacheConfig.isEmpty() ? <span class="literal">NULL</span> : cacheConfig.<span class="built_in">string</span>(),</span><br><span class="line">                disconnectAtHighwatermark);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(<span class="string">&quot;data:&quot;</span>, uri, <span class="number">5</span>)) &#123;</span><br><span class="line">        source = DataURISource::Create(uri);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果scheme都不符合，则假设其是个本地文件</span></span><br><span class="line">        source = CreateFileSource(uri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="literal">NULL</span> || source-&gt;initCheck() != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="selectTrack、unselectTrack"><a href="#selectTrack、unselectTrack" class="headerlink" title="selectTrack、unselectTrack"></a>selectTrack、unselectTrack</h3><p>选中指定轨道和解除选中。一个媒体文件中会包含着多个轨道，比如音频轨道和视频轨道等，在MediaExtractor中对样本数据的操作都是基于指定的轨道来的，所以在操作样本数据之前，必须先选中一个轨道。</p>
<p>当一个轨道被选中后，后续的<strong>getSamplexxx</strong>方法都是针对该轨道，如果想换一个轨道进行处理，则必须先解除当前轨道的选中，调用unselectTrack函数。</p>
<p>对于如何选择想要的轨道，可以通过<strong>getTrackFormat</strong>方法来获取每一个轨道的详细信息，通过这些信息筛选出想要处理的轨道。</p>
<h3 id="getTrackCount"><a href="#getTrackCount" class="headerlink" title="getTrackCount"></a>getTrackCount</h3><p>获取当前媒体文件中的轨道数量，通常用来遍历所有的轨道。</p>
<h3 id="getTrackFormat"><a href="#getTrackFormat" class="headerlink" title="getTrackFormat"></a>getTrackFormat</h3><p>获取指定索引的轨道的详细信息，索引的值从0开始递增。轨道信息在不同Android版本上有不同的支持，在使用的时候需要注意。</p>
<p><img src="/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/media_extractor_format_key.png"></p>
<blockquote>
<p>这里有一点需要注意，就是在使用轨道的MediaFormat对象去创建解码器的时候，最好先将KEY_LEVEL的值设置为null（<code>MediaFormat.setString(KEY_LEVEL, null)</code>），因为这个值经常不准。</p>
</blockquote>
<h3 id="readSampleData"><a href="#readSampleData" class="headerlink" title="readSampleData"></a>readSampleData</h3><p>读取当前选中的轨道的一个样本数据，返回读取的size，这里要注意的是buffer的大小，需要足够大，否则无法一次读取完一个样本，通常可以使用<strong>MediaFormat.KEY_MAX_INPUT_SIZE</strong>来获取。</p>
<p>返回-1则表示当前轨道已经没有可读取的样本数据了。</p>
<h3 id="getSampleTrackIndex"><a href="#getSampleTrackIndex" class="headerlink" title="getSampleTrackIndex"></a>getSampleTrackIndex</h3><p>查询当前样本来源的轨道索引，也就是当前选中的轨道索引。如果当前轨道没有可读取的样本数据，会返回-1。</p>
<h3 id="getSampleTime"><a href="#getSampleTime" class="headerlink" title="getSampleTime"></a>getSampleTime</h3><p>返回当前样本的PTS，微秒。</p>
<h3 id="getSmapleFlags"><a href="#getSmapleFlags" class="headerlink" title="getSmapleFlags"></a>getSmapleFlags</h3><p>返回当前样本的标记，通过标记可以判断当前样本的一些特征。</p>
<ul>
<li>SAMPLE_FLAG_ENCRYPTED 样本数据被加密</li>
<li>SAMPLE_FLAG_SYNC 样本为关键帧</li>
</ul>
<h3 id="seekTo"><a href="#seekTo" class="headerlink" title="seekTo"></a>seekTo</h3><p>根据指定模式跳转到指定时间，只能跳转到关键帧，所以最终时间可能会和指定时间有误差。模式有三种：</p>
<ul>
<li>SEEK_TO_CLOSEST_SYNC 在指定时间的前后查找最近关键帧</li>
<li>SEEK_TO_NEXT_SYNC 在指定时间的后面查找最近关键帧</li>
<li>SEEK_TO_PREVIOUS_SYNC 在指定时间的前面查找最近关键帧</li>
</ul>
<h3 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h3><p>移动到下一个样本，每次读取完样本数据后，都需要调用该方法，此时调用<strong>getSmaplexxx</strong>方法读取到的才是下一个样本的数据。</p>
<p>如果当前轨道没有可读样本，则返回false。</p>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><p>释放资源</p>
<h1 id="MediaMuxer-封装"><a href="#MediaMuxer-封装" class="headerlink" title="MediaMuxer 封装"></a>MediaMuxer 封装</h1><p>MediaMuxer类是官方提供的音视频封装类。其官方使用Demo如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建封装器，指定输出文件和封装格式。</span></span><br><span class="line"><span class="type">MediaMuxer</span> <span class="variable">muxer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaMuxer</span>(<span class="string">&quot;temp.mp4&quot;</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"><span class="comment">// 创建音频和视频轨道</span></span><br><span class="line"><span class="type">MediaFormat</span> <span class="variable">audioFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaFormat</span>(...);</span><br><span class="line"><span class="type">MediaFormat</span> <span class="variable">videoFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaFormat</span>(...);</span><br><span class="line"><span class="comment">// 将轨道添加到封装器中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">audioTrackIndex</span> <span class="operator">=</span> muxer.addTrack(audioFormat);</span><br><span class="line"><span class="type">int</span> <span class="variable">videoTrackIndex</span> <span class="operator">=</span> muxer.addTrack(videoFormat);</span><br><span class="line"><span class="comment">// 创建一个buffer用来接收样本数据</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">inputBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(bufferSize);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">finished</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">BufferInfo</span> <span class="variable">bufferInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferInfo</span>();</span><br><span class="line"><span class="comment">// 启动封装器，启动后不可再更改</span></span><br><span class="line">muxer.start();</span><br><span class="line"><span class="keyword">while</span>(!finished) &#123;</span><br><span class="line">  <span class="comment">// 循环写入样本数据到指定轨道中</span></span><br><span class="line">  finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);</span><br><span class="line">  <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">currentTrackIndex</span> <span class="operator">=</span> isAudioSample ? audioTrackIndex : videoTrackIndex;</span><br><span class="line">    muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 停止封装器</span></span><br><span class="line">muxer.stop();</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">muxer.release();</span><br></pre></td></tr></table></figure>

<h2 id="支持的格式-1"><a href="#支持的格式-1" class="headerlink" title="支持的格式"></a>支持的格式</h2><p><img src="/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/media_muxer_support.png"></p>
<h2 id="创建封装器"><a href="#创建封装器" class="headerlink" title="创建封装器"></a>创建封装器</h2><p>封装器的创建比较简单，根据指定的OutputFormat来创建对应格式的封装器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">isMp4Format</span><span class="params">(MediaMuxer::OutputFormat format)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> format == MediaMuxer::OUTPUT_FORMAT_MPEG_4 ||</span><br><span class="line">           format == MediaMuxer::OUTPUT_FORMAT_THREE_GPP ||</span><br><span class="line">           format == MediaMuxer::OUTPUT_FORMAT_HEIF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MediaMuxer::MediaMuxer(<span class="type">int</span> fd, OutputFormat format)</span><br><span class="line">    : mFormat(format),</span><br><span class="line">      mState(UNINITIALIZED) &#123;</span><br><span class="line">    <span class="comment">// 根据指定format创建对应的writer</span></span><br><span class="line">    <span class="keyword">if</span> (isMp4Format(format)) &#123;</span><br><span class="line">        mWriter = new MPEG4Writer(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == OUTPUT_FORMAT_WEBM) &#123;</span><br><span class="line">        mWriter = new WebmWriter(fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == OUTPUT_FORMAT_OGG) &#123;</span><br><span class="line">        mWriter = new OggWriter(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mWriter != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mFileMeta = new MetaData;</span><br><span class="line">        <span class="keyword">if</span> (format == OUTPUT_FORMAT_HEIF) &#123;</span><br><span class="line">            <span class="comment">// Note that the key uses recorder file types.</span></span><br><span class="line">            mFileMeta-&gt;setInt32(kKeyFileType, output_format::OUTPUT_FORMAT_HEIF);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (format == OUTPUT_FORMAT_OGG) &#123;</span><br><span class="line">            mFileMeta-&gt;setInt32(kKeyFileType, output_format::OUTPUT_FORMAT_OGG);</span><br><span class="line">        &#125;</span><br><span class="line">        mState = INITIALIZED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重要方法详解-1"><a href="#重要方法详解-1" class="headerlink" title="重要方法详解"></a>重要方法详解</h2><h3 id="addTrack"><a href="#addTrack" class="headerlink" title="addTrack"></a>addTrack</h3><p>创建了封装器后，需要添加对应的轨道，轨道的信息通过MediaFormat来描述，也就是上面解封装器中通过<strong>getTrackFormat</strong>方法获取到的信息，通过这些信息添加一个轨道，添加成功返回轨道的索引，后续write数据的时候使用该索引即可。</p>
<p>对于音频轨道，需要添加的是KEY_SAMPLE_RATE 采样率以及KEY_CHANNEL_COUT声道数，需要注意的是CSD的添加。</p>
<p>对于视频轨道，处理必要的KEY_WIDTH和KEY_HEIGHT外，需要注意的有KEY_BIT_RATE码率和CSD的添加。</p>
<blockquote>
<p>关于CSD这里简单介绍下，也就是Codec-Specific Data，对于H.264来说，csd-0的数据为SPS序列参数集，csd-1的数据为PPS图像参数集，而对于AAC来说，csd-0的数据为ESDS。</p>
</blockquote>
<p>那么对于MediaFormat的key在不同版本中的支持情况与接封装器中的又不太一样，使用的时候需要注意参考下表。</p>
<p><img src="/2020/04/12/av/Android%E7%A1%AC%E4%BB%B6%E8%A7%A3%E5%B0%81%E8%A3%85/media_muxer_format_key.png"></p>
<h3 id="writeSampleData"><a href="#writeSampleData" class="headerlink" title="writeSampleData"></a>writeSampleData</h3><p>将编码后的样本数据写入到封装器中的指定轨道中，参数为轨道索引、数据buffer、bufferInfo。buffer和bufferInfo都是通过MediaCodec编码后产生的，需要注意的是bufferInfo的flag标记.</p>
<ul>
<li>BUFFER_FLAG_CODEC_CONFIG 表明buffer中包含CSD数据，而并非样本数据。</li>
<li>BUFFER_FLAG_END_OF_STREAM 表明流结束。</li>
<li>BUFFER_FLAG_KEY_FRAME 关键帧</li>
<li>BUFFER_FLAG_SYNC_FRAME 关键帧，API21废弃</li>
<li>BUFFER_FLAG_PARTIAL_FRAME 表明当前数据并非完整的一帧，API26添加</li>
</ul>
<blockquote>
<p>这里需要注意的一点是，CSD数据是不能通过该方法来写入的，所以在调用该方法的时候需要判断bufferInfo的flag是否有BUFFER_FLAG_CODEC_CONFIG标记，没有BUFFER_FLAG_CODEC_CONFIG标记的数据才可以用该方法写入。CSD数据需要通过添加到轨道的MediaFormat中，跟随MediaFormt被addTrack到封装器中。</p>
</blockquote>
<h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>启动封装器，启动后无法再添加轨道。</p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>停止封装器。</p>
<h3 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h3><p>释放封装器。</p>
<h1 id="MediaMetadataRetriever-获取元信息-（扩展）"><a href="#MediaMetadataRetriever-获取元信息-（扩展）" class="headerlink" title="MediaMetadataRetriever 获取元信息 （扩展）"></a>MediaMetadataRetriever 获取元信息 （扩展）</h1><p>MediaMetadataRetriever是用于获取媒体文件信息和指定帧数据的API。</p>
<h2 id="重要方法详解-2"><a href="#重要方法详解-2" class="headerlink" title="重要方法详解"></a>重要方法详解</h2><h3 id="extractMetadata"><a href="#extractMetadata" class="headerlink" title="extractMetadata"></a>extractMetadata</h3><p>查询指定的媒体信息。常用的有以下几种KEY，需要注意返回的值很有可能为空。</p>
<ul>
<li>METADATA_KEY_BITRATE  如果可用，此键检索平均比特率（以比特&#x2F;秒为单位）。</li>
<li>METADATA_KEY_CAPTURE_FRAMERATE  该键可检索原始捕获帧率（如果可用）</li>
<li>METADATA_KEY_DATE  用于检索数据源创建或修改日期的元数据键。</li>
<li>METADATA_KEY_HAS_AUDIO  如果此键存在，则媒体包含音频内容。</li>
<li>METADATA_KEY_HAS_VIDEO  如果该键存在，则媒体包含视频内容。</li>
<li>METADATA_KEY_LOCATION  该键检索位置信息（如果可用）。</li>
<li>METADATA_KEY_MIMETYPE  用于检索数据源的MIME类型的元数据密钥。</li>
<li>METADATA_KEY_TITLE  用于检索数据源标题的元数据键。</li>
<li>METADATA_KEY_VIDEO_HEIGHT  如果媒体包含视频，则此键检索其高度。</li>
<li>METADATA_KEY_VIDEO_ROTATION  如果可用，此键以度数检索视频旋转角度。</li>
<li>METADATA_KEY_VIDEO_WIDTH  如果媒体包含视频，则此键检索其宽度。</li>
</ul>
<h3 id="getFrameAtTime"><a href="#getFrameAtTime" class="headerlink" title="getFrameAtTime"></a>getFrameAtTime</h3><p>根据指定模式，返回接近指定时间的关键帧数据，以bitmap格式返回。一般使用该方法获取封面图。</p>
<ul>
<li>OPTION_CLOSEST_SYNC 在指定时间的前后查找最近关键帧</li>
<li>OPTION_NEXT_SYNC 在指定时间的后面查找最近关键帧</li>
<li>OPTION_PREVIOUS_SYNC 在指定时间的前面查找最近关键帧</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg录制视频</title>
    <url>/2020/07/14/av/FFmpeg%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<h1 id="视频录制流程"><a href="#视频录制流程" class="headerlink" title="视频录制流程"></a>视频录制流程</h1><p>前面讲解录制音频时讲过，FFmpeg对各大平台的输入和输出API进行了统一的封装，这里就不在阐述。</p>
<p>视频的录制相比音频的录制流程基本差不多，主要是去掉了FIFO队列的逻辑。另外对于视频帧来说，FFmpeg提供的SwsContext API处理较慢，一般不太使用，可以用libyuv库，或者使用OpenGL API用GPU来提速。</p>
<p><img src="/2020/07/14/av/FFmpeg%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/4E40FEDD-212D-4633-94A7-F5BC2DF0905F.png"></p>
<span id="more"></span>

<h2 id="打开视频输入"><a href="#打开视频输入" class="headerlink" title="打开视频输入"></a>打开视频输入</h2><h3 id="注册视频设备"><a href="#注册视频设备" class="headerlink" title="注册视频设备"></a>注册视频设备</h3><p>所有的输入和输出设备默认都是没有注册的，如果需要使用，需要手动调用下面的注册函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">avdevice_register_all();</span><br></pre></td></tr></table></figure>

<h3 id="创建输入上下文"><a href="#创建输入上下文" class="headerlink" title="创建输入上下文"></a>创建输入上下文</h3><p>FFmpeg将对视频文件的解封装和封装等操作都抽象到AVFormatContext中，所以视频文件的打开和输出都是要通道AVFormatContext来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mac平台上依旧使用avfoundation API</span></span><br><span class="line">AVInputFormat* format = <span class="built_in">av_find_input_format</span>(<span class="string">&quot;avfoundation&quot;</span>);</span><br><span class="line"><span class="comment">// 视频的采集必须设置采集的分辨率和帧率以及像素格式，如果设置的组合在设备上不支持，会出错</span></span><br><span class="line">AVDictionary* options = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;video_size&quot;</span>, <span class="string">&quot;1280x720&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;framerate&quot;</span>, <span class="string">&quot;30&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">av_dict_set</span>(&amp;options, <span class="string">&quot;pixel_format&quot;</span>, <span class="string">&quot;nv12&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 开启输入上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avformat_open_input</span>(&amp;fmt_ctx_in_, <span class="string">&quot;0&quot;</span>, format, &amp;options)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open input device &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  fmt_ctx_in_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="获取设备输入数据格式"><a href="#获取设备输入数据格式" class="headerlink" title="获取设备输入数据格式"></a>获取设备输入数据格式</h3><p>FFmpeg将视频文件中的每一个轨道都封装成了AVStream对象，一个正常的媒体文件一般都包含两个Stream，一个音频流和一个视频流。</p>
<p>对于这里，视频设备只有一个输入流，AVStream中包含了输入视频数据的分辨率、帧率、像素格式等视频相关信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 视频设备只有一个输入流</span></span><br><span class="line">stream_in_ = fmt_ctx_in_-&gt;streams[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<h3 id="创建解码上下文"><a href="#创建解码上下文" class="headerlink" title="创建解码上下文"></a>创建解码上下文</h3><p>FFmpeg将对视频文件的编码和解码等操作都抽象到AVCodecContext中，所以视频文件的编码和解码都是要通过AVCodecContext来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取视频输入流的编码格式，进行解码</span></span><br><span class="line">codec = <span class="built_in">avcodec_find_decoder</span>(stream_in_-&gt;codecpar-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not find input codec&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建解码上下文</span></span><br><span class="line">codec_ctx_in_ = <span class="built_in">avcodec_alloc_context3</span>(codec);</span><br><span class="line"><span class="keyword">if</span> (!codec_ctx_in_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate input codec context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将输入流中的解码参数设置给解码上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_parameters_to_context</span>(codec_ctx_in_,</span><br><span class="line">                                           stream_in_-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not copy parameters to input codec&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启解码器</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_open2</span>(codec_ctx_in_, codec, <span class="literal">nullptr</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open input codec &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打开视频输出"><a href="#打开视频输出" class="headerlink" title="打开视频输出"></a>打开视频输出</h2><h3 id="创建输出上下文"><a href="#创建输出上下文" class="headerlink" title="创建输出上下文"></a>创建输出上下文</h3><p>下面是创建了一个aac文件的输出上下文</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;/Users/gaozhenyu/Desktop/video.h264&quot;</span>;</span><br><span class="line">AVOutputFormat* oformat = <span class="built_in">av_guess_format</span>(<span class="literal">nullptr</span>, filename, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 创建输出上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avformat_alloc_output_context2</span>(&amp;fmt_ctx_out_, oformat, <span class="literal">nullptr</span>,</span><br><span class="line">                                            filename)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate output format context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启输出IO</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avio_open</span>(&amp;(fmt_ctx_out_-&gt;pb), filename, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open output file&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建指定编码器上下文"><a href="#创建指定编码器上下文" class="headerlink" title="创建指定编码器上下文"></a>创建指定编码器上下文</h3><p>使用libx264编码器来进行编码，并设置音频编码的相关参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到libx264编码器</span></span><br><span class="line">codec = <span class="built_in">avcodec_find_encoder_by_name</span>(<span class="string">&quot;libx264&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not find libfdk_aac encoder&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建输出编码上下文</span></span><br><span class="line">codec_ctx_out_ = <span class="built_in">avcodec_alloc_context3</span>(codec);</span><br><span class="line"><span class="keyword">if</span> (!stream_out_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate output codec context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置输出编码参数</span></span><br><span class="line">codec_ctx_out_-&gt;profile = FF_PROFILE_H264_HIGH;</span><br><span class="line">codec_ctx_out_-&gt;level = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">codec_ctx_out_-&gt;width = <span class="number">640</span>;</span><br><span class="line">codec_ctx_out_-&gt;height = <span class="number">520</span>;</span><br><span class="line"></span><br><span class="line">codec_ctx_out_-&gt;gop_size = <span class="number">300</span>;</span><br><span class="line">codec_ctx_out_-&gt;keyint_min = <span class="number">30</span>;</span><br><span class="line">codec_ctx_out_-&gt;max_b_frames = <span class="number">3</span>;</span><br><span class="line">codec_ctx_out_-&gt;has_b_frames = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">codec_ctx_out_-&gt;refs = <span class="number">3</span>;</span><br><span class="line">codec_ctx_out_-&gt;pix_fmt = AV_PIX_FMT_YUV420P;</span><br><span class="line">codec_ctx_out_-&gt;bit_rate = <span class="number">6000000</span>;</span><br><span class="line">codec_ctx_out_-&gt;time_base = AVRational&#123;<span class="number">1</span>, <span class="number">25</span>&#125;;</span><br><span class="line">codec_ctx_out_-&gt;framerate = AVRational&#123;<span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启编码器</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_open2</span>(codec_ctx_out_, codec, <span class="literal">nullptr</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open output codec &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建输出流"><a href="#创建输出流" class="headerlink" title="创建输出流"></a>创建输出流</h3><p>这里我们需要输出的轨道只有一个视频轨道，所以创建一个流就可以。创建完流后还需要将上面设置的视频编码相关参数设置给流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建指定编码器的输出视频流，添加到输出上下文中</span></span><br><span class="line">stream_out_ = <span class="built_in">avformat_new_stream</span>(fmt_ctx_out_, codec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将编码上下文中的参数设置给输出流</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_parameters_from_context</span>(stream_out_-&gt;codecpar,</span><br><span class="line">                                             codec_ctx_out_)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not initialize output stream parameters &quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">av_err2str</span>(error) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化图像处理上下文"><a href="#初始化图像处理上下文" class="headerlink" title="初始化图像处理上下文"></a>初始化图像处理上下文</h2><h3 id="图像处理上下文"><a href="#图像处理上下文" class="headerlink" title="图像处理上下文"></a>图像处理上下文</h3><p>FFmpeg将对视频的图像处理操作抽象到SwsContext中，根据输入的视频帧数据格式和处理后的视频帧数据格式来创建一个SwsContext。</p>
<p>实际上决定视频帧数据格式的就是三要素：宽、高、像素格式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建图像处理上下文，设置输入输出参数</span></span><br><span class="line">sws_ctx_ = <span class="built_in">sws_getContext</span>(codec_ctx_in_-&gt;width, codec_ctx_in_-&gt;height,</span><br><span class="line">                          codec_ctx_in_-&gt;pix_fmt, codec_ctx_out_-&gt;width,</span><br><span class="line">                          codec_ctx_out_-&gt;height, codec_ctx_out_-&gt;pix_fmt,</span><br><span class="line">                          SWS_BILINEAR, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!sws_ctx_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate sws context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>对于AVFormatContext来进行视频数据的输出，需要调用三个write函数，avformat_write_header、av_write_frame、av_write_trailer。</p>
<p>整体流程就是不断的从视频设备中读取数据，解码后进行图像处理，将处理后的视频帧进行编码，编码后写入到输出文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 读取数据并编码</span></span><br><span class="line"><span class="keyword">while</span> (request_abort_) &#123;</span><br><span class="line">  AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  <span class="type">int</span> data_present;</span><br><span class="line">  AVFrame* out = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line">  <span class="comment">// 读取并解码</span></span><br><span class="line">  <span class="keyword">if</span> ((error = <span class="built_in">DecodeVideoFrame</span>(frame, &amp;data_present)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Could not decoding video packet &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data_present) &#123;</span><br><span class="line">    <span class="comment">// 视频图像处理</span></span><br><span class="line">    out-&gt;format = codec_ctx_out_-&gt;pix_fmt;</span><br><span class="line">    out-&gt;width = codec_ctx_out_-&gt;width;</span><br><span class="line">    out-&gt;height = codec_ctx_out_-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((error = <span class="built_in">av_frame_get_buffer</span>(out, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Could not alloc av image&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sws_scale</span>(sws_ctx_, (<span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span>*)frame-&gt;data, frame-&gt;linesize,</span><br><span class="line">              <span class="number">0</span>, frame-&gt;height, out-&gt;data, out-&gt;linesize);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编码并写入</span></span><br><span class="line">  <span class="keyword">if</span> ((error = <span class="built_in">EncodeVideoFrame</span>(out, data_present)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Could not encodeing video frame &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">goto</span> cleanup;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="读取数据并解码"><a href="#读取数据并解码" class="headerlink" title="读取数据并解码"></a>读取数据并解码</h3><p>读取数据非常简单，创建一个AVPacket对象，通过av_read_frame就可以读取一帧数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建AVPacket，用来从视频设备中接收一帧数据</span></span><br><span class="line"><span class="built_in">av_init_packet</span>(&amp;pkt);</span><br><span class="line"><span class="comment">// 从视频设备中读取一帧数据到AVPacket中</span></span><br><span class="line"><span class="built_in">av_read_frame</span>(fmt_ctx_in_, &amp;pkt);</span><br></pre></td></tr></table></figure>



<p>通过avcodec_send_packet、avcodec_receive_frame来进行解码，avcodec_send_packet负责将一个AVPacket送给解码器，avcodec_receive_frame负责从解码器中取出一个已经解码好的AVFrame，如果返回AVERROR(EAGAIN)表明当前没有已经解码好的数据，返回AVERROR_EOF表明已经全部解码完成，返回大于0则表明获取解码数据成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 发送到解码器中进行解码</span></span><br><span class="line"> <span class="keyword">if</span> ((error = <span class="built_in">avcodec_send_packet</span>(codec_ctx_in_, &amp;pkt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125;  </span><br><span class="line"><span class="comment">// 从解码器中获取一帧解码后的数据，存到AVFrame中</span></span><br><span class="line"> error = <span class="built_in">avcodec_receive_frame</span>(codec_ctx_in_, frame);</span><br><span class="line"> <span class="keyword">if</span> (error == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">   <span class="comment">// 没有获取到数据</span></span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == AVERROR_EOF) &#123;</span><br><span class="line">   <span class="comment">// 解码器中数据已经全部解码完成</span></span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line">   *finished = <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 解码错误</span></span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 数据成功解码到AVFrame中</span></span><br><span class="line">   *data_present = <span class="number">1</span>;</span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p>创建一个AVFrame用来接收处理后的视频帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AVFrame* out = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="comment">// 设置输出参数给视频帧</span></span><br><span class="line">out-&gt;format = codec_ctx_out_-&gt;pix_fmt;</span><br><span class="line">out-&gt;width = codec_ctx_out_-&gt;width;</span><br><span class="line">out-&gt;height = codec_ctx_out_-&gt;height;</span><br><span class="line"><span class="comment">// 分配buffer</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">av_frame_get_buffer</span>(out, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not alloc av image&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图像处理，将解码后的AVFrame数据处理后，存储到上面创建的AVFrame中</span></span><br><span class="line"><span class="built_in">sws_scale</span>(sws_ctx_, (<span class="type">const</span> <span class="type">uint8_t</span>* <span class="type">const</span>*)frame-&gt;data, frame-&gt;linesize,</span><br><span class="line">          <span class="number">0</span>, frame-&gt;height, out-&gt;data, out-&gt;linesize);</span><br></pre></td></tr></table></figure>


<h3 id="编码数据并输出"><a href="#编码数据并输出" class="headerlink" title="编码数据并输出"></a>编码数据并输出</h3><p>通过avcodec_send_frame、avcodec_receive_packet来进行编码。avcodec_send_frame负责将一个AVFrame帧发送给编码器，avcodec_receive_packet负责从编码器中取出一帧已经编码好的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AVPacket pkt;</span><br><span class="line"><span class="comment">// 创建AVPacket，接收编码后的数据</span></span><br><span class="line"><span class="built_in">av_init_packet</span>(&amp;pkt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果待编码数据不为空，则累计计算当前帧的pts</span></span><br><span class="line"><span class="keyword">if</span> (frame) &#123;</span><br><span class="line">  frame-&gt;pts = pts;</span><br><span class="line">  pts += frame-&gt;nb_samples;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送AVFrame到编码器中进行编码</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_send_frame</span>(codec_ctx_out_, frame)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送失败</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收编码后的数据到AVPacket中</span></span><br><span class="line">error = <span class="built_in">avcodec_receive_packet</span>(codec_ctx_out_, &amp;pkt);</span><br><span class="line"><span class="keyword">if</span> (error == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">  <span class="comment">// 没有获取到编码后数据</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == AVERROR_EOF) &#123;</span><br><span class="line">  <span class="comment">// 编码器中所有数据编码完成</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 编码出错</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 成功获取编码后数据到AVPacket中</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  *data_written = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="写入到输出"><a href="#写入到输出" class="headerlink" title="写入到输出"></a>写入到输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果获取数据，则写入到输出上下文中</span></span><br><span class="line"><span class="keyword">if</span> (*data_written &amp;&amp; (error = <span class="built_in">av_write_frame</span>(fmt_ctx_out_, &amp;pkt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 写入失败</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg录制音频</title>
    <url>/2020/07/05/av/FFmpeg%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<h1 id="音频录制流程"><a href="#音频录制流程" class="headerlink" title="音频录制流程"></a>音频录制流程</h1><p>FFmpeg对各大平台的音频输入和输出的API进行了统一的封装，将输入API封装成AVInputFormat，将输出API封装成AVOutputFormat，并且将音频采集设备封装成一个音频文件进行处理，所以我们在采集音频数据的时候，可以将音频设备当做一个无限大的音频文件，不断的从音频文件中读取数据。</p>
<p><img src="/2020/07/05/av/FFmpeg%E5%BD%95%E5%88%B6%E9%9F%B3%E9%A2%91/ffmpeg_record_audio.png"></p>
<span id="more"></span>

<h2 id="打开音频输入"><a href="#打开音频输入" class="headerlink" title="打开音频输入"></a>打开音频输入</h2><h3 id="注册音频设备"><a href="#注册音频设备" class="headerlink" title="注册音频设备"></a>注册音频设备</h3><p>所有的输入和输出设备默认都是没有注册的，如果需要使用，需要手动调用下面的注册函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">avdevice_register_all();</span><br></pre></td></tr></table></figure>



<h3 id="创建输入上下文"><a href="#创建输入上下文" class="headerlink" title="创建输入上下文"></a>创建输入上下文</h3><p>FFmpeg将对音频文件的解封装和封装等操作都抽象到AVFormatContext中，所以音频文件的打开和输出都是要通道AVFormatContext来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置音频设备API Mac上为avfoundation</span></span><br><span class="line">AVInputFormat* format = <span class="built_in">av_find_input_format</span>(<span class="string">&quot;avfoundation&quot;</span>);</span><br><span class="line"><span class="comment">// :0 为音频第一个设备，开启音频设备，FFmpeg中将音频设备封装为一个音频文件</span></span><br><span class="line"><span class="comment">// video:audio 如果视频设备为空，则写成 :音频设备</span></span><br><span class="line"><span class="comment">// 获取到输入上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avformat_open_input</span>(&amp;fmt_ctx_in_, <span class="string">&quot;:0&quot;</span>, format, <span class="literal">nullptr</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open input device &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  fmt_ctx_in_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取设备输入数据格式"><a href="#获取设备输入数据格式" class="headerlink" title="获取设备输入数据格式"></a>获取设备输入数据格式</h3><p>FFmpeg将音频文件中的每一个轨道都封装成了AVStream对象，一个正常的音频文件一般都包含两个Stream，一个音频流和一个视频流。</p>
<p>对于这里，音频设备只有一个输入流，AVStream中包含了输入音频数据的采样率、采样位数、声道数等音频相关信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 音频设备只有一个输入流</span></span><br><span class="line">stream_in_ = fmt_ctx_in_-&gt;streams[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>



<h3 id="创建解码上下文"><a href="#创建解码上下文" class="headerlink" title="创建解码上下文"></a>创建解码上下文</h3><p>由于FFmpeg是将音频设备封装为音频文件来处理的，所以我们从输入流中读取的是AVPacket对象，其data数据是PCM原始音频数据，虽然不解码也可以直接将AVPacket中数据copy到AVFrame中，但最好通过解码转换为AVFrame。</p>
<p>FFmpeg将对音频文件的编码和解码等操作都抽象到AVCodecContext中，所以音频文件的编码和解码都是要通过AVCodecContext来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取音频输入流的编码格式，进行解码</span></span><br><span class="line">codec = <span class="built_in">avcodec_find_decoder</span>(stream_in_-&gt;codecpar-&gt;codec_id);</span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not find input codec&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建解码上下文</span></span><br><span class="line">codec_ctx_in_ = <span class="built_in">avcodec_alloc_context3</span>(codec);</span><br><span class="line"><span class="keyword">if</span> (!codec_ctx_in_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate input codec context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将输入流中的解码参数设置给解码上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_parameters_to_context</span>(codec_ctx_in_,</span><br><span class="line">                                           stream_in_-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not copy parameters to input codec&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启解码器</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_open2</span>(codec_ctx_in_, codec, <span class="literal">nullptr</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open input codec &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="打开音频输出"><a href="#打开音频输出" class="headerlink" title="打开音频输出"></a>打开音频输出</h2><h3 id="创建输出上下文"><a href="#创建输出上下文" class="headerlink" title="创建输出上下文"></a>创建输出上下文</h3><p>下面是创建了一个aac文件的输出上下文</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;/Users/gaozhenyu/Desktop/audio.aac&quot;</span>;</span><br><span class="line">AVOutputFormat* oformat = <span class="built_in">av_guess_format</span>(<span class="literal">nullptr</span>, filename, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 创建输出上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avformat_alloc_output_context2</span>(&amp;fmt_ctx_out_, oformat, <span class="literal">nullptr</span>,</span><br><span class="line">                                            filename)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate output format context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开启输出IO</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avio_open</span>(&amp;(fmt_ctx_out_-&gt;pb), filename, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open output file&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建指定编码器上下文"><a href="#创建指定编码器上下文" class="headerlink" title="创建指定编码器上下文"></a>创建指定编码器上下文</h3><p>使用libfdk_aac编码器来进行编码，并设置音频编码的相关参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到libfdk_aac编码器</span></span><br><span class="line">codec = <span class="built_in">avcodec_find_encoder_by_name</span>(<span class="string">&quot;libfdk_aac&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!codec) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not find libfdk_aac encoder&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建输出编码上下文</span></span><br><span class="line">codec_ctx_out_ = <span class="built_in">avcodec_alloc_context3</span>(codec);</span><br><span class="line"><span class="keyword">if</span> (!stream_out_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate output codec context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AVERROR</span>(ENOMEM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置输出编码参数</span></span><br><span class="line">codec_ctx_out_-&gt;sample_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">codec_ctx_out_-&gt;sample_rate = <span class="number">48000</span>;</span><br><span class="line">codec_ctx_out_-&gt;channel_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">codec_ctx_out_-&gt;channels = <span class="number">2</span>;</span><br><span class="line">codec_ctx_out_-&gt;bit_rate = <span class="number">128000</span>;</span><br><span class="line"><span class="comment">//  codec_ctx_out_-&gt;profile = FF_PROFILE_AAC_LD;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启编码器</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_open2</span>(codec_ctx_out_, codec, <span class="literal">nullptr</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open output codec &quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error)</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建输出流"><a href="#创建输出流" class="headerlink" title="创建输出流"></a>创建输出流</h3><p>上面说过，音频文件中每一个轨道都被封装成一个AVStream，那么想要向输出一个音频文件，除了上面创建了AVFormatContext外，还需要对每一个轨道创建一个AVStream，并添加到对应的输出AVFormatContext上。</p>
<p>这里我们需要输出的轨道只有一个音频轨道，所以创建一个流就可以。创建完流后还需要将上面设置的音频编码相关参数设置给流。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建指定编码器的输出音频流，添加到输出上下文中</span></span><br><span class="line">stream_out_ = <span class="built_in">avformat_new_stream</span>(fmt_ctx_out_, codec);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将编码上下文中的参数设置给输出流</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_parameters_from_context</span>(stream_out_-&gt;codecpar,</span><br><span class="line">                                             codec_ctx_out_)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not initialize output stream parameters &quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">av_err2str</span>(error) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="初始化重采样、FIFO队列"><a href="#初始化重采样、FIFO队列" class="headerlink" title="初始化重采样、FIFO队列"></a>初始化重采样、FIFO队列</h2><h3 id="重采样上下文"><a href="#重采样上下文" class="headerlink" title="重采样上下文"></a>重采样上下文</h3><p>FFmpeg将对音频的重采样操作抽象到SwrContext中，根据输入的音频数据格式和重采样后的音频数据格式来创建一个SwrContext。</p>
<p>实际上决定音频数据格式的就是三要素：采样率、声道数、采样位数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建重采样上下文，设置重采样输入输出参数</span></span><br><span class="line">swr_ctx_ = <span class="built_in">swr_alloc_set_opts</span>(</span><br><span class="line">    <span class="literal">nullptr</span>, <span class="built_in">av_get_default_channel_layout</span>(codec_ctx_out_-&gt;channels),</span><br><span class="line">    codec_ctx_out_-&gt;sample_fmt, codec_ctx_out_-&gt;sample_rate,</span><br><span class="line">    <span class="built_in">av_get_default_channel_layout</span>(codec_ctx_in_-&gt;channels),</span><br><span class="line">    codec_ctx_in_-&gt;sample_fmt, codec_ctx_in_-&gt;sample_rate, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (!swr_ctx_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate swr context&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化重采样上下文</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">swr_init</span>(swr_ctx_)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not open swr context&quot;</span> &lt;&lt; <span class="built_in">av_err2str</span>(error) &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">swr_free</span>(&amp;swr_ctx_);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="FIFO队列"><a href="#FIFO队列" class="headerlink" title="FIFO队列"></a>FIFO队列</h3><p>音频数据和视频数据在对一帧数据的定义上不太一样，对于视频来说一帧就是一张图像，每次从设备上采集来的都是一帧数据，而对于音频来说，都是散列的采样点，多少个采样点作为一帧需要看具体使用的编码器的要求。所以从设备上采集来的数据数量并不一定满足编码器需要的采样数量。</p>
<p>所以FFmpeg提供了AVAudioFifo队列来完成对数据的缓存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建音频FIFO队列，用来作为缓冲区，音频编码器需要一定的帧数才可以进行编码</span></span><br><span class="line"><span class="comment">// 所以将读取的音频帧存放在FIFO队列中，当大于音频编码器需要的帧数时，才进行编码</span></span><br><span class="line">fifo_ = <span class="built_in">av_audio_fifo_alloc</span>(codec_ctx_out_-&gt;sample_fmt,</span><br><span class="line">                            codec_ctx_out_-&gt;channels, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!fifo_) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Could not allocate FIFO&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> AVERROR_EXIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h2><p>对于AVFormatContext来进行音频数据的输出，需要调用三个write函数，avformat_write_header、av_write_frame、av_write_trailer。</p>
<p>整体流程就是不断的从音频设备中读取数据，解码后进行重采样，将重采样结果放入到FIFO队列中，当FIFO中数据足够时，则从FIFO中取出数据进行编码，编码后写入到输出文件中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="built_in">avformat_write_header</span>(fmt_ctx_out_, <span class="literal">nullptr</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Could not write output file header&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (request_abort_) &#123;</span><br><span class="line">   <span class="type">int</span> finished = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 一个音频帧中每个通道的样本数。</span></span><br><span class="line">   <span class="comment">// 编码：由libavcodec在avcodec_open2（）中设置。</span></span><br><span class="line">   <span class="comment">//      除最后一个帧外，每个提交的帧必须在每个通道中完全包含frame_size样本。</span></span><br><span class="line">   <span class="comment">// 解码：可能由某些解码器设置以指示恒定的帧大小</span></span><br><span class="line">   <span class="type">const</span> <span class="type">int</span> frame_size_out = codec_ctx_out_-&gt;frame_size;</span><br><span class="line">   <span class="comment">// 如果FIFO队列中音频样本数不足编码器需要的样本数，则循环读取数据，直到FIFO中数据满足需要的样本量</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">av_audio_fifo_size</span>(fifo_) &lt; frame_size_out) &#123;</span><br><span class="line">     <span class="comment">// 读取音频样本加入到FIFO队列中</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">ReadAndStore</span>(&amp;finished) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 数据读取失败，则直接退出</span></span><br><span class="line">       <span class="keyword">goto</span> cleanup;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 如果输入数据读取完了，则最后一帧的样本数可以小于指定的样本数</span></span><br><span class="line">     <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">       <span class="comment">// 跳出</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果FIFO队列中音频样本数大于编码器需要的 或者</span></span><br><span class="line">   <span class="comment">// 输入数据读取完但是FIFO中还有未处理的数据</span></span><br><span class="line">   <span class="comment">// 则循环不断处理，直到FIFO中数据不足一帧 或者 数据全部处理完成 才退出</span></span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">av_audio_fifo_size</span>(fifo_) &gt;= frame_size_out ||</span><br><span class="line">          (finished &amp;&amp; <span class="built_in">av_audio_fifo_size</span>(fifo_) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">     <span class="comment">// 从FIFO中取出数据进行编码并写入到输出文件中</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">EncodeAndWrite</span>() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 编码或写入失败，则直接退出</span></span><br><span class="line">       <span class="keyword">goto</span> cleanup;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输入数据读取完，但是编码器中可能还有最后几帧数据还在编码，所以需要重新从编码器中读取</span></span><br><span class="line">   <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">     <span class="type">int</span> data_written;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">       data_written = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 传入空的数据，进行编码，如果编码器中有数据，则继续</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">EncodeAudioFrame</span>(<span class="literal">nullptr</span>, &amp;data_written) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">goto</span> cleanup;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">while</span> (data_written);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">av_write_trailer</span>(fmt_ctx_out_) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Could not write output file trailer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="读取数据并解码"><a href="#读取数据并解码" class="headerlink" title="读取数据并解码"></a>读取数据并解码</h3><p>读取数据非常简单，创建一个AVPacket对象，通过av_read_frame就可以读取一帧数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建AVPacket，用来从音频设备中接收一帧数据</span></span><br><span class="line"><span class="built_in">av_init_packet</span>(&amp;pkt);</span><br><span class="line"><span class="comment">// 从音频设备中读取一帧数据到AVPacket中</span></span><br><span class="line"><span class="built_in">av_read_frame</span>(fmt_ctx_in_, &amp;pkt);</span><br></pre></td></tr></table></figure>



<p>通过avcodec_send_packet、avcodec_receive_frame来进行解码，avcodec_send_packet负责将一个AVPacket送给解码器，avcodec_receive_frame负责从解码器中取出一个已经解码好的AVFrame，如果返回AVERROR(EAGAIN)表明当前没有已经解码好的数据，返回AVERROR_EOF表明已经全部解码完成，返回大于0则表明获取解码数据成功。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 发送到解码器中进行解码</span></span><br><span class="line"> <span class="keyword">if</span> ((error = <span class="built_in">avcodec_send_packet</span>(codec_ctx_in_, &amp;pkt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125;  </span><br><span class="line"><span class="comment">// 从解码器中获取一帧解码后的数据，存到AVFrame中</span></span><br><span class="line"> error = <span class="built_in">avcodec_receive_frame</span>(codec_ctx_in_, frame);</span><br><span class="line"> <span class="keyword">if</span> (error == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">   <span class="comment">// 没有获取到数据</span></span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == AVERROR_EOF) &#123;</span><br><span class="line">   <span class="comment">// 解码器中数据已经全部解码完成</span></span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line">   *finished = <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 解码错误</span></span><br><span class="line">   <span class="keyword">goto</span> cleanup;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 数据成功解码到AVFrame中</span></span><br><span class="line">   *data_present = <span class="number">1</span>;</span><br><span class="line">   error = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>创建缓冲区，用来存放重采样后的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">av_samples_alloc_array_and_samples</span>(</span><br><span class="line">         data, <span class="literal">nullptr</span>, codec_ctx_out_-&gt;channels, nb_samples,</span><br><span class="line">         codec_ctx_out_-&gt;sample_fmt, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">av_freep</span>(*data[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">free</span>(*data);</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将AVFrame中的数据重采样到上面创建的缓冲区中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">swr_convert</span>(swr_ctx_, dst, nb_samples, src, nb_samples)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><p>将重采样后的数据放入到缓冲队列中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新分配FIFO队列的大小，新的大小=已有的大小加上当前音频帧的样本量</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">av_audio_fifo_realloc</span>(</span><br><span class="line">         fifo_, <span class="built_in">av_audio_fifo_size</span>(fifo_) + input_frame-&gt;nb_samples)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将重采样数据写入到FIFO中，如果写入的样本量小于当前帧的样本量，则表明写入有错误</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">av_audio_fifo_write</span>(fifo_, (<span class="type">void</span>**)converted_input_samples,</span><br><span class="line">                        input_frame-&gt;nb_samples) &lt;</span><br><span class="line">    input_frame-&gt;nb_samples) &#123;</span><br><span class="line">  error = AVERROR_EXIT;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>当队列中采样数据量满足编码器需要的大小后，从队列中取出需要的采样数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="comment">// 用来接收FIFO中数据</span></span><br><span class="line"><span class="comment">// 将AVFrame的样本量，设置为当前会读取的样本量</span></span><br><span class="line">frame-&gt;nb_samples = frame_size;</span><br><span class="line"><span class="comment">// 设置AVFrame的参数</span></span><br><span class="line">frame-&gt;channel_layout = codec_ctx_out_-&gt;channel_layout;</span><br><span class="line">frame-&gt;format = codec_ctx_out_-&gt;sample_fmt;</span><br><span class="line">frame-&gt;sample_rate = codec_ctx_out_-&gt;sample_rate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化AVFrame中的数据缓冲区</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">av_frame_get_buffer</span>(frame, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">av_frame_free</span>(&amp;frame);</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从FIFO中读取数据到AVFrame的缓冲区中，如果读取的样本数小于预定的样本数，则说明读取出错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">av_audio_fifo_read</span>(fifo_, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>**&gt;(frame-&gt;data),</span><br><span class="line">                       frame_size) &lt; frame_size) &#123;</span><br><span class="line">  error = AVERROR_EXIT;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编码数据并输出"><a href="#编码数据并输出" class="headerlink" title="编码数据并输出"></a>编码数据并输出</h3><p>通过avcodec_send_frame、avcodec_receive_packet来进行编码。avcodec_send_frame负责将一个AVFrame帧发送给编码器，avcodec_receive_packet负责从编码器中取出一帧已经编码好的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AVPacket pkt;</span><br><span class="line"><span class="comment">// 创建AVPacket，接收编码后的数据</span></span><br><span class="line"><span class="built_in">av_init_packet</span>(&amp;pkt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果待编码数据不为空，则累计计算当前帧的pts</span></span><br><span class="line"><span class="keyword">if</span> (frame) &#123;</span><br><span class="line">  frame-&gt;pts = pts;</span><br><span class="line">  <span class="comment">// 这里用样本量的个数来计算pts</span></span><br><span class="line">  <span class="comment">// 假设第一帧的样本量为1024，则第一帧的pts=1024，第二帧的样本量也是1024，则第二帧的pts=2048</span></span><br><span class="line">  pts += frame-&gt;nb_samples;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送AVFrame到编码器中进行编码</span></span><br><span class="line"><span class="keyword">if</span> ((error = <span class="built_in">avcodec_send_frame</span>(codec_ctx_out_, frame)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送失败</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收编码后的数据到AVPacket中</span></span><br><span class="line">error = <span class="built_in">avcodec_receive_packet</span>(codec_ctx_out_, &amp;pkt);</span><br><span class="line"><span class="keyword">if</span> (error == <span class="built_in">AVERROR</span>(EAGAIN)) &#123;</span><br><span class="line">  <span class="comment">// 没有获取到编码后数据</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == AVERROR_EOF) &#123;</span><br><span class="line">  <span class="comment">// 编码器中所有数据编码完成</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (error &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 编码出错</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 成功获取编码后数据到AVPacket中</span></span><br><span class="line">  error = <span class="number">0</span>;</span><br><span class="line">  *data_written = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="写入到输出"><a href="#写入到输出" class="headerlink" title="写入到输出"></a>写入到输出</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果获取数据，则写入到输出上下文中</span></span><br><span class="line"><span class="keyword">if</span> (*data_written &amp;&amp; (error = <span class="built_in">av_write_frame</span>(fmt_ctx_out_, &amp;pkt)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 写入失败</span></span><br><span class="line">  <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffplay渲染线程分析</title>
    <url>/2020/08/05/av/ffplay%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="视频渲染线程"><a href="#视频渲染线程" class="headerlink" title="视频渲染线程"></a>视频渲染线程</h1><p>视频渲染线程实际就是main线程。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="初始化SDL"><a href="#初始化SDL" class="headerlink" title="初始化SDL"></a>初始化SDL</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDL初始化</span></span><br><span class="line">flags = SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER;</span><br><span class="line"><span class="keyword">if</span> (SDL_Init(flags)) &#123;</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Could not initialize SDL - %s\n&quot;</span>,</span><br><span class="line">         SDL_GetError());</span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;(Did you set the DISPLAY variable?)\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="创建Window和Renderer"><a href="#创建Window和Renderer" class="headerlink" title="创建Window和Renderer"></a>创建Window和Renderer</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (borderless)</span><br><span class="line">  flags |= SDL_WINDOW_BORDERLESS;  <span class="comment">// 去掉窗口状态栏</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  flags |= SDL_WINDOW_RESIZABLE;  <span class="comment">// 窗口是否可缩放</span></span><br><span class="line"><span class="comment">// 创建SDL窗口</span></span><br><span class="line">window = SDL_CreateWindow(program_name, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                          SDL_WINDOWPOS_UNDEFINED, default_width,</span><br><span class="line">                          default_height, flags);</span><br><span class="line">SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, <span class="string">&quot;linear&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (window) &#123;</span><br><span class="line">  <span class="comment">// 创建SDL渲染器，SDL_RENDERER_ACCELERATED 使用硬件加速</span></span><br><span class="line">  renderer = SDL_CreateRenderer(</span><br><span class="line">      window, <span class="number">-1</span>, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);</span><br><span class="line">  <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING,</span><br><span class="line">           <span class="string">&quot;Failed to initialize a hardware accelerated renderer: %s\n&quot;</span>,</span><br><span class="line">           SDL_GetError());</span><br><span class="line">    <span class="comment">// 如果创建SDL渲染器失败，则去掉标记再重试，可能是当前设备不支持该标记</span></span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">    <span class="comment">// 输出渲染器信息</span></span><br><span class="line">    <span class="keyword">if</span> (!SDL_GetRendererInfo(renderer, &amp;renderer_info))</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_VERBOSE, <span class="string">&quot;Initialized %s renderer.\n&quot;</span>,</span><br><span class="line">             renderer_info.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!window || !renderer || !renderer_info.num_texture_formats) &#123;</span><br><span class="line">  <span class="comment">// 如果窗口或者渲染器创建失败，或者渲染器中可用的纹理格式为0，则退出</span></span><br><span class="line">  av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;Failed to create window or renderer: %s&quot;</span>,</span><br><span class="line">         SDL_GetError());</span><br><span class="line">  do_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>主线程在开启解复用线程后，就会开始轮询处理SDL事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_loop</span><span class="params">(VideoState *cur_stream)</span> &#123;</span><br><span class="line">  SDL_Event event;</span><br><span class="line">  <span class="type">double</span> incr, pos, frac;</span><br><span class="line">  <span class="comment">// 开始轮询SDL消息</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">    <span class="comment">// 获取事件，如果有，则执行下面的switch，如果没有，则会尝试刷新视频渲染</span></span><br><span class="line">    refresh_loop_wait_event(cur_stream, &amp;event);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在refresh_loop_wait_event中，会尝试获取SDL事件，如果获取成功，则返回，如果获取失败，则会执行while中的视频刷新操作。SDL事件会优先处理，在没有SDL事件的时候，就会轮询刷新视频</p>
<p>remaining_time的时间默认是0.01，当video_refresh刷新时，如果继续显示当前帧，则remaining_time的值等于当前帧结束的时间差，如果是显示下一帧，则不改变remaining_time的值，依旧是0.01。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">refresh_loop_wait_event</span><span class="params">(VideoState *is, SDL_Event *event)</span> &#123;</span><br><span class="line">  <span class="type">double</span> remaining_time = <span class="number">0.0</span>;</span><br><span class="line">  SDL_PumpEvents();</span><br><span class="line">  <span class="comment">// 如果获取到事件，则会直接返回，不会进入while</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">      !SDL_PeepEvents(event, <span class="number">1</span>, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) &#123;</span><br><span class="line">    <span class="comment">// 如果没有获取到事件，则会尝试更新视频渲染</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cursor_hidden &amp;&amp;</span><br><span class="line">        av_gettime_relative() - cursor_last_shown &gt; CURSOR_HIDE_DELAY) &#123;</span><br><span class="line">      SDL_ShowCursor(<span class="number">0</span>);</span><br><span class="line">      cursor_hidden = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二次之后刷新时，就会先睡个一定时间，这个时间由音视频同步机制计算得出</span></span><br><span class="line">    <span class="keyword">if</span> (remaining_time &gt; <span class="number">0.0</span>) av_usleep((<span class="type">int64_t</span>)(remaining_time * <span class="number">1000000.0</span>));</span><br><span class="line">    <span class="comment">// 默认刷新间隔是0.01s</span></span><br><span class="line">    remaining_time = REFRESH_RATE;</span><br><span class="line">    <span class="comment">// 如果当前是显示视频模式，并且 当前没有暂停或者当前强制刷新</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))</span><br><span class="line">      video_refresh(is, &amp;remaining_time); <span class="comment">// 刷新视频</span></span><br><span class="line">    SDL_PumpEvents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h3 id="刷新视频"><a href="#刷新视频" class="headerlink" title="刷新视频"></a>刷新视频</h3><p>主要逻辑是计算当前显示的帧是否显示结束，如果显示结束，那么下一帧是否应该显示，根据音视频同步机制，进行丢帧或者对当前帧的结束时间进行缩短和增长。</p>
<p>音视频同步机制就是通过两个时钟的差值，来调整当前显示帧的结束时间，也就是frame_timer的值，进而调整remaining_time的值，也就是线程等待的时间。当视频时钟慢，则减小当前帧显示的时间，当视频时钟快，则加大当前帧显示的时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_refresh</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">double</span> *remaining_time)</span> &#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">double</span> time;</span><br><span class="line"></span><br><span class="line">  Frame *sp, *sp2;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">  retry:</span><br><span class="line">    <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前Frame队列中没有数据，则什么也不干</span></span><br><span class="line">      <span class="comment">// nothing to do, no picture to display in the queue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">double</span> last_duration, duration, delay;</span><br><span class="line">      Frame *vp, *lastvp;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* dequeue the picture */</span></span><br><span class="line">      <span class="comment">// 获取当前已经在显示的帧，可以认为是上一帧</span></span><br><span class="line">      lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 获取当前帧</span></span><br><span class="line">      vp = frame_queue_peek(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 如果当前帧的序号不符合，则丢弃</span></span><br><span class="line">      <span class="keyword">if</span> (vp-&gt;serial != is-&gt;videoq.serial) &#123;</span><br><span class="line">        <span class="comment">// 读取移动到下一位，并重试</span></span><br><span class="line">        frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果上一帧与当前帧的序号不符合，重新更新播放时间frame_timer为当前系统时间</span></span><br><span class="line">      <span class="keyword">if</span> (lastvp-&gt;serial != vp-&gt;serial)</span><br><span class="line">        is-&gt;frame_timer = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">      <span class="comment">// 如果暂停了，则继续显示当前显示的帧</span></span><br><span class="line">      <span class="keyword">if</span> (is-&gt;paused) <span class="keyword">goto</span> display;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* compute nominal last_duration */</span></span><br><span class="line">      <span class="comment">// 获取上一帧要显示的时长</span></span><br><span class="line">      last_duration = vp_duration(is, lastvp, vp);</span><br><span class="line">      <span class="comment">// 计算音视频同步的延迟时差</span></span><br><span class="line">      delay = compute_target_delay(last_duration, is);</span><br><span class="line"></span><br><span class="line">      time = av_gettime_relative() / <span class="number">1000000.0</span>;</span><br><span class="line">      <span class="comment">// frame_timer 当前显示的帧要结束的时间</span></span><br><span class="line">      <span class="comment">// frame_timer + delay = 当前显示的帧真正要结束的时间</span></span><br><span class="line">      <span class="comment">// 如果上一帧还没有结束，则继续显示上一帧</span></span><br><span class="line">      <span class="keyword">if</span> (time &lt; is-&gt;frame_timer + delay) &#123;</span><br><span class="line">        <span class="comment">// frame_timer + delay - time 就是当前显示的帧结束的时间与当前时间的差值，也就是线程要wait的时间</span></span><br><span class="line">        *remaining_time =</span><br><span class="line">            FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);</span><br><span class="line">        <span class="keyword">goto</span> display;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果上一帧帧的显示时间已经过去了</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新frame_timer，指向的是当前显示的帧结束的时间</span></span><br><span class="line">      is-&gt;frame_timer += delay;</span><br><span class="line">      <span class="keyword">if</span> (delay &gt; <span class="number">0</span> &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)</span><br><span class="line">        is-&gt;frame_timer = time; <span class="comment">// 与系统时间偏离太大，则更新为系统时间</span></span><br><span class="line"></span><br><span class="line">      SDL_LockMutex(is-&gt;pictq.mutex);</span><br><span class="line">      <span class="keyword">if</span> (!isnan(vp-&gt;pts)) update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);</span><br><span class="line">      SDL_UnlockMutex(is-&gt;pictq.mutex);</span><br><span class="line">      <span class="comment">// 如果队列中还有剩余的帧</span></span><br><span class="line">      <span class="keyword">if</span> (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个帧</span></span><br><span class="line">        Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);</span><br><span class="line">        <span class="comment">// 计算当前帧的显示时长</span></span><br><span class="line">        duration = vp_duration(is, vp, nextvp);</span><br><span class="line">        <span class="comment">// time &gt; is-&gt;frame_timer + duration</span></span><br><span class="line">        <span class="comment">// 如果下一帧的时间还没有过去，则丢弃当前帧，队列读索引向后移动一位，重试</span></span><br><span class="line">        <span class="keyword">if</span> (!is-&gt;step &amp;&amp;</span><br><span class="line">            (framedrop &gt; <span class="number">0</span> ||</span><br><span class="line">             (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp;</span><br><span class="line">            time &gt; is-&gt;frame_timer + duration) &#123;</span><br><span class="line">          is-&gt;frame_drops_late++;</span><br><span class="line">          frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">          <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 队列向后移动一位</span></span><br><span class="line">      frame_queue_next(&amp;is-&gt;pictq);</span><br><span class="line">      <span class="comment">// 强制刷新</span></span><br><span class="line">      is-&gt;force_refresh = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (is-&gt;step &amp;&amp; !is-&gt;paused) stream_toggle_pause(is);</span><br><span class="line">    &#125;</span><br><span class="line">  display:</span><br><span class="line">    <span class="comment">/* display picture */</span></span><br><span class="line">    <span class="comment">// 显示当前帧</span></span><br><span class="line">    <span class="keyword">if</span> (!display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp;</span><br><span class="line">        is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)</span><br><span class="line">      video_display(is);</span><br><span class="line">  &#125;</span><br><span class="line">  is-&gt;force_refresh = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示视频"><a href="#显示视频" class="headerlink" title="显示视频"></a>显示视频</h3><p>更新纹理数据，刷新屏幕</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_display</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!is-&gt;width) video_open(is);</span><br><span class="line">  <span class="comment">// 设置颜色 黑色</span></span><br><span class="line">  SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="comment">// 使用黑色清空缓冲区</span></span><br><span class="line">  SDL_RenderClear(renderer);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (is-&gt;audio_st &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">    video_audio_display(is); <span class="comment">// 如果是音频播放模式，显示音频声波图</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (is-&gt;video_st)</span><br><span class="line">    video_image_display(is);<span class="comment">// 更新纹理数据</span></span><br><span class="line">  <span class="comment">// 将渲染的内容刷新到屏幕上</span></span><br><span class="line">  SDL_RenderPresent(renderer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新纹理数据"><a href="#更新纹理数据" class="headerlink" title="更新纹理数据"></a>更新纹理数据</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">video_image_display</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  Frame *vp;</span><br><span class="line">  Frame *sp = <span class="literal">NULL</span>;</span><br><span class="line">  SDL_Rect rect;</span><br><span class="line">  <span class="comment">// 从视频原始数据队列中取出一帧，这里没有调用frame_queue_peek</span></span><br><span class="line">  <span class="comment">// 是因为更新纹理有两种情况：一种是继续显示当前帧，这种使用frame_queue_peek_last正好，另一种是显示下一帧，在这种情况下，会提前调用frame_queue_next移动，所以这里直接调用frame_queue_peek_last，不管哪种情况都是合适的。</span></span><br><span class="line">  vp = frame_queue_peek_last(&amp;is-&gt;pictq);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算显示的矩阵</span></span><br><span class="line">  calculate_display_rect(&amp;rect, is-&gt;xleft, is-&gt;ytop, is-&gt;width, is-&gt;height,</span><br><span class="line">                         vp-&gt;width, vp-&gt;height, vp-&gt;sar);</span><br><span class="line">  <span class="comment">// 重复显示当前在显示的帧时，没必要重复上传数据到纹理中</span></span><br><span class="line">  <span class="keyword">if</span> (!vp-&gt;uploaded) &#123;</span><br><span class="line">    <span class="comment">// 如果视频帧还有没更新到纹理上</span></span><br><span class="line">    <span class="keyword">if</span> (upload_texture(&amp;is-&gt;vid_texture, vp-&gt;frame, &amp;is-&gt;img_convert_ctx) &lt; <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 标记已经更新</span></span><br><span class="line">    vp-&gt;uploaded = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    vp-&gt;flip_v = vp-&gt;frame-&gt;linesize[<span class="number">0</span>] &lt; <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置YUV转换RGB的转换公式</span></span><br><span class="line">  set_sdl_yuv_conversion_mode(vp-&gt;frame);</span><br><span class="line">  <span class="comment">// 将纹理上的内容拷贝到渲染器的默认渲染目标上</span></span><br><span class="line">  SDL_RenderCopyEx(renderer, is-&gt;vid_texture, <span class="literal">NULL</span>, &amp;rect, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">                   vp-&gt;flip_v ? SDL_FLIP_VERTICAL : <span class="number">0</span>);</span><br><span class="line">  set_sdl_yuv_conversion_mode(<span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="音频渲染线程"><a href="#音频渲染线程" class="headerlink" title="音频渲染线程"></a>音频渲染线程</h1><p>音频渲染线程是由SDL创建的，会在该线程中执行我们设置的回调函数。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在回调函数中主要处理两件事，一件就是从FrameQueue中取出len长度的数据放入到stream中，交给音频设备进行播放；另一件事就是更新音频时钟。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频渲染线程 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sdl_audio_callback</span><span class="params">(<span class="type">void</span> *opaque, Uint8 *stream, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  VideoState *is = opaque;</span><br><span class="line">  <span class="type">int</span> audio_size, len1;</span><br><span class="line"></span><br><span class="line">  audio_callback_time = av_gettime_relative();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果audio_buf中数据已经全部读完，则说明需要加入更多的数据</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">      <span class="comment">// 获取buffer到 is-&gt;audio_buf 中，返回获取的buffer大小</span></span><br><span class="line">      audio_size = audio_decode_frame(is);</span><br><span class="line">      <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* if error, just output silence */</span></span><br><span class="line">        is-&gt;audio_buf = <span class="literal">NULL</span>;</span><br><span class="line">        is-&gt;audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE /</span><br><span class="line">                             is-&gt;audio_tgt.frame_size *</span><br><span class="line">                             is-&gt;audio_tgt.frame_size;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;show_mode != SHOW_MODE_VIDEO)</span><br><span class="line">          update_sample_display(is, (<span class="type">int16_t</span> *)is-&gt;audio_buf, audio_size);</span><br><span class="line">        <span class="comment">// 读取的buffer大小  </span></span><br><span class="line">        is-&gt;audio_buf_size = audio_size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 已经读取的buffer位置重置</span></span><br><span class="line">      is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算还未读取的字节大小</span></span><br><span class="line">    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    <span class="comment">// 如果为读取的字节大小大于音频设备想要的大小，则使用音频设备想要的大小</span></span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len) len1 = len;</span><br><span class="line">    <span class="comment">// 将audio_buf中的数据copy到stream中</span></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf &amp;&amp; is-&gt;audio_volume == SDL_MIX_MAXVOLUME)</span><br><span class="line">      <span class="built_in">memcpy</span>(stream, (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(stream, <span class="number">0</span>, len1);</span><br><span class="line">      <span class="keyword">if</span> (!is-&gt;muted &amp;&amp; is-&gt;audio_buf)</span><br><span class="line">        SDL_MixAudioFormat(stream,</span><br><span class="line">                           (<span class="type">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index,</span><br><span class="line">                           AUDIO_S16SYS, len1, is-&gt;audio_volume);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减去已经传递给音频设备的buffer大小，如果剩下的还有，则再次读取传递</span></span><br><span class="line">    len -= len1;</span><br><span class="line">    <span class="comment">// stream加上偏移量</span></span><br><span class="line">    stream += len1;</span><br><span class="line">    <span class="comment">// 更新audio_buf的偏移量</span></span><br><span class="line">    is-&gt;audio_buf_index += len1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记录audio_buf中还剩余的大小</span></span><br><span class="line">  is-&gt;audio_write_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">  <span class="comment">/* Let&#x27;s assume the audio driver that is used by SDL has two periods. */</span></span><br><span class="line">  <span class="comment">// 更新音频时钟</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(is-&gt;audio_clock)) &#123;</span><br><span class="line">    <span class="comment">// 音频时钟中保存的是当前audio_buf开始的时间+时长，也就是结束的时间</span></span><br><span class="line">    <span class="comment">// 真正播放的准确时间应该要减去缓冲区中未使用的数据的时长，才是真正当前播放的时长</span></span><br><span class="line">    <span class="comment">// 缓冲区中未使用的字节大小 = 2 * is-&gt;audio_hw_buf_size 音频设备的缓冲区大小 + is-&gt;audio_write_buf_size audio_buf中还剩余的大小</span></span><br><span class="line">    <span class="comment">// 缓冲区中未使用的时长 = 缓冲区中未使用的字节大小 / （音频设备）1s数据的字节大小</span></span><br><span class="line">    <span class="comment">// 音频时钟准确时间 = 当前音频包结束时长 - 音频缓冲中剩余的数据时长</span></span><br><span class="line">    set_clock_at(&amp;is-&gt;audclk,</span><br><span class="line">                 is-&gt;audio_clock - (<span class="type">double</span>)(<span class="number">2</span> * is-&gt;audio_hw_buf_size +</span><br><span class="line">                                            is-&gt;audio_write_buf_size) /</span><br><span class="line">                                       is-&gt;audio_tgt.bytes_per_sec,</span><br><span class="line">                 is-&gt;audio_clock_serial, audio_callback_time / <span class="number">1000000.0</span>);</span><br><span class="line">    sync_clock_to_slave(&amp;is-&gt;extclk, &amp;is-&gt;audclk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重采样"><a href="#重采样" class="headerlink" title="重采样"></a>重采样</h3><p>如果音频数据参数与开启音频设备的参数不一致，那么是无法播放的，需要进行重采样</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_decode_frame</span><span class="params">(VideoState *is)</span> &#123;</span><br><span class="line">  <span class="type">int</span> data_size, resampled_data_size;</span><br><span class="line">  <span class="type">int64_t</span> dec_channel_layout;</span><br><span class="line">  av_unused <span class="type">double</span> audio_clock0;</span><br><span class="line">  <span class="type">int</span> wanted_nb_samples;</span><br><span class="line">  Frame *af;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;paused) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 循环从音频原始数据列表中获取一个可读帧，如果帧的序号与音频编码数据队列中的序号不一样，则丢帧</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 从音频原始数据列表中获取一个可读帧</span></span><br><span class="line">    <span class="keyword">if</span> (!(af = frame_queue_peek_readable(&amp;is-&gt;sampq))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 队列移动到下一个可读帧</span></span><br><span class="line">    frame_queue_next(&amp;is-&gt;sampq);</span><br><span class="line">  &#125; <span class="keyword">while</span> (af-&gt;serial != is-&gt;audioq.serial);</span><br><span class="line">  <span class="comment">// 根据音频参数计算一帧的字节大小  </span></span><br><span class="line">  data_size = av_samples_get_buffer_size(</span><br><span class="line">      <span class="literal">NULL</span>, af-&gt;frame-&gt;channels, af-&gt;frame-&gt;nb_samples, af-&gt;frame-&gt;format, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  dec_channel_layout =</span><br><span class="line">      (af-&gt;frame-&gt;channel_layout &amp;&amp;</span><br><span class="line">       af-&gt;frame-&gt;channels ==</span><br><span class="line">           av_get_channel_layout_nb_channels(af-&gt;frame-&gt;channel_layout))</span><br><span class="line">          ? af-&gt;frame-&gt;channel_layout</span><br><span class="line">          : av_get_default_channel_layout(af-&gt;frame-&gt;channels);</span><br><span class="line">  wanted_nb_samples = synchronize_audio(is, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">  <span class="comment">// 如果音频数据的参数发生了变化， audio_src 默认是音频设备开启时的参数</span></span><br><span class="line">  <span class="comment">// 只有当音频数据参数发生了变化才会重新创建重采样上下文</span></span><br><span class="line">  <span class="keyword">if</span> (af-&gt;frame-&gt;format != is-&gt;audio_src.fmt ||</span><br><span class="line">      dec_channel_layout != is-&gt;audio_src.channel_layout ||</span><br><span class="line">      af-&gt;frame-&gt;sample_rate != is-&gt;audio_src.freq ||</span><br><span class="line">      (wanted_nb_samples != af-&gt;frame-&gt;nb_samples &amp;&amp; !is-&gt;swr_ctx)) &#123;</span><br><span class="line">    swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">    <span class="comment">// 创建重采样上下文，将音频重采样成音频设备开启的参数</span></span><br><span class="line">    is-&gt;swr_ctx = swr_alloc_set_opts(<span class="literal">NULL</span>, is-&gt;audio_tgt.channel_layout,</span><br><span class="line">                                     is-&gt;audio_tgt.fmt, is-&gt;audio_tgt.freq,</span><br><span class="line">                                     dec_channel_layout, af-&gt;frame-&gt;format,</span><br><span class="line">                                     af-&gt;frame-&gt;sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录当前帧的参数作为音频源的参数，如果后面的帧的参数发生了变化，则会重新创建重采样上下文</span></span><br><span class="line">    is-&gt;audio_src.channel_layout = dec_channel_layout;</span><br><span class="line">    is-&gt;audio_src.channels = af-&gt;frame-&gt;channels;</span><br><span class="line">    is-&gt;audio_src.freq = af-&gt;frame-&gt;sample_rate;</span><br><span class="line">    is-&gt;audio_src.fmt = af-&gt;frame-&gt;format;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重采样</span></span><br><span class="line">  <span class="keyword">if</span> (is-&gt;swr_ctx) &#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span> **in = (<span class="type">const</span> <span class="type">uint8_t</span> **)af-&gt;frame-&gt;extended_data;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="type">uint8_t</span> **out = &amp;is-&gt;audio_buf1;</span><br><span class="line">    <span class="comment">// 计算重采样后AVFrame中具体有几帧数据</span></span><br><span class="line">    <span class="type">int</span> out_count = (<span class="type">int64_t</span>)wanted_nb_samples * is-&gt;audio_tgt.freq /</span><br><span class="line">                        af-&gt;frame-&gt;sample_rate +</span><br><span class="line">                    <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 计算重采样后的数据大小</span></span><br><span class="line">    <span class="type">int</span> out_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, is-&gt;audio_tgt.channels,</span><br><span class="line">                                              out_count, is-&gt;audio_tgt.fmt, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> len2;</span><br><span class="line">    <span class="keyword">if</span> (out_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size() failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果想要的帧数和AVFrame中的帧数不符合</span></span><br><span class="line">    <span class="keyword">if</span> (wanted_nb_samples != af-&gt;frame-&gt;nb_samples) &#123;</span><br><span class="line">      <span class="keyword">if</span> (swr_set_compensation(is-&gt;swr_ctx,</span><br><span class="line">                               (wanted_nb_samples - af-&gt;frame-&gt;nb_samples) *</span><br><span class="line">                                   is-&gt;audio_tgt.freq / af-&gt;frame-&gt;sample_rate,</span><br><span class="line">                               wanted_nb_samples * is-&gt;audio_tgt.freq /</span><br><span class="line">                                   af-&gt;frame-&gt;sample_rate) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_set_compensation() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配输出buffer的内存</span></span><br><span class="line">    av_fast_malloc(&amp;is-&gt;audio_buf1, &amp;is-&gt;audio_buf1_size, out_size);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;audio_buf1) <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">    <span class="comment">// 重采样</span></span><br><span class="line">    len2 = swr_convert(is-&gt;swr_ctx, out, out_count, in, af-&gt;frame-&gt;nb_samples);</span><br><span class="line">    <span class="keyword">if</span> (len2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;swr_convert() failed\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len2 == out_count) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;audio buffer is probably too small\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (swr_init(is-&gt;swr_ctx) &lt; <span class="number">0</span>) swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取buffer</span></span><br><span class="line">    is-&gt;audio_buf = is-&gt;audio_buf1;</span><br><span class="line">    <span class="comment">// 计算重采样后数据大小</span></span><br><span class="line">    resampled_data_size = len2 * is-&gt;audio_tgt.channels *</span><br><span class="line">                          av_get_bytes_per_sample(is-&gt;audio_tgt.fmt);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要重采样，则直接使用AVFrame中的data</span></span><br><span class="line">    <span class="comment">// 获取buffer</span></span><br><span class="line">    is-&gt;audio_buf = af-&gt;frame-&gt;data[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 获取buffer大小</span></span><br><span class="line">    resampled_data_size = data_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  audio_clock0 = is-&gt;audio_clock;</span><br><span class="line">  <span class="comment">/* update the audio clock with the pts */</span></span><br><span class="line">  <span class="comment">// 更新音频时钟，音频时钟 = 当前帧的PTS + （样本数量 / 每秒采样率） 也就是这些数据时长是多少秒</span></span><br><span class="line">  <span class="keyword">if</span> (!isnan(af-&gt;pts))</span><br><span class="line">    is-&gt;audio_clock =</span><br><span class="line">        af-&gt;pts + (<span class="type">double</span>)af-&gt;frame-&gt;nb_samples / af-&gt;frame-&gt;sample_rate;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    is-&gt;audio_clock = NAN;</span><br><span class="line">  <span class="comment">// 更新音频时钟序号</span></span><br><span class="line">  is-&gt;audio_clock_serial = af-&gt;serial;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resampled_data_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffplay解复用线程分析</title>
    <url>/2020/08/03/av/ffplay%E8%A7%A3%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>由主线程创建，负责媒体文件的解复用和读取，读取的数据根据流类型放入到对应的编码数据队列中</p>
<h1 id="查询流信息"><a href="#查询流信息" class="headerlink" title="查询流信息"></a>查询流信息</h1><h2 id="创建解复用上下文"><a href="#创建解复用上下文" class="headerlink" title="创建解复用上下文"></a>创建解复用上下文</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建解复用上下文</span></span><br><span class="line">ic = avformat_alloc_context();</span><br><span class="line"><span class="keyword">if</span> (!ic) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置中断回调</span></span><br><span class="line">ic-&gt;interrupt_callback.callback = decode_interrupt_cb;</span><br><span class="line"><span class="comment">// 回调函数的参数</span></span><br><span class="line">ic-&gt;interrupt_callback.opaque = is;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 打开输入</span></span><br><span class="line">err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;format_opts);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">is-&gt;ic = ic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (genpts) ic-&gt;flags |= AVFMT_FLAG_GENPTS;</span><br><span class="line"></span><br><span class="line">av_format_inject_global_side_data(ic);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (find_stream_info) &#123;</span><br><span class="line">  AVDictionary **opts = setup_find_stream_info_opts(ic, codec_opts);</span><br><span class="line">  <span class="type">int</span> orig_nb_streams = ic-&gt;nb_streams;</span><br><span class="line">  <span class="comment">// 读取文件头，获取文件的流详细信息</span></span><br><span class="line">  err = avformat_find_stream_info(ic, opts);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="查找流索引"><a href="#查找流索引" class="headerlink" title="查找流索引"></a>查找流索引</h2><p>查找音频和视频流的索引</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ic-&gt;nb_streams; i++) &#123;</span><br><span class="line">  AVStream *st = ic-&gt;streams[i];</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">AVMediaType</span> <span class="title">type</span> =</span> st-&gt;codecpar-&gt;codec_type;</span><br><span class="line">  st-&gt;discard = AVDISCARD_ALL;</span><br><span class="line">  <span class="keyword">if</span> (type &gt;= <span class="number">0</span> &amp;&amp; wanted_stream_spec[type] &amp;&amp; st_index[type] == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">if</span> (avformat_match_stream_specifier(ic, st, wanted_stream_spec[type]) &gt; <span class="number">0</span>)</span><br><span class="line">      st_index[type] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; AVMEDIA_TYPE_NB; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (wanted_stream_spec[i] &amp;&amp; st_index[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;Stream specifier %s does not match any %s stream\n&quot;</span>,</span><br><span class="line">           wanted_stream_spec[i], av_get_media_type_string(i));</span><br><span class="line">    st_index[i] = INT_MAX;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找流索引</span></span><br><span class="line"><span class="keyword">if</span> (!video_disable)</span><br><span class="line">  st_index[AVMEDIA_TYPE_VIDEO] = av_find_best_stream(</span><br><span class="line">      ic, AVMEDIA_TYPE_VIDEO, st_index[AVMEDIA_TYPE_VIDEO], <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!audio_disable)</span><br><span class="line">  st_index[AVMEDIA_TYPE_AUDIO] = av_find_best_stream(</span><br><span class="line">      ic, AVMEDIA_TYPE_AUDIO, st_index[AVMEDIA_TYPE_AUDIO],</span><br><span class="line">      st_index[AVMEDIA_TYPE_VIDEO], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!video_disable &amp;&amp; !subtitle_disable)</span><br><span class="line">  st_index[AVMEDIA_TYPE_SUBTITLE] = av_find_best_stream(</span><br><span class="line">      ic, AVMEDIA_TYPE_SUBTITLE, st_index[AVMEDIA_TYPE_SUBTITLE],</span><br><span class="line">      (st_index[AVMEDIA_TYPE_AUDIO] &gt;= <span class="number">0</span> ? st_index[AVMEDIA_TYPE_AUDIO]</span><br><span class="line">                                         : st_index[AVMEDIA_TYPE_VIDEO]),</span><br><span class="line">      <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h1 id="开启输入流"><a href="#开启输入流" class="headerlink" title="开启输入流"></a>开启输入流</h1><h2 id="创建解码上下文"><a href="#创建解码上下文" class="headerlink" title="创建解码上下文"></a>创建解码上下文</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建解码上下文</span></span><br><span class="line">avctx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!avctx) <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line"><span class="comment">// 设置解码上下文参数</span></span><br><span class="line">ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">goto</span> fail;</span><br><span class="line"><span class="comment">// 设置解码上下文时间基</span></span><br><span class="line">avctx-&gt;pkt_timebase = ic-&gt;streams[stream_index]-&gt;time_base;</span><br><span class="line"><span class="comment">// 查找解码器</span></span><br><span class="line">codec = avcodec_find_decoder(avctx-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">avctx-&gt;codec_id = codec-&gt;id;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启编码器上下文</span></span><br><span class="line"><span class="keyword">if</span> ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h2 id="开启音频设备"><a href="#开启音频设备" class="headerlink" title="开启音频设备"></a>开启音频设备</h2><p>使用SDL_OpenAudioDevice开启音频设备，如果失败，则不断更换音频参数组合来重试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">audio_open</span><span class="params">(<span class="type">void</span> *opaque, <span class="type">int64_t</span> wanted_channel_layout,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> wanted_nb_channels, <span class="type">int</span> wanted_sample_rate,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> AudioParams *audio_hw_params)</span> &#123;</span><br><span class="line">  SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *env;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_nb_channels[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> next_sample_rates[] = &#123;<span class="number">0</span>, <span class="number">44100</span>, <span class="number">48000</span>, <span class="number">96000</span>, <span class="number">192000</span>&#125;;</span><br><span class="line">  <span class="type">int</span> next_sample_rate_idx = FF_ARRAY_ELEMS(next_sample_rates) - <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 设置SDL音频播放参数</span></span><br><span class="line">  env = SDL_getenv(<span class="string">&quot;SDL_AUDIO_CHANNELS&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (env) &#123;</span><br><span class="line">    wanted_nb_channels = atoi(env);</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!wanted_channel_layout ||</span><br><span class="line">      wanted_nb_channels !=</span><br><span class="line">          av_get_channel_layout_nb_channels(wanted_channel_layout)) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line">    wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 采样率、声道数</span></span><br><span class="line">  wanted_nb_channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">  wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">  wanted_spec.freq = wanted_sample_rate;</span><br><span class="line">  <span class="keyword">if</span> (wanted_spec.freq &lt;= <span class="number">0</span> || wanted_spec.channels &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;Invalid sample rate or channel count!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (next_sample_rate_idx &amp;&amp;</span><br><span class="line">         next_sample_rates[next_sample_rate_idx] &gt;= wanted_spec.freq)</span><br><span class="line">    next_sample_rate_idx--;</span><br><span class="line">  <span class="comment">// 采样位数</span></span><br><span class="line">  wanted_spec.format = AUDIO_S16SYS;</span><br><span class="line">  <span class="comment">// 静音</span></span><br><span class="line">  wanted_spec.silence = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 样本数量</span></span><br><span class="line">  wanted_spec.samples =</span><br><span class="line">      FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE,</span><br><span class="line">            <span class="number">2</span> &lt;&lt; av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));</span><br><span class="line">  <span class="comment">// 回调函数</span></span><br><span class="line">  wanted_spec.callback = sdl_audio_callback;</span><br><span class="line">  <span class="comment">// 回调函数参数</span></span><br><span class="line">  wanted_spec.userdata = opaque;</span><br><span class="line">  <span class="comment">// 开启音频播放设备，如果开启失败，则更换参数不断重试</span></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">      !(audio_dev = SDL_OpenAudioDevice(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;wanted_spec, &amp;spec,</span><br><span class="line">                                        SDL_AUDIO_ALLOW_FREQUENCY_CHANGE |</span><br><span class="line">                                            SDL_AUDIO_ALLOW_CHANNELS_CHANGE))) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_WARNING, <span class="string">&quot;SDL_OpenAudio (%d channels, %d Hz): %s\n&quot;</span>,</span><br><span class="line">           wanted_spec.channels, wanted_spec.freq, SDL_GetError());</span><br><span class="line">    wanted_spec.channels = next_nb_channels[FFMIN(<span class="number">7</span>, wanted_spec.channels)];</span><br><span class="line">    <span class="keyword">if</span> (!wanted_spec.channels) &#123;</span><br><span class="line">      wanted_spec.freq = next_sample_rates[next_sample_rate_idx--];</span><br><span class="line">      wanted_spec.channels = wanted_nb_channels;</span><br><span class="line">      <span class="keyword">if</span> (!wanted_spec.freq) &#123;</span><br><span class="line">        <span class="comment">// 如果所有组合都重试完了还是打不开则直接退出</span></span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">&quot;No more combinations to try, audio open failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果开启音频设备的参数中采样位数不是16位，则退出，只支持16位</span></span><br><span class="line">  <span class="keyword">if</span> (spec.format != AUDIO_S16SYS) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">&quot;SDL advised audio format %d is not supported!\n&quot;</span>, spec.format);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (spec.channels != wanted_spec.channels) &#123;</span><br><span class="line">    wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">    <span class="keyword">if</span> (!wanted_channel_layout) &#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">             <span class="string">&quot;SDL advised channel count %d is not supported!\n&quot;</span>, spec.channels);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将真正开启音频设备的参数保存到 audio_hw_params 中</span></span><br><span class="line">  <span class="comment">// 只支持16位</span></span><br><span class="line">  audio_hw_params-&gt;fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">  <span class="comment">// 采样率</span></span><br><span class="line">  audio_hw_params-&gt;freq = spec.freq;</span><br><span class="line">  <span class="comment">// 声道布局</span></span><br><span class="line">  audio_hw_params-&gt;channel_layout = wanted_channel_layout;</span><br><span class="line">  <span class="comment">// 声道数</span></span><br><span class="line">  audio_hw_params-&gt;channels = spec.channels;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  audio_hw_params-&gt;frame_size = av_samples_get_buffer_size(</span><br><span class="line">      <span class="literal">NULL</span>, audio_hw_params-&gt;channels, <span class="number">1</span>, audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 1s数据的字节大小</span></span><br><span class="line">  audio_hw_params-&gt;bytes_per_sec = av_samples_get_buffer_size(</span><br><span class="line">      <span class="literal">NULL</span>, audio_hw_params-&gt;channels, audio_hw_params-&gt;freq,</span><br><span class="line">      audio_hw_params-&gt;fmt, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (audio_hw_params-&gt;bytes_per_sec &lt;= <span class="number">0</span> || audio_hw_params-&gt;frame_size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;av_samples_get_buffer_size failed\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回分配的缓冲区字节大小</span></span><br><span class="line">  <span class="keyword">return</span> spec.size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动解码线程"><a href="#启动解码线程" class="headerlink" title="启动解码线程"></a>启动解码线程</h2><p>初始化Decoder结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">decoder_init</span><span class="params">(Decoder *d, AVCodecContext *avctx, PacketQueue *<span class="built_in">queue</span>,</span></span><br><span class="line"><span class="params">                         SDL_cond *empty_queue_cond)</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(Decoder));</span><br><span class="line">  d-&gt;avctx = avctx;</span><br><span class="line">  d-&gt;<span class="built_in">queue</span> = <span class="built_in">queue</span>;</span><br><span class="line">  d-&gt;empty_queue_cond = empty_queue_cond;</span><br><span class="line">  d-&gt;start_pts = AV_NOPTS_VALUE;</span><br><span class="line">  d-&gt;pkt_serial = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动解码线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_start</span><span class="params">(Decoder *d, <span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">const</span> <span class="type">char</span> *thread_name,</span></span><br><span class="line"><span class="params">                         <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">  <span class="comment">// 启动编码数据队列</span></span><br><span class="line">  packet_queue_start(d-&gt;<span class="built_in">queue</span>);</span><br><span class="line">  <span class="comment">// 创建编码线程</span></span><br><span class="line">  d-&gt;decoder_tid = SDL_CreateThread(fn, thread_name, arg);</span><br><span class="line">  <span class="keyword">if</span> (!d-&gt;decoder_tid) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;SDL_CreateThread(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="轮询读取流数据"><a href="#轮询读取流数据" class="headerlink" title="轮询读取流数据"></a>轮询读取流数据</h1><p>流开启完毕后，就开始轮询从媒体文件中读取数据放入到Packet队列中，当Packet队列中数据足够的时候，会wait等待，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 轮询从文件中读取流数据</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 是否退出</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;abort_request) <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 如果本次暂停事件没有处理，则处理暂停事件</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused != is-&gt;last_paused) &#123;</span><br><span class="line">      <span class="comment">// 更新最新处理的暂停事件</span></span><br><span class="line">      is-&gt;last_paused = is-&gt;paused;</span><br><span class="line">      <span class="comment">// 如果是暂停，就停止读取，如果是播放，则开始读取</span></span><br><span class="line">      <span class="keyword">if</span> (is-&gt;paused)</span><br><span class="line">        is-&gt;read_pause_return = av_read_pause(ic);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        av_read_play(ic);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL</span></span><br><span class="line">    <span class="comment">// 如果是RTSP流，暂停就是等待10ms后再重试</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;paused &amp;&amp; (!<span class="built_in">strcmp</span>(ic-&gt;iformat-&gt;name, <span class="string">&quot;rtsp&quot;</span>) ||</span><br><span class="line">                       (ic-&gt;pb &amp;&amp; !<span class="built_in">strncmp</span>(input_filename, <span class="string">&quot;mmsh:&quot;</span>, <span class="number">5</span>)))) &#123;</span><br><span class="line">      <span class="comment">/* wait 10 ms to avoid trying to get another packet */</span></span><br><span class="line">      <span class="comment">/* <span class="doctag">XXX:</span> horrible */</span></span><br><span class="line">      SDL_Delay(<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// seek操作</span></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;seek_req) &#123;</span><br><span class="line">      <span class="comment">// seek的位置</span></span><br><span class="line">      <span class="type">int64_t</span> seek_target = is-&gt;seek_pos;</span><br><span class="line">      <span class="comment">// seek的区间,上下行</span></span><br><span class="line">      <span class="type">int64_t</span> seek_min =</span><br><span class="line">          is-&gt;seek_rel &gt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel + <span class="number">2</span> : INT64_MIN;</span><br><span class="line">      <span class="type">int64_t</span> seek_max =</span><br><span class="line">          is-&gt;seek_rel &lt; <span class="number">0</span> ? seek_target - is-&gt;seek_rel - <span class="number">2</span> : INT64_MAX;</span><br><span class="line">      <span class="comment">// FIXME the +-2 is due to rounding being not done in the correct</span></span><br><span class="line">      <span class="comment">// direction in generation</span></span><br><span class="line">      <span class="comment">//      of the seek_pos/seek_rel variables</span></span><br><span class="line">      <span class="comment">// seek</span></span><br><span class="line">      ret = avformat_seek_file(is-&gt;ic, <span class="number">-1</span>, seek_min, seek_target, seek_max,</span><br><span class="line">                               is-&gt;seek_flags);</span><br><span class="line">      <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">&quot;%s: error while seeking\n&quot;</span>, is-&gt;ic-&gt;url);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 重置音频编码数据队列</span></span><br><span class="line">          packet_queue_flush(&amp;is-&gt;audioq);</span><br><span class="line">          <span class="comment">// 队列中加入flush_pkt分割标记</span></span><br><span class="line">          packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 重置字幕编码数据队列</span></span><br><span class="line">          packet_queue_flush(&amp;is-&gt;subtitleq);</span><br><span class="line">          <span class="comment">// 队列中加入flush_pkt分割标记</span></span><br><span class="line">          packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// 重置视频编码数据队列</span></span><br><span class="line">          packet_queue_flush(&amp;is-&gt;videoq);</span><br><span class="line">          <span class="comment">// 队列中加入flush_pkt分割标记，让队列的序号+1</span></span><br><span class="line">          packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新外部时钟的PTS</span></span><br><span class="line">        <span class="keyword">if</span> (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) &#123;</span><br><span class="line">          set_clock(&amp;is-&gt;extclk, NAN, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          set_clock(&amp;is-&gt;extclk, seek_target / (<span class="type">double</span>)AV_TIME_BASE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;seek_req = <span class="number">0</span>;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">1</span>;</span><br><span class="line">      is-&gt;eof = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (is-&gt;paused) step_to_next_frame(is);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is-&gt;queue_attachments_req) &#123;</span><br><span class="line">      <span class="keyword">if</span> (is-&gt;video_st &amp;&amp;</span><br><span class="line">          is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC) &#123;</span><br><span class="line">        AVPacket copy = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span> ((ret = av_packet_ref(&amp;copy, &amp;is-&gt;video_st-&gt;attached_pic)) &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">goto</span> fail;</span><br><span class="line">        packet_queue_put(&amp;is-&gt;videoq, &amp;copy);</span><br><span class="line">        packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);</span><br><span class="line">      &#125;</span><br><span class="line">      is-&gt;queue_attachments_req = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if the queue are full, no need to read more */</span></span><br><span class="line">    <span class="comment">// 如果音频编码数据队列+视频编码数据队列+字幕编码数据队列中字节数量超过了15</span></span><br><span class="line">    <span class="comment">// * 1024 * 1024（15M） 或者说</span></span><br><span class="line">    <span class="comment">// 音频流、视频流、字幕流中都已经读取了充足的Packet在队列中缓存着，则wait</span></span><br><span class="line">    <span class="comment">// 10ms等待</span></span><br><span class="line">    <span class="comment">// 也就是说三个队列中缓冲数据超过15M或者三个队列中都已经有了一定的数据(1s的数据)，那么就不能继续读下去了，等待10ms后再来重试</span></span><br><span class="line">    <span class="keyword">if</span> (infinite_buffer &lt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">        (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt;</span><br><span class="line">             MAX_QUEUE_SIZE ||</span><br><span class="line">         (stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream,</span><br><span class="line">                                    &amp;is-&gt;audioq) &amp;&amp;</span><br><span class="line">          stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream,</span><br><span class="line">                                    &amp;is-&gt;videoq) &amp;&amp;</span><br><span class="line">          stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream,</span><br><span class="line">                                    &amp;is-&gt;subtitleq)))) &#123;</span><br><span class="line">      <span class="comment">/* wait 10 ms */</span></span><br><span class="line">      SDL_LockMutex(wait_mutex);</span><br><span class="line">      <span class="comment">// 等待10ms后，重新循环</span></span><br><span class="line">      SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class="number">10</span>);</span><br><span class="line">      SDL_UnlockMutex(wait_mutex);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理播放结束</span></span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;paused &amp;&amp;</span><br><span class="line">        (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp;</span><br><span class="line">                           frame_queue_nb_remaining(&amp;is-&gt;sampq) == <span class="number">0</span>)) &amp;&amp;</span><br><span class="line">        (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp;</span><br><span class="line">                           frame_queue_nb_remaining(&amp;is-&gt;pictq) == <span class="number">0</span>))) &#123;</span><br><span class="line">      <span class="comment">// loop = 0 表示无限循环， 否则表示循环次数，每次结束-1，直到等于1停止循环</span></span><br><span class="line">      <span class="keyword">if</span> (loop != <span class="number">1</span> &amp;&amp; (!loop || --loop)) &#123;</span><br><span class="line">        stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (autoexit) &#123;</span><br><span class="line">        ret = AVERROR_EOF;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取一个Packet</span></span><br><span class="line">    ret = av_read_frame(ic, pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 读取失败</span></span><br><span class="line">      <span class="keyword">if</span> ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) &#123;</span><br><span class="line">        <span class="comment">// 如果文件流已经结束，放入一个空的Packet到队列中</span></span><br><span class="line">        <span class="keyword">if</span> (is-&gt;video_stream &gt;= <span class="number">0</span>)</span><br><span class="line">          packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_stream &gt;= <span class="number">0</span>)</span><br><span class="line">          packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;subtitle_stream &gt;= <span class="number">0</span>)</span><br><span class="line">          packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);</span><br><span class="line">        <span class="comment">// EOF 流结束</span></span><br><span class="line">        is-&gt;eof = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error) <span class="keyword">break</span>;</span><br><span class="line">      SDL_LockMutex(wait_mutex);</span><br><span class="line">      <span class="comment">// 等待10ms</span></span><br><span class="line">      SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, <span class="number">10</span>);</span><br><span class="line">      SDL_UnlockMutex(wait_mutex);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      is-&gt;eof = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* check if packet is in play range specified by user, then queue, otherwise</span></span><br><span class="line"><span class="comment">     * discard */</span></span><br><span class="line">    <span class="comment">// 流的开始时间</span></span><br><span class="line">    stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;</span><br><span class="line">    <span class="comment">// 当前Packet的PTS</span></span><br><span class="line">    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;</span><br><span class="line">    <span class="comment">// 当前Packet的PTS - 流开始时间 &lt;= 播放时长duration</span></span><br><span class="line">    <span class="comment">// 则表明当前Packet是在播放范围内的</span></span><br><span class="line">    pkt_in_play_range =</span><br><span class="line">        duration == AV_NOPTS_VALUE ||</span><br><span class="line">        (pkt_ts -</span><br><span class="line">         (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : <span class="number">0</span>)) *</span><br><span class="line">                    av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -</span><br><span class="line">                (<span class="type">double</span>)(start_time != AV_NOPTS_VALUE ? start_time : <span class="number">0</span>) /</span><br><span class="line">                    <span class="number">1000000</span> &lt;=</span><br><span class="line">            ((<span class="type">double</span>)duration / <span class="number">1000000</span>);</span><br><span class="line">    <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      <span class="comment">// 音频Packet，放入到音频编码数据队列中</span></span><br><span class="line">      packet_queue_put(&amp;is-&gt;audioq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range &amp;&amp;</span><br><span class="line">               !(is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) &#123;</span><br><span class="line">      <span class="comment">// 音频Packet，放入到音频编码数据队列中</span></span><br><span class="line">      packet_queue_put(&amp;is-&gt;videoq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) &#123;</span><br><span class="line">      <span class="comment">// 音频Packet，放入到音频编码数据队列中</span></span><br><span class="line">      packet_queue_put(&amp;is-&gt;subtitleq, pkt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 类型都不符合，则释放不处理</span></span><br><span class="line">      av_packet_unref(pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffplay解码线程分析</title>
    <url>/2020/08/04/av/ffplay%E8%A7%A3%E7%A0%81%E7%BA%BF%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="视频解码线程"><a href="#视频解码线程" class="headerlink" title="视频解码线程"></a>视频解码线程</h1><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>不断从Packet队列中取出一帧数据进行解码，然后将解码数据放入到Frame队列中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// 获取一帧解码数据</span></span><br><span class="line">  ret = get_video_frame(is, frame);</span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">goto</span> the_end;</span><br><span class="line">  <span class="keyword">if</span> (!ret) <span class="keyword">continue</span>;</span><br><span class="line">  ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 根据帧率计算每帧的显示时长</span></span><br><span class="line">    duration = (frame_rate.num &amp;&amp; frame_rate.den</span><br><span class="line">                    ? av_q2d((AVRational)&#123;frame_rate.den, frame_rate.num&#125;)</span><br><span class="line">                    : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将帧的PTS转换为秒</span></span><br><span class="line">    pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">    <span class="comment">// 将解码后的帧数据放入到视频原始数据队列中</span></span><br><span class="line">    ret = queue_picture(is, frame, pts, duration, frame-&gt;pkt_pos,</span><br><span class="line">                        is-&gt;viddec.pkt_serial);</span><br><span class="line">    av_frame_unref(frame);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) <span class="keyword">goto</span> the_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="解码-1"><a href="#解码-1" class="headerlink" title="解码"></a>解码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decoder_decode_frame</span><span class="params">(Decoder *d, AVFrame *frame, AVSubtitle *sub)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret = AVERROR(EAGAIN);</span><br><span class="line">  <span class="comment">// 轮询解码，直到解码一帧成功</span></span><br><span class="line">  <span class="comment">// 1. 先尝试从解码器中获取，获取成功则直接返回</span></span><br><span class="line">  <span class="comment">// 2. 不成功，则从Packet队列中获取一帧数据，顺便丢弃一些过时数据</span></span><br><span class="line">  <span class="comment">// 3. 将获取的一帧数据送给解码器进行解码</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    <span class="comment">// 比较Packet队列的序号是否相同，是否是过时的数据</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial == d-&gt;pkt_serial) &#123;</span><br><span class="line">      <span class="comment">// 不断的尝试从解码器中获取已经解码完成的帧，直到获取成功</span></span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Packet队列是否退出</span></span><br><span class="line">        <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;abort_request) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 尝试从解码器中获取已经解码完成的帧</span></span><br><span class="line">        <span class="keyword">switch</span> (d-&gt;avctx-&gt;codec_type) &#123;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_VIDEO:</span><br><span class="line">            <span class="comment">// 从解码器中获取解码完成的视频帧</span></span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取成功，重置PTS</span></span><br><span class="line">              <span class="keyword">if</span> (decoder_reorder_pts == <span class="number">-1</span>) &#123;</span><br><span class="line">                frame-&gt;pts = frame-&gt;best_effort_timestamp;</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!decoder_reorder_pts) &#123;</span><br><span class="line">                frame-&gt;pts = frame-&gt;pkt_dts;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            <span class="comment">// 从解码器中获取解码完成的音频帧</span></span><br><span class="line">            ret = avcodec_receive_frame(d-&gt;avctx, frame);</span><br><span class="line">            <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">              AVRational tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">              <span class="comment">// 获取成功，重置PTS</span></span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts =</span><br><span class="line">                    av_rescale_q(frame-&gt;pts, d-&gt;avctx-&gt;pkt_timebase, tb);</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (d-&gt;next_pts != AV_NOPTS_VALUE)</span><br><span class="line">                frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);</span><br><span class="line">              <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">                d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;</span><br><span class="line">                d-&gt;next_pts_tb = tb;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == AVERROR_EOF) &#123;</span><br><span class="line">          <span class="comment">// 如果流解码结束，记录本次结束的Packet队列的序号</span></span><br><span class="line">          d-&gt;finished = d-&gt;pkt_serial;</span><br><span class="line">          <span class="comment">// 刷新解码上下文，以便再次解码，不刷新则不能再解码了</span></span><br><span class="line">          avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果获取成功，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">while</span> (ret != AVERROR(EAGAIN));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果Packet队列的序号不相同，则开始丢弃这些过时的数据</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 如果Packet队列中已经空了，则唤醒read线程继续读取数据</span></span><br><span class="line">      <span class="keyword">if</span> (d-&gt;<span class="built_in">queue</span>-&gt;nb_packets == <span class="number">0</span>) SDL_CondSignal(d-&gt;empty_queue_cond);</span><br><span class="line">      <span class="comment">// packet_pending用于失败重新发送</span></span><br><span class="line">      <span class="keyword">if</span> (d-&gt;packet_pending) &#123;</span><br><span class="line">        <span class="comment">// 重新复制pkt</span></span><br><span class="line">        av_packet_move_ref(&amp;pkt, &amp;d-&gt;pkt);</span><br><span class="line">        <span class="comment">//去掉重发标记</span></span><br><span class="line">        d-&gt;packet_pending = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从Packet队列中读取一个新的Packet，存在pkt中，并将获取的pkt的序号赋值给d-&gt;pkt_serial</span></span><br><span class="line">        <span class="keyword">if</span> (packet_queue_get(d-&gt;<span class="built_in">queue</span>, &amp;pkt, <span class="number">1</span>, &amp;d-&gt;pkt_serial) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (d-&gt;<span class="built_in">queue</span>-&gt;serial != d-&gt;pkt_serial);</span><br><span class="line">    <span class="comment">// 如果获取到的是flush_pkt分割标记</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.data == flush_pkt.data) &#123;</span><br><span class="line">      <span class="comment">// 清空解码器</span></span><br><span class="line">      avcodec_flush_buffers(d-&gt;avctx);</span><br><span class="line">      <span class="comment">// 重新开始</span></span><br><span class="line">      d-&gt;finished = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// pts重新计算</span></span><br><span class="line">      d-&gt;next_pts = d-&gt;start_pts;</span><br><span class="line">      d-&gt;next_pts_tb = d-&gt;start_pts_tb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 获取到正常数据</span></span><br><span class="line">      <span class="keyword">if</span> (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) &#123;</span><br><span class="line">        <span class="comment">// 字幕数据</span></span><br><span class="line">        <span class="type">int</span> got_frame = <span class="number">0</span>;</span><br><span class="line">        ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = AVERROR(EAGAIN);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (got_frame &amp;&amp; !pkt.data) &#123;</span><br><span class="line">            d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line">            av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);</span><br><span class="line">          &#125;</span><br><span class="line">          ret = got_frame ? <span class="number">0</span> : (pkt.data ? AVERROR(EAGAIN) : AVERROR_EOF);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 音频或视频数据，发送给解码器进行解码</span></span><br><span class="line">        <span class="keyword">if</span> (avcodec_send_packet(d-&gt;avctx, &amp;pkt) == AVERROR(EAGAIN)) &#123;</span><br><span class="line">          av_log(d-&gt;avctx, AV_LOG_ERROR,</span><br><span class="line">                 <span class="string">&quot;Receive_frame and send_packet both returned EAGAIN, which is &quot;</span></span><br><span class="line">                 <span class="string">&quot;an API violation.\n&quot;</span>);</span><br><span class="line">          <span class="comment">// 解码失败，标记重发</span></span><br><span class="line">          d-&gt;packet_pending = <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 将Packet还给pkt对象，用于下次重新发送</span></span><br><span class="line">          av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h4 id="丢帧"><a href="#丢帧" class="headerlink" title="丢帧"></a>丢帧</h4><p>解码完成后，对过时的帧进行丢弃</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_video_frame</span><span class="params">(VideoState *is, AVFrame *frame)</span> &#123;</span><br><span class="line">  <span class="type">int</span> got_picture;</span><br><span class="line">  <span class="comment">// 解码，将解码的结果放入到frame中</span></span><br><span class="line">  <span class="keyword">if</span> ((got_picture = decoder_decode_frame(&amp;is-&gt;viddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (got_picture) &#123;</span><br><span class="line">    <span class="comment">// 解码成功</span></span><br><span class="line">    <span class="type">double</span> dpts = NAN;</span><br><span class="line">    <span class="comment">// 将当前帧的PTS转换成秒</span></span><br><span class="line">    <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">      dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;</span><br><span class="line">    <span class="comment">// 采样横纵比</span></span><br><span class="line">    frame-&gt;sample_aspect_ratio =</span><br><span class="line">        av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);</span><br><span class="line">    <span class="comment">// 丢帧操作，如果同步模式不是视频为主，则判断是否要丢帧</span></span><br><span class="line">    <span class="keyword">if</span> (framedrop &gt; <span class="number">0</span> ||</span><br><span class="line">        (framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (frame-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">        <span class="comment">// 计算主时钟和当前帧要显示的时间差</span></span><br><span class="line">        <span class="type">double</span> diff = dpts - get_master_clock(is);</span><br><span class="line">        <span class="comment">// 大致意思当当前帧的时间小于主时钟的时间时，就需要进行丢帧操作</span></span><br><span class="line">        <span class="keyword">if</span> (!isnan(diff) &amp;&amp; <span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;</span><br><span class="line">            diff - is-&gt;frame_last_filter_delay &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;</span><br><span class="line">            is-&gt;videoq.nb_packets) &#123;</span><br><span class="line">          <span class="comment">// 丢帧次数+1</span></span><br><span class="line">          is-&gt;frame_drops_early++;</span><br><span class="line">          <span class="comment">// 是否frame</span></span><br><span class="line">          av_frame_unref(frame);</span><br><span class="line">          <span class="comment">// 标记未获取到解码数据</span></span><br><span class="line">          got_picture = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> got_picture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>frame_queue_peek_writable方法中，如果Frame队列已经满了，则会进行阻塞，否则返回一个可写的Frame对象，将数据写入到Frame对象中，调用frame_queue_push通知Frame队列写入完成，整个入队操作就完成了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">queue_picture</span><span class="params">(VideoState *is, AVFrame *src_frame, <span class="type">double</span> pts,</span></span><br><span class="line"><span class="params">                         <span class="type">double</span> duration, <span class="type">int64_t</span> pos, <span class="type">int</span> serial)</span> &#123;</span><br><span class="line">  Frame *vp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从视频原始数据队列中获取一个可以写入的帧，vp</span></span><br><span class="line">  <span class="keyword">if</span> (!(vp = frame_queue_peek_writable(&amp;is-&gt;pictq))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 采样横纵比</span></span><br><span class="line">  vp-&gt;sar = src_frame-&gt;sample_aspect_ratio;</span><br><span class="line">  vp-&gt;uploaded = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// w h 像素格式</span></span><br><span class="line">  vp-&gt;width = src_frame-&gt;width;</span><br><span class="line">  vp-&gt;height = src_frame-&gt;height;</span><br><span class="line">  vp-&gt;format = src_frame-&gt;format;</span><br><span class="line">  <span class="comment">// pts 时长 序号</span></span><br><span class="line">  vp-&gt;pts = pts;</span><br><span class="line">  vp-&gt;duration = duration;</span><br><span class="line">  vp-&gt;pos = pos;</span><br><span class="line">  vp-&gt;serial = serial;</span><br><span class="line">  <span class="comment">// 更改窗口的大小</span></span><br><span class="line">  set_default_window_size(vp-&gt;width, vp-&gt;height, vp-&gt;sar);</span><br><span class="line">  <span class="comment">// 将AVFrame数据复制到vp中</span></span><br><span class="line">  av_frame_move_ref(vp-&gt;frame, src_frame);</span><br><span class="line">  <span class="comment">// 通知视频原始数据队列，数据已经写入完成</span></span><br><span class="line">  frame_queue_push(&amp;is-&gt;pictq);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="音频解码线程"><a href="#音频解码线程" class="headerlink" title="音频解码线程"></a>音频解码线程</h1><p>解码和入队的逻辑和视频一样，调用decoder_decode_frame进行解码，解码成功则got_frame为1，再调用frame_queue_peek_writable和frame_queue_push进行入队。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 解码，将解码的结果放入到frame中</span></span><br><span class="line">  <span class="keyword">if</span> ((got_frame = decoder_decode_frame(&amp;is-&gt;auddec, frame, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">goto</span> the_end;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (got_frame) &#123;</span><br><span class="line">    <span class="comment">// 解码成功</span></span><br><span class="line">    <span class="comment">// 音频帧的采样率</span></span><br><span class="line">    tb = (AVRational)&#123;<span class="number">1</span>, frame-&gt;sample_rate&#125;;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从音频的原始数据队列中取出一个可写入的帧 af,</span></span><br><span class="line">      <span class="comment">// 如果返回null，则表明Packet队列已经退出，不会再有数据增加了，直接结束解码</span></span><br><span class="line">      <span class="keyword">if</span> (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq))) <span class="keyword">goto</span> the_end;</span><br><span class="line">      <span class="comment">// 设置帧的PTS</span></span><br><span class="line">      af-&gt;pts =</span><br><span class="line">          (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);</span><br><span class="line">      <span class="comment">// 设置帧在流中的位置</span></span><br><span class="line">      af-&gt;pos = frame-&gt;pkt_pos;</span><br><span class="line">      <span class="comment">// 设置帧的序号</span></span><br><span class="line">      af-&gt;serial = is-&gt;auddec.pkt_serial;</span><br><span class="line">      <span class="comment">// 设置帧的时长</span></span><br><span class="line">      af-&gt;duration =</span><br><span class="line">          av_q2d((AVRational)&#123;frame-&gt;nb_samples, frame-&gt;sample_rate&#125;);</span><br><span class="line">      <span class="comment">// 将帧数据赋值到af中</span></span><br><span class="line">      av_frame_move_ref(af-&gt;frame, frame);</span><br><span class="line">      <span class="comment">// 通知音频的原始数据队列，数据已经成功写入</span></span><br><span class="line">      frame_queue_push(&amp;is-&gt;sampq);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (ret &gt;= <span class="number">0</span> || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>ffplay队列分析</title>
    <url>/2020/08/02/av/ffplay%E9%98%9F%E5%88%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ffplay的整体结构是由5个线程和4个队列组成、运转的（不分析字幕）。</p>
<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p><img src="/2020/08/02/av/ffplay%E9%98%9F%E5%88%97%E5%88%86%E6%9E%90/ffplay.png" alt="音视频开发之ffplay队列分析"></p>
<span id="more"></span>

<h2 id="5个线程"><a href="#5个线程" class="headerlink" title="5个线程"></a>5个线程</h2><ul>
<li>解复用线程 : read_thread，由主线程创建，负责媒体文件的解复用和读取，读取的数据根据流类型放入到对应的编码数据队列中。</li>
<li>音频解码线程 : audio_thread，由read_thread创建，负责将编码数据队列中的数据解码，放入到原始数据队列中。</li>
<li>视频解码线程 : video_thread，由read_thread创建，负责将编码数据队列中的数据解码，放入到原始数据队列中。</li>
<li>音频渲染线程 : 由SDL创建，负责将音频原始数据队列中的数据发送给音频播放设备。</li>
<li>视频渲染线程 : main线程，负责用视频原始数据队列中的数据不断的更新纹理内容，并刷新显示器进行显示。</li>
</ul>
<h2 id="4个队列"><a href="#4个队列" class="headerlink" title="4个队列"></a>4个队列</h2><ul>
<li>FrameQueue pictq : 视频原始数据队列</li>
<li>FrameQueue sampq : 音频原始数据队列</li>
<li>PacketQueue audioq : 音频编码数据队列</li>
<li>PacketQueue videoq : 视频编码数据队列</li>
</ul>
<h3 id="PacketQueue"><a href="#PacketQueue" class="headerlink" title="PacketQueue"></a>PacketQueue</h3><p>Packet队列是基于链表实现的普通队列，由于编码数据帧比较小，所以这是个无限队列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">  <span class="comment">// Packet队列采用的是链表结构</span></span><br><span class="line">  MyAVPacketList *first_pkt, *last_pkt;  <span class="comment">// 第一个节点和最后一个节点</span></span><br><span class="line">  <span class="type">int</span> nb_packets;                        <span class="comment">// 队列中节点个数</span></span><br><span class="line">  <span class="type">int</span> size;                              <span class="comment">// 队列中所有节点的字节总数</span></span><br><span class="line">  <span class="type">int64_t</span> duration;                      <span class="comment">// 队列中所有节点的总时长</span></span><br><span class="line">  <span class="type">int</span> abort_request;  <span class="comment">// 是否退出标记 1 退出，0 不退出</span></span><br><span class="line">  <span class="type">int</span> serial;         <span class="comment">// 序号</span></span><br><span class="line">  SDL_mutex *mutex;   <span class="comment">// 锁</span></span><br><span class="line">  SDL_cond *cond;     <span class="comment">// 互斥量</span></span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure>


<h4 id="packet-queue-init"><a href="#packet-queue-init" class="headerlink" title="packet_queue_init"></a>packet_queue_init</h4><p>初始化队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_init</span><span class="params">(PacketQueue *q)</span> &#123;</span><br><span class="line">  <span class="comment">// 将编码数据队列初始化，清零</span></span><br><span class="line">  <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(PacketQueue));</span><br><span class="line">  <span class="comment">// 为队列创建锁</span></span><br><span class="line">  q-&gt;mutex = SDL_CreateMutex();</span><br><span class="line">  <span class="keyword">if</span> (!q-&gt;mutex) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateMutex(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为队列创建锁的互斥量</span></span><br><span class="line">  q-&gt;cond = SDL_CreateCond();</span><br><span class="line">  <span class="keyword">if</span> (!q-&gt;cond) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateCond(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列设置为退出状态</span></span><br><span class="line">  q-&gt;abort_request = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="packet-queue-start"><a href="#packet-queue-start" class="headerlink" title="packet_queue_start"></a>packet_queue_start</h4><p>启动队列，每次启动都会在队列中插入一个分割标记，并将队列序号+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_start</span><span class="params">(PacketQueue *q)</span> &#123;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="comment">// 设置启动标记</span></span><br><span class="line">  q-&gt;abort_request = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 队列中放入一个特殊的flush_pkt，用来做不连续的两段数据的分割标记</span></span><br><span class="line">  packet_queue_put_private(q, &amp;flush_pkt);</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="packet-queue-destroy"><a href="#packet-queue-destroy" class="headerlink" title="packet_queue_destroy"></a>packet_queue_destroy</h4><p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_flush</span><span class="params">(PacketQueue *q)</span> &#123;</span><br><span class="line">  MyAVPacketList *pkt, *pkt1;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="comment">// 遍历整个链表，将每个节点的AVPacket对象进行销毁</span></span><br><span class="line">  <span class="keyword">for</span> (pkt = q-&gt;first_pkt; pkt; pkt = pkt1) &#123;</span><br><span class="line">    pkt1 = pkt-&gt;next;</span><br><span class="line">    av_packet_unref(&amp;pkt-&gt;pkt);</span><br><span class="line">    av_freep(&amp;pkt);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将队列重置</span></span><br><span class="line">  q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;first_pkt = <span class="literal">NULL</span>;</span><br><span class="line">  q-&gt;nb_packets = <span class="number">0</span>;</span><br><span class="line">  q-&gt;size = <span class="number">0</span>;</span><br><span class="line">  q-&gt;duration = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">packet_queue_destroy</span><span class="params">(PacketQueue *q)</span> &#123;</span><br><span class="line">  <span class="comment">// 销毁队列</span></span><br><span class="line">  packet_queue_flush(q);</span><br><span class="line">  <span class="comment">// 销毁锁</span></span><br><span class="line">  SDL_DestroyMutex(q-&gt;mutex);</span><br><span class="line">  SDL_DestroyCond(q-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->

<h4 id="packet-queue-get"><a href="#packet-queue-get" class="headerlink" title="packet_queue_get"></a>packet_queue_get</h4><p>从队列中取出头节点，block参数表明当队列为空时是否需要阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_get</span><span class="params">(PacketQueue *q, AVPacket *pkt, <span class="type">int</span> block,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> *serial)</span> &#123;</span><br><span class="line">  MyAVPacketList *pkt1;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 如果退出标记，则退出</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;abort_request) &#123;</span><br><span class="line">      ret = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取队列的头节点</span></span><br><span class="line">    pkt1 = q-&gt;first_pkt;</span><br><span class="line">    <span class="keyword">if</span> (pkt1) &#123;</span><br><span class="line">      <span class="comment">// 将头结点的下一个节点作为新的头结点</span></span><br><span class="line">      q-&gt;first_pkt = pkt1-&gt;next;</span><br><span class="line">      <span class="comment">// 如果新头结点为空，则说明当前队列空了，将尾节点也设为空</span></span><br><span class="line">      <span class="keyword">if</span> (!q-&gt;first_pkt) q-&gt;last_pkt = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">// 节点数量-1</span></span><br><span class="line">      q-&gt;nb_packets--;</span><br><span class="line">      <span class="comment">// 队列中总字节数减少</span></span><br><span class="line">      q-&gt;size -= pkt1-&gt;pkt.size + <span class="keyword">sizeof</span>(*pkt1);</span><br><span class="line">      <span class="comment">// 队列中总时长减少</span></span><br><span class="line">      q-&gt;duration -= pkt1-&gt;pkt.duration;</span><br><span class="line">      <span class="comment">// 获取节点中的AVPacket，赋值给参数中的pkt指针</span></span><br><span class="line">      *pkt = pkt1-&gt;pkt;</span><br><span class="line">      <span class="comment">// 将节点的序号赋值给参数中的serial指针</span></span><br><span class="line">      <span class="keyword">if</span> (serial) *serial = pkt1-&gt;serial;</span><br><span class="line">      <span class="comment">// 释放节点</span></span><br><span class="line">      av_free(pkt1);</span><br><span class="line">      ret = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">      <span class="comment">// 如果头结点为空，而block为0，则不阻塞，直接返回</span></span><br><span class="line">      ret = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果头结点为空，block为1，则wait等待</span></span><br><span class="line">      SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="packet-queue-put"><a href="#packet-queue-put" class="headerlink" title="packet_queue_put"></a>packet_queue_put</h4><p>在队列尾部插入新节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put_private</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> &#123;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  MyAVPacketList *pkt1;</span><br><span class="line">  <span class="comment">// 如果退出，则返回</span></span><br><span class="line">  <span class="keyword">if</span> (q-&gt;abort_request) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  pkt1 = av_malloc(<span class="keyword">sizeof</span>(MyAVPacketList));</span><br><span class="line">  <span class="keyword">if</span> (!pkt1) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// 将AVPacket保存到节点中</span></span><br><span class="line">  pkt1-&gt;pkt = *pkt;</span><br><span class="line">  pkt1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 如果加入的数据是flush_pkt标记，则序号+1</span></span><br><span class="line">  <span class="keyword">if</span> (pkt == &amp;flush_pkt) q-&gt;serial++;</span><br><span class="line">  pkt1-&gt;serial = q-&gt;serial;</span><br><span class="line">  <span class="comment">// 如果队列中尾节点为空，则将当前节点作为头结点，否则，将当前节点作为尾节点的下一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (!q-&gt;last_pkt)</span><br><span class="line">    q-&gt;first_pkt = pkt1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    q-&gt;last_pkt-&gt;next = pkt1;</span><br><span class="line">  <span class="comment">// 将当前节点作为队列新的尾节点</span></span><br><span class="line">  q-&gt;last_pkt = pkt1;</span><br><span class="line">  <span class="comment">// 节点数量+1</span></span><br><span class="line">  q-&gt;nb_packets++;</span><br><span class="line">  <span class="comment">// 队列中总字节数增加</span></span><br><span class="line">  q-&gt;size += pkt1-&gt;pkt.size + <span class="keyword">sizeof</span>(*pkt1);</span><br><span class="line">  <span class="comment">// 队列中总时长增加</span></span><br><span class="line">  q-&gt;duration += pkt1-&gt;pkt.duration;</span><br><span class="line">  <span class="comment">/* <span class="doctag">XXX:</span> should duplicate packet data in DV case */</span></span><br><span class="line">  <span class="comment">// 唤醒wait线程</span></span><br><span class="line">  SDL_CondSignal(q-&gt;cond);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">packet_queue_put</span><span class="params">(PacketQueue *q, AVPacket *pkt)</span> &#123;</span><br><span class="line">  <span class="type">int</span> ret;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="comment">// 入队列</span></span><br><span class="line">  ret = packet_queue_put_private(q, pkt);</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line">  <span class="comment">// 如果失败，则释放AVPacket</span></span><br><span class="line">  <span class="keyword">if</span> (pkt != &amp;flush_pkt &amp;&amp; ret &lt; <span class="number">0</span>) av_packet_unref(pkt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="FrameQueue"><a href="#FrameQueue" class="headerlink" title="FrameQueue"></a>FrameQueue</h3><p>Frame队列与Packet队列不同，因为Frame中存储的是原始数据，是非常庞大的，所以需要设置成有限队列，这里采用的是滚动数组的方式来实现，分别用读写两个索引来记录位置。</p>
<p>由于将数组进行了读写分离，所以在线程加锁时有了优化，不再需要锁住整个函数，可以局部加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FrameQueue</span> &#123;</span></span><br><span class="line">  <span class="comment">// 使用滚动数组来实现的Frame队列</span></span><br><span class="line">  Frame <span class="built_in">queue</span></span><br><span class="line">      [FRAME_QUEUE_SIZE];  <span class="comment">// 数据帧数组，使用数组来实现的队列，默认大小为FRAME_QUEUE_SIZE</span></span><br><span class="line">  <span class="type">int</span> rindex;              <span class="comment">// 读索引</span></span><br><span class="line">  <span class="type">int</span> windex;              <span class="comment">// 写索引</span></span><br><span class="line">  <span class="type">int</span> size;                <span class="comment">// 当前写入的数据大小</span></span><br><span class="line">  <span class="type">int</span> max_size;  <span class="comment">// 外部设置的队列最大允许存储的大小，该值不超过FRAME_QUEUE_SIZE</span></span><br><span class="line">  <span class="type">int</span> keep_last;  <span class="comment">// 是否保留最后一个读数据，如果是1，则rindex_shown的值就为1。并且后面rindex所指向的位置实际上是上个次读的索引，而rindex+rindex_shown才是当前读的索引</span></span><br><span class="line">  <span class="type">int</span> rindex_shown;  <span class="comment">// 用来配合keep_last，如果keep_last为1，则再第一次next后，rindex_shown也会为1</span></span><br><span class="line">  SDL_mutex *mutex;  <span class="comment">// 队列锁</span></span><br><span class="line">  SDL_cond *cond;    <span class="comment">// 队列锁互斥量</span></span><br><span class="line">  PacketQueue *pktq;  <span class="comment">// 关联的Packet队列</span></span><br><span class="line">&#125; FrameQueue;</span><br></pre></td></tr></table></figure>

<h4 id="frame-queue-init"><a href="#frame-queue-init" class="headerlink" title="frame_queue_init"></a>frame_queue_init</h4><p>初始化队列，并设置队列的最大大小，根据最大大小提前创建好每一个Frame对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_init</span><span class="params">(FrameQueue *f, PacketQueue *pktq, <span class="type">int</span> max_size,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> keep_last)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 初始化原始数据队列，清零</span></span><br><span class="line">  <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(FrameQueue));</span><br><span class="line">  <span class="comment">// 创建原始数据队列的锁</span></span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;mutex = SDL_CreateMutex())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateMutex(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建原始数据队列的互斥量</span></span><br><span class="line">  <span class="keyword">if</span> (!(f-&gt;cond = SDL_CreateCond())) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_FATAL, <span class="string">&quot;SDL_CreateCond(): %s\n&quot;</span>, SDL_GetError());</span><br><span class="line">    <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关联原始数据队列和编码数据队列</span></span><br><span class="line">  f-&gt;pktq = pktq;</span><br><span class="line">  <span class="comment">// 设置原始数据队列的最大大小</span></span><br><span class="line">  f-&gt;max_size = FFMIN(max_size, FRAME_QUEUE_SIZE);</span><br><span class="line">  <span class="comment">// 是否保留最后一个读的数据</span></span><br><span class="line">  f-&gt;keep_last = !!keep_last;</span><br><span class="line">  <span class="comment">// 提前分配好所有的Frame</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++)</span><br><span class="line">    <span class="keyword">if</span> (!(f-&gt;<span class="built_in">queue</span>[i].frame = av_frame_alloc())) <span class="keyword">return</span> AVERROR(ENOMEM);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="frame-queue-destory"><a href="#frame-queue-destory" class="headerlink" title="frame_queue_destory"></a>frame_queue_destory</h4><p>销毁队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_destory</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// 释放所有的原始数据帧</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; f-&gt;max_size; i++) &#123;</span><br><span class="line">    Frame *vp = &amp;f-&gt;<span class="built_in">queue</span>[i];</span><br><span class="line">    <span class="comment">// 主要是销毁AVFrame和AVSubtitle</span></span><br><span class="line">    frame_queue_unref_item(vp);</span><br><span class="line">    av_frame_free(&amp;vp-&gt;frame);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 销毁锁和互斥量</span></span><br><span class="line">  SDL_DestroyMutex(f-&gt;mutex);</span><br><span class="line">  SDL_DestroyCond(f-&gt;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="frame-queue-peek-readable"><a href="#frame-queue-peek-readable" class="headerlink" title="frame_queue_peek_readable"></a>frame_queue_peek_readable</h4><p>读取这里也和Packet队列不同，首先通过frame_queue_peek_readable获取到读索引位置的节点，想要获取下一个节点，需要调用frame_queue_next将读索引移动到下一个位置。</p>
<p>读取时如果当前队列为空，则进行阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中取出一个可读的帧</span></span><br><span class="line"><span class="comment"> * @param 队列</span></span><br><span class="line"><span class="comment"> * @return 队列中可读的帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_readable</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="comment">/* wait until we have a readable a new frame */</span></span><br><span class="line">  <span class="comment">// 同写入，size是读写线程都需要操作的，所以需要加锁</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// 如果设置了keep_last，则在next后，rindex_shown为1，</span></span><br><span class="line">  <span class="comment">// rindex_shown为1其实就是标记rindex少走了一步，也等于size少减了1，所以这里计算size时需要减去1</span></span><br><span class="line">  <span class="comment">// 如果队列为空</span></span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size - f-&gt;rindex_shown &lt;= <span class="number">0</span> &amp;&amp; !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    <span class="comment">// 等待写线程notify</span></span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列解锁</span></span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// 如果关联的Packet队列退出，则返回null</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// rindex + rindex_shown</span></span><br><span class="line">  <span class="comment">// （当rindex_shown为1时，rindex少了一次+1，所以需要加上1）</span></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[(f-&gt;rindex + f-&gt;rindex_shown) % f-&gt;max_size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>frame_queue_next中并没有对队列进行判空，所以调用该方法的时候需要先用frame_queue_nb_remaining判断一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知队列数据已经读取，rindex位置的帧已经被外部使用</span></span><br><span class="line"><span class="comment"> * rindex需要向后移动，以便frame_queue_peek_readable获取后续的数据</span></span><br><span class="line"><span class="comment"> * @param f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_next</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果当前队列设置了保留最后一帧，则rindex少走一步，size少减1</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;keep_last &amp;&amp; !f-&gt;rindex_shown) &#123;</span><br><span class="line">    <span class="comment">// 标记rindex_shown来弥补这1步</span></span><br><span class="line">    f-&gt;rindex_shown = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果队列设置了keep_last，则这里的删除操作针对的都是上一帧，而不是当前帧</span></span><br><span class="line">  <span class="comment">// 删除rindex位置的帧数据，AVFrame和AVSubtitle</span></span><br><span class="line">  frame_queue_unref_item(&amp;f-&gt;<span class="built_in">queue</span>[f-&gt;rindex]);</span><br><span class="line">  <span class="comment">// rindex+1,向后移动一位，如果超出，则从头开始</span></span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;rindex == f-&gt;max_size) f-&gt;rindex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// size减1</span></span><br><span class="line">  f-&gt;size--;</span><br><span class="line">  <span class="comment">// 通知写线程有空位写入，唤醒wait</span></span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取当前队列中可读的节点数量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">frame_queue_nb_remaining</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="comment">// 返回当前队列中已有的帧数量</span></span><br><span class="line">  <span class="keyword">return</span> f-&gt;size - f-&gt;rindex_shown;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="frame-queue-peek-writable"><a href="#frame-queue-peek-writable" class="headerlink" title="frame_queue_peek_writable"></a>frame_queue_peek_writable</h4><p>写入的话和读取一样，先通过frame_queue_peek_writable获取当前写索引位置的节点，写入完毕后，调用frame_queue_push通知队列写入完毕，写索引向后移动一位。</p>
<p>写入时如果当前队列已满，那么会进行阻塞等待。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从队列中取出一个可写入的帧</span></span><br><span class="line"><span class="comment"> * @param 队列</span></span><br><span class="line"><span class="comment"> * @return 队列中可写入的帧</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> Frame *<span class="title function_">frame_queue_peek_writable</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="comment">/* wait until we have space to put a new frame */</span></span><br><span class="line">  <span class="comment">// 队列加锁（因为读线程和写线程都会对队列的size进行修改，所以需要加锁）</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// 如果队列已满，并且关联的Packet队列并没有退出(避免死循环)，则循环wait</span></span><br><span class="line">  <span class="keyword">while</span> (f-&gt;size &gt;= f-&gt;max_size &amp;&amp; !f-&gt;pktq-&gt;abort_request) &#123;</span><br><span class="line">    <span class="comment">// wait，等待notify</span></span><br><span class="line">    SDL_CondWait(f-&gt;cond, f-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 队列解锁</span></span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// 只有写线程才需要进行写入，才会改变windex的值，所以获取写入的帧操作并不需要加锁</span></span><br><span class="line">  <span class="comment">// 如果关联的Packet队列退出，则返回null</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;pktq-&gt;abort_request) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 返回windex位置的Frame供外部写入</span></span><br><span class="line">  <span class="keyword">return</span> &amp;f-&gt;<span class="built_in">queue</span>[f-&gt;windex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知队列数据已经写入，windex位置的帧已经写入了数据</span></span><br><span class="line"><span class="comment"> * 数据写入的帧是通过frame_queue_peek_writable获取的</span></span><br><span class="line"><span class="comment"> * @param 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">frame_queue_push</span><span class="params">(FrameQueue *f)</span> &#123;</span><br><span class="line">  <span class="comment">// 将windex+1，往后移一位，如果后面已经到底了，则从头开始（环状）</span></span><br><span class="line">  <span class="keyword">if</span> (++f-&gt;windex == f-&gt;max_size) f-&gt;windex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 同上，windex只有写线程操作，所以不需要加锁，但是下面的size的操作是读线程和写线程都需要操作的，所以需要加锁</span></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  SDL_LockMutex(f-&gt;mutex);</span><br><span class="line">  <span class="comment">// 队列的size+1</span></span><br><span class="line">  f-&gt;size++;</span><br><span class="line">  <span class="comment">// notify通知读线程，唤醒wait</span></span><br><span class="line">  SDL_CondSignal(f-&gt;cond);</span><br><span class="line">  <span class="comment">// 释放锁</span></span><br><span class="line">  SDL_UnlockMutex(f-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="MyAVPacketList"><a href="#MyAVPacketList" class="headerlink" title="MyAVPacketList"></a>MyAVPacketList</h3><p>Packet队列中的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> &#123;</span></span><br><span class="line">  AVPacket pkt;                 <span class="comment">// 编码数据</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MyAVPacketList</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个节点</span></span><br><span class="line">  <span class="type">int</span> serial;                   <span class="comment">// 序号</span></span><br><span class="line">&#125; MyAVPacketList;</span><br></pre></td></tr></table></figure>

<h3 id="Frame"><a href="#Frame" class="headerlink" title="Frame"></a>Frame</h3><p>Frame队列中的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Frame</span> &#123;</span></span><br><span class="line">  <span class="comment">// 对数据帧的统一抽象，包含音频帧、视频帧、字幕帧</span></span><br><span class="line">  AVFrame *frame;  <span class="comment">// 音视频帧</span></span><br><span class="line">  AVSubtitle sub;  <span class="comment">// 字幕帧</span></span><br><span class="line">  <span class="type">int</span> serial; <span class="comment">// 序号</span></span><br><span class="line">  <span class="type">double</span> pts; <span class="comment">// pts</span></span><br><span class="line">  <span class="type">double</span> duration; <span class="comment">// 显示时长</span></span><br><span class="line">  <span class="type">int64_t</span> pos; <span class="comment">// 在流中的位置</span></span><br><span class="line">  <span class="type">int</span> width; <span class="comment">// 宽</span></span><br><span class="line">  <span class="type">int</span> height; <span class="comment">// 高</span></span><br><span class="line">  <span class="type">int</span> format; <span class="comment">// 格式</span></span><br><span class="line">  AVRational sar; <span class="comment">// 横纵比</span></span><br><span class="line">  <span class="type">int</span> uploaded; <span class="comment">// 是否上传到纹理上</span></span><br><span class="line">  <span class="type">int</span> flip_v; <span class="comment">// 是否需要翻转</span></span><br><span class="line">&#125; Frame;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>x265源码分析之帧类型决策</title>
    <url>/2022/03/02/av/x265%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%B8%A7%E7%B1%BB%E5%9E%8B%E5%86%B3%E7%AD%96/</url>
    <content><![CDATA[<h1 id="Lookahead"><a href="#Lookahead" class="headerlink" title="Lookahead"></a>Lookahead</h1><p>Lookahead是预处理模块，负责对输入的待编码图像进行下采样、复杂度预计算、帧类型决策等编码前期处理。</p>
<p>在Lookahead中维护了两个队列，外部输入的待编码图像按照输入的顺序放入到m_inputQueue队列中等待预处理，当m_inputQueue中数量超过指定阈值时，就会开始预处理，预处理完毕的就会根据DTS顺序放入到m_outputQueue中等待取出编码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Lookahead</span> : <span class="keyword">public</span> JobProvider</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 输入队列，PTS顺序</span></span><br><span class="line">    PicList       m_inputQueue;      <span class="comment">// input pictures in order received</span></span><br><span class="line">    <span class="comment">// 输出队列，DTS顺序</span></span><br><span class="line">    PicList       m_outputQueue;     <span class="comment">// pictures to be encoded, in encode order</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>每个Encoder都持有一个Lookahead，在Encoder创建时，Lookahead也会被创建。Lookahead内部拥有一个线程池，每次预处理操作都是在子线程中进行。lookaheadThreads默认是0，默认Lookahead和FrameEncoder共用一个线程池。线程池中的线程会在此时全部启动并阻塞等待着唤醒。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Encoder::create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pools = m_numPools;</span><br><span class="line">    ThreadPool* lookAheadThreadPool = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// lookaheadThreads默认是0</span></span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;lookaheadThreads &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lookAheadThreadPool = ThreadPool::<span class="built_in">allocThreadPools</span>(p, pools, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        lookAheadThreadPool = m_threadPool; <span class="comment">// 和FrameEncoder共用线程池</span></span><br><span class="line">    m_lookahead = <span class="keyword">new</span> <span class="built_in">Lookahead</span>(m_param, lookAheadThreadPool);</span><br><span class="line">    <span class="keyword">if</span> (pools)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lookahead-&gt;m_jpId = lookAheadThreadPool[<span class="number">0</span>].m_numProviders++;</span><br><span class="line">        lookAheadThreadPool[<span class="number">0</span>].m_jpTable[m_lookahead-&gt;m_jpId] = m_lookahead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;lookaheadThreads &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pools; i++)</span><br><span class="line">            lookAheadThreadPool[i].<span class="built_in">start</span>(); <span class="comment">// 启动线程池中的所有线程</span></span><br><span class="line">    m_lookahead-&gt;m_numPools = pools;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m_lookahead-&gt;<span class="built_in">create</span>())</span><br><span class="line">        m_aborted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="addPicture"><a href="#addPicture" class="headerlink" title="addPicture"></a>addPicture</h2><p>接入一个输入图像，放入到m_inputQueue，每次add都会尝试一次支持预处理任务</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lookahead::addPicture</span><span class="params">(Frame&amp; curFrame, <span class="type">int</span> sliceType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">checkLookaheadQueue</span>(m_inputCount); <span class="comment">// 尝试一次支持预处理任务</span></span><br><span class="line">    <span class="built_in">addPicture</span>(curFrame); <span class="comment">// 放入到m_inputQueue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将输入图像放入到m_inputQueue中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lookahead::addPicture</span><span class="params">(Frame&amp; curFrame)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_inputLock.<span class="built_in">acquire</span>();</span><br><span class="line">    m_inputQueue.<span class="built_in">pushBack</span>(curFrame);</span><br><span class="line">    m_inputLock.<span class="built_in">release</span>();</span><br><span class="line">    m_inputCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="checkLookaheadQueue"><a href="#checkLookaheadQueue" class="headerlink" title="checkLookaheadQueue"></a>checkLookaheadQueue</h2><p>尝试执行一次预处理任务，判断当前m_inputQueue中的数量是否大于阈值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The number of frames that must be queued in the lookahead before it may</span></span><br><span class="line"><span class="comment"> * make slice decisions. Increasing this value directly increases the encode</span></span><br><span class="line"><span class="comment"> * latency. The longer the queue the more optimally the lookahead may make</span></span><br><span class="line"><span class="comment"> * slice decisions, particularly with b-adapt 2. When cu-tree is enabled,</span></span><br><span class="line"><span class="comment"> * the length of the queue linearly increases the effectiveness of the</span></span><br><span class="line"><span class="comment"> * cu-tree analysis. Default is 40 frames, maximum is 250 */</span></span><br><span class="line"><span class="type">int</span>       lookaheadDepth;  <span class="comment">// 进行预处理必须的帧数，只有待处理帧数大于该值才会进行处理</span></span><br></pre></td></tr></table></figure>
<p>当filled为true时，getDecidedPicture从m_outputQueue中返回数据，如果m_outputQueue为空，则会阻塞等待</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lookahead::checkLookaheadQueue</span><span class="params">(<span class="type">int</span> &amp;frameCnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* determine if the lookahead is (over) filled enough for frames to begin to</span></span><br><span class="line"><span class="comment">     * be consumed by frame encoders */</span></span><br><span class="line">    <span class="keyword">if</span> (!m_filled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_param-&gt;bframes &amp; !m_param-&gt;lookaheadDepth)</span><br><span class="line">            m_filled = <span class="literal">true</span>; <span class="comment">/* zero-latency */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (frameCnt &gt;= m_param-&gt;lookaheadDepth + <span class="number">2</span> + m_param-&gt;bframes)</span><br><span class="line">            m_filled = <span class="literal">true</span>; <span class="comment">/* full capacity plus mini-gop lag */</span> <span class="comment">// 当剩余输入的帧数量达到一定值，才会开启编码，为了避免encode阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_inputLock.<span class="built_in">acquire</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_pool &amp;&amp; m_inputQueue.<span class="built_in">size</span>() &gt;= m_fullQueueSize)</span><br><span class="line">        <span class="built_in">tryWakeOne</span>(); <span class="comment">// 从线程池中唤醒一个空闲线程，执行findJob</span></span><br><span class="line">    m_inputLock.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="findJob"><a href="#findJob" class="headerlink" title="findJob"></a>findJob</h2><p>子线程中执行，子线程每次被唤醒都会调用该方法来获取需要处理的任务，任务执行完成则继续等待下次唤醒。虽然Lookahead绑定了线程池，可以多线程同时处理，但是帧类型决策是不支持多线程的，所以<strong>通过m_sliceTypeBusy来保证同一时间只会有一个线程真正的进行预处理任务</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Lookahead::findJob</span><span class="params">(<span class="type">int</span> <span class="comment">/*workerThreadID*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> doDecide;</span><br><span class="line"></span><br><span class="line">    m_inputLock.<span class="built_in">acquire</span>();</span><br><span class="line">    <span class="comment">// 虽然预处理是可以被多个线程同时处理的，但是帧类型决策是不能同时多个线程一起的，所以当一个线程标记m_sliceTypeBusy后，其它线程不可以再进行帧类型决策</span></span><br><span class="line">    <span class="keyword">if</span> (m_inputQueue.<span class="built_in">size</span>() &gt;= m_fullQueueSize &amp;&amp; !m_sliceTypeBusy &amp;&amp; m_isActive)</span><br><span class="line">        doDecide = m_sliceTypeBusy = <span class="literal">true</span>; <span class="comment">// 标记当前线程进行帧类型决策</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        doDecide = m_helpWanted = <span class="literal">false</span>; <span class="comment">// 标记当前线程不进行帧类型决策</span></span><br><span class="line">    m_inputLock.<span class="built_in">release</span>();</span><br><span class="line">    <span class="comment">// 如果已经有线程在处理了，则当前线程退出任务</span></span><br><span class="line">    <span class="keyword">if</span> (!doDecide)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ProfileLookaheadTime</span>(m_slicetypeDecideElapsedTime, m_countSlicetypeDecide);</span><br><span class="line">    <span class="built_in">ProfileScopeEvent</span>(slicetypeDecideEV);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">slicetypeDecide</span>(); <span class="comment">// 帧类型决策</span></span><br><span class="line"></span><br><span class="line">    m_inputLock.<span class="built_in">acquire</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_outputSignalRequired)</span><br><span class="line">    &#123;</span><br><span class="line">        m_outputSignal.<span class="built_in">trigger</span>(); <span class="comment">// 唤醒等待线程，如果在getDecidedPicture中阻塞了</span></span><br><span class="line">        m_outputSignalRequired = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_sliceTypeBusy = <span class="literal">false</span>;</span><br><span class="line">    m_inputLock.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="slicetypeDecide"><a href="#slicetypeDecide" class="headerlink" title="slicetypeDecide"></a>slicetypeDecide</h2><p>子线程中执行，进行帧类型决策，每一次帧类型决策都是决策到下一个非b帧为止，决策完成的帧会放入到输出队列中等待编码线程进行处理。</p>
<h3 id="下采样"><a href="#下采样" class="headerlink" title="下采样"></a>下采样</h3><p>对每个要预处理的帧，都初始化一个1&#x2F;2下采样的图像，因为下采样任务是可以多线程并行的，所以是通过线程池分发的，会同步等待所有任务都处理完成。</p>
<p><strong>frames</strong><br>存储所有参与本次帧决策的帧，数据来源为m_inputQueue中每一帧的下采样数据，长度为lookaheadDepth + 1，frames[0]为m_lastNonB（上一个非b帧）。</p>
<p><strong>list</strong><br>存放的是本次帧决策中连续B帧以及B帧的前后参考帧，长度为bframes + 2。(最终被真正被决策的帧)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要预处理的帧列表</span></span><br><span class="line"><span class="function">PreLookaheadGroup <span class="title">pre</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">Lowres* frames[X265_LOOKAHEAD_MAX + X265_BFRAME_MAX + <span class="number">4</span>]; <span class="comment">// 所有参与到帧类型决策的帧的下采样图像</span></span><br><span class="line">Frame*  list[X265_BFRAME_MAX + <span class="number">4</span>]; <span class="comment">// b帧列表</span></span><br><span class="line"><span class="built_in">memset</span>(frames, <span class="number">0</span>, <span class="built_in">sizeof</span>(frames));</span><br><span class="line"><span class="built_in">memset</span>(list, <span class="number">0</span>, <span class="built_in">sizeof</span>(list));</span><br><span class="line"><span class="type">int</span> maxSearch = <span class="built_in">X265_MIN</span>(m_param-&gt;lookaheadDepth, X265_LOOKAHEAD_MAX);</span><br><span class="line">maxSearch = <span class="built_in">X265_MAX</span>(<span class="number">1</span>, maxSearch);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ScopedLock <span class="title">lock</span><span class="params">(m_inputLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    Frame *curFrame = m_inputQueue.<span class="built_in">first</span>();</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// （连续b帧 + 后非b帧）数量的帧放入到list中进行b帧的决策</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m_param-&gt;bframes + <span class="number">2</span>; j++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!curFrame) <span class="keyword">break</span>;</span><br><span class="line">        list[j] = curFrame;</span><br><span class="line">        curFrame = curFrame-&gt;m_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curFrame = m_inputQueue.<span class="built_in">first</span>();</span><br><span class="line">    frames[<span class="number">0</span>] = m_lastNonB;</span><br><span class="line">    <span class="comment">// 在m_inputQueue遍历lookaheadDepth个图像</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; maxSearch; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!curFrame) <span class="keyword">break</span>;</span><br><span class="line">        frames[j + <span class="number">1</span>] = &amp;curFrame-&gt;m_lowres;</span><br><span class="line">        <span class="comment">// 如果当前帧没有进行下采样处理，加入到预处理任务组中</span></span><br><span class="line">        <span class="keyword">if</span> (!curFrame-&gt;m_lowresInit)</span><br><span class="line">            pre.m_preframes[pre.m_jobTotal++] = curFrame;</span><br><span class="line"></span><br><span class="line">        curFrame = curFrame-&gt;m_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maxSearch = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform pre-analysis on frames which need it, using a bonded task group */</span></span><br><span class="line"><span class="keyword">if</span> (pre.m_jobTotal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程池分发任务，异步处理，进行1/2下采样，并计算帧内预测的成本估计，frames[i].costEst[0][0]</span></span><br><span class="line">    <span class="keyword">if</span> (m_pool)</span><br><span class="line">        pre.<span class="built_in">tryBondPeers</span>(*m_pool, pre.m_jobTotal);</span><br><span class="line">    pre.<span class="built_in">processTasks</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 等待任务组处理完成</span></span><br><span class="line">    pre.<span class="built_in">waitForExit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="帧类型决策"><a href="#帧类型决策" class="headerlink" title="帧类型决策"></a>帧类型决策</h3><p>帧类型决策，决策B帧，如果没有开启B帧，则无需决策。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启了b帧，并且前向的非b帧有值</span></span><br><span class="line"><span class="keyword">if</span> (m_lastNonB &amp;&amp;</span><br><span class="line">    ((m_param-&gt;bFrameAdaptive &amp;&amp; m_param-&gt;bframes) ||</span><br><span class="line">     m_param-&gt;rc.cuTree || m_param-&gt;scenecutThreshold || m_param-&gt;bHistBasedSceneCut ||</span><br><span class="line">     (m_param-&gt;lookaheadDepth &amp;&amp; m_param-&gt;rc.vbvBufferSize)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!m_param-&gt;rc.bStatRead)</span><br><span class="line">        <span class="built_in">slicetypeAnalyse</span>(frames, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="决策帧准备"><a href="#决策帧准备" class="headerlink" title="决策帧准备"></a>决策帧准备</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> numFrames, origNumFrames, keyintLimit, framecnt;</span><br><span class="line"><span class="type">int</span> maxSearch = <span class="built_in">X265_MIN</span>(m_param-&gt;lookaheadDepth, X265_LOOKAHEAD_MAX);</span><br><span class="line"><span class="type">int</span> cuCount = m_8x8Blocks;</span><br><span class="line"><span class="type">int</span> resetStart;</span><br><span class="line"><span class="type">bool</span> bIsVbvLookahead = m_param-&gt;rc.vbvBufferSize &amp;&amp; m_param-&gt;lookaheadDepth;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计未决策的帧数量</span></span><br><span class="line"><span class="keyword">for</span> (framecnt = <span class="number">0</span>; framecnt &lt; maxSearch; framecnt++)</span><br><span class="line">&#123;</span><br><span class="line">    Lowres *fenc = frames[framecnt + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!fenc || fenc-&gt;sliceType != X265_TYPE_AUTO)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前列表中的帧都已经决策过，则跳过</span></span><br><span class="line"><span class="keyword">if</span> (!framecnt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;rc.cuTree)</span><br><span class="line">        <span class="built_in">cuTree</span>(frames, <span class="number">0</span>, bKeyframe);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">frames[framecnt + <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 关键帧最大间隔</span></span><br><span class="line"><span class="type">int</span> keylimit = m_param-&gt;keyframeMax;</span><br><span class="line"><span class="comment">// 关键帧当前间隔</span></span><br><span class="line"><span class="type">int</span> keyFrameLimit = keylimit + m_lastKeyframe - frames[<span class="number">0</span>]-&gt;frameNum - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果当前未决策帧中需要插入关键帧，则截断，numFrames为截断后的剩余帧数量，framecnt为截断前数量，numFrames &lt; framecnt表明中间要插入一个关键帧</span></span><br><span class="line">origNumFrames = numFrames = m_param-&gt;bIntraRefresh ? framecnt : <span class="built_in">X265_MIN</span>(framecnt, keyintLimit);</span><br><span class="line"><span class="keyword">if</span> (bIsVbvLookahead)</span><br><span class="line">    numFrames = framecnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_param-&gt;bOpenGOP &amp;&amp; numFrames &lt; framecnt) <span class="comment">// 对于OpenGOP来说，可以参考下个GOP的关键帧，所以numFrames+1</span></span><br><span class="line">    numFrames++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (numFrames == <span class="number">0</span>) <span class="comment">// numFrames为0，表明当前第一帧就必须是关键帧，则直接将frames[1]定义为I帧，返回，在帧类型修正中会决定是否修正为IDR</span></span><br><span class="line">&#123;</span><br><span class="line">    frames[<span class="number">1</span>]-&gt;sliceType = X265_TYPE_I;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考帧成本估算"><a href="#参考帧成本估算" class="headerlink" title="参考帧成本估算"></a>参考帧成本估算</h4><p>成本估算搜索的是运动矢量，CostEstimateGroup表示一个任务组，组内的任务会并行处理。这里主要针对每一帧计算其所有可以的前后参考帧组合下的成本，方便后面进行最优路径搜索时进行比较。frames[i].costEst中存储了估算结果，costEst是个二维数组，第一维是当前帧与前向参考帧的距离，第二维是当前帧与后向参考帧的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_bBatchMotionSearch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 成本估计任务组，frames为数据源</span></span><br><span class="line">    <span class="function">CostEstimateGroup <span class="title">estGroup</span><span class="params">(*<span class="keyword">this</span>, frames)</span></span>;</span><br><span class="line">    <span class="comment">// b表示第几帧，从1开始，由于第1帧是上一个非B帧，所以从第2帧开始计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">2</span>; b &lt; numFrames; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每帧预测的帧范围, 前向参考帧范围[b - (bframes + 1), b)，后向参考帧范围(b, b + (bframes + 1)]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_param-&gt;bframes + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p0 = b - i; <span class="comment">// 前向参考帧</span></span><br><span class="line">            <span class="keyword">if</span> (p0 &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Skip search if already done */</span></span><br><span class="line">            <span class="keyword">if</span> (frames[b]-&gt;lowresMvs[<span class="number">0</span>][i][<span class="number">0</span>].x != <span class="number">0x7FFF</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* perform search to p1 at same distance, if possible */</span></span><br><span class="line">            <span class="type">int</span> p1 = b + i; <span class="comment">// 后向参考帧，前向参考帧和后向参考帧按照相同的距离去搜索</span></span><br><span class="line">            <span class="keyword">if</span> (p1 &gt;= numFrames || frames[b]-&gt;lowresMvs[<span class="number">1</span>][i][<span class="number">0</span>].x != <span class="number">0x7FFF</span>)</span><br><span class="line">                p1 = b;</span><br><span class="line"></span><br><span class="line">            estGroup.<span class="built_in">add</span>(p0, p1, b); <span class="comment">// 添加任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* auto-disable after the first batch if pool is small */</span></span><br><span class="line">    m_bBatchMotionSearch &amp;= m_pool-&gt;m_numWorkers &gt;= <span class="number">4</span>;</span><br><span class="line">    estGroup.<span class="built_in">finishBatch</span>(); <span class="comment">// 异步处理所有任务，阻塞等待任务完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_bBatchFrameCosts)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* pre-calculate all frame cost estimates, using many worker threads */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">2</span>; b &lt; numFrames; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前向参考帧范围[b - (bframes + 1), b)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m_param-&gt;bframes + <span class="number">1</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (b &lt; i)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* only measure frame cost in this pass if motion searches</span></span><br><span class="line"><span class="comment">                 * are already done */</span></span><br><span class="line">                <span class="keyword">if</span> (frames[b]-&gt;lowresMvs[<span class="number">0</span>][i][<span class="number">0</span>].x == <span class="number">0x7FFF</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> p0 = b - i; <span class="comment">// 前向参考帧，前向参考帧和后向参考帧按照不同的距离去搜索</span></span><br><span class="line">                <span class="comment">// 后向参考帧范围[b, b + (bframes )]</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m_param-&gt;bframes; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> p1 = b + j; <span class="comment">// 后向参考帧</span></span><br><span class="line">                    <span class="keyword">if</span> (p1 &gt;= numFrames)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ensure P1 search is done */</span></span><br><span class="line">                    <span class="keyword">if</span> (j &amp;&amp; frames[b]-&gt;lowresMvs[<span class="number">1</span>][j][<span class="number">0</span>].x == <span class="number">0x7FFF</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* ensure frame cost is not done */</span></span><br><span class="line">                    <span class="keyword">if</span> (frames[b]-&gt;costEst[i][j] &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    estGroup.<span class="built_in">add</span>(p0, p1, b); <span class="comment">// 添加任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* auto-disable after the first batch if the pool is not large */</span></span><br><span class="line">        m_bBatchFrameCosts &amp;= m_pool-&gt;m_numWorkers &gt; <span class="number">12</span>;</span><br><span class="line">        estGroup.<span class="built_in">finishBatch</span>(); <span class="comment">// 异步处理所有任务，阻塞等待任务完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h4><p>检测决策数组中第一帧是否和上个非B帧是场景切换，如果是则需要重新定义上一个参考帧，本次决策退出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isScenecut = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When scenecut threshold is set, use scenecut detection for I frame placements */</span></span><br><span class="line"><span class="keyword">if</span> (!m_param-&gt;bHistBasedSceneCut || (m_param-&gt;bHistBasedSceneCut &amp;&amp; frames[<span class="number">1</span>]-&gt;bScenecut))</span><br><span class="line">    isScenecut = <span class="built_in">scenecut</span>(frames, <span class="number">0</span>, <span class="number">1</span>, <span class="literal">true</span>, origNumFrames); <span class="comment">// 检测当前frames[0]和frames[1]是否是场景切换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isScenecut &amp;&amp; (m_param-&gt;bHistBasedSceneCut || m_param-&gt;scenecutThreshold))</span><br><span class="line">&#123;</span><br><span class="line">    frames[<span class="number">1</span>]-&gt;sliceType = X265_TYPE_I; <span class="comment">// 如果是场景切换，则将第一帧frames[1]定义为I帧，并退出</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="B帧决策"><a href="#B帧决策" class="headerlink" title="B帧决策"></a>B帧决策</h4><p>B帧决策策略有三种，一种是X265_B_ADAPT_TRELLIS最优决策，一种是X265_B_ADAPT_FAST最快决策，最后一种就是没有决策X265_B_ADAPT_NONE。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="type">int</span> numBFrames = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> numAnalyzed = numFrames;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;bframes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_param-&gt;bFrameAdaptive == X265_B_ADAPT_TRELLIS)</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_param-&gt;bFrameAdaptive == X265_B_ADAPT_FAST)</span><br><span class="line">        &#123;</span><br><span class="line">					 	...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">					  ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 遍历第一段连续B帧，检测是否有场景切换，如果有则将该帧设置为P帧</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; numBFrames + <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> isNextScenecut = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!m_param-&gt;bHistBasedSceneCut || (m_param-&gt;bHistBasedSceneCut &amp;&amp; frames[j + <span class="number">1</span>]-&gt;bScenecut))</span><br><span class="line">                    isNextScenecut = <span class="built_in">scenecut</span>(frames, j, j + <span class="number">1</span>, <span class="literal">false</span>, origNumFrames); <span class="comment">// 下一帧是否是场景切换</span></span><br><span class="line">                <span class="keyword">if</span> (isNextScenecut || (bForceRADL &amp;&amp; frames[j]-&gt;frameNum == preRADL))</span><br><span class="line">                &#123;</span><br><span class="line">                    frames[j]-&gt;sliceType = X265_TYPE_P; <span class="comment">// 将当前帧设置为P帧，下一帧会放到下一次处理</span></span><br><span class="line">                    numAnalyzed = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        resetStart = bKeyframe ? <span class="number">1</span> : <span class="built_in">X265_MIN</span>(numBFrames + <span class="number">2</span>, numAnalyzed + <span class="number">1</span>); <span class="comment">// 只保留第一段连续B帧的预测，也就是numBFrames+2长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= numFrames; j++)</span><br><span class="line">            frames[j]-&gt;sliceType = X265_TYPE_P; <span class="comment">// 没有开启B帧情况下，每一帧都是P帧</span></span><br><span class="line"></span><br><span class="line">        resetStart = bKeyframe ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将第一段连续B帧后面的帧类型都重置为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = resetStart; j &lt;= numFrames; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        frames[j]-&gt;sliceType = X265_TYPE_AUTO;</span><br><span class="line">        <span class="comment">/* If any frame marked as scenecut is being restarted for sliceDecision, </span></span><br><span class="line"><span class="comment">         * undo scene Transition flag */</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt;= maxp1 &amp;&amp; frames[j]-&gt;bScenecut &amp;&amp; m_isSceneTransition)</span><br><span class="line">            m_isSceneTransition = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="X265-B-ADAPT-TRELLIS"><a href="#X265-B-ADAPT-TRELLIS" class="headerlink" title="X265_B_ADAPT_TRELLIS"></a>X265_B_ADAPT_TRELLIS</h5><p>最优路径决策主要是根据参与决策的帧数量，依次计算1~n个帧长度下，每个长度下所有的可能路径组合，选出每个长度下最优的路径，最后算出n个长度的最优路径。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">每个长度的帧路径组合有bframes+1条，每条路径的最后一帧一定是P，P前面可选的是0个B...1个B...bframes个B，再前面的就是剩余长度下的最优路径。</span><br><span class="line"></span><br><span class="line"><span class="params">#</span> numFrames = 20, bframes = 4</span><br><span class="line">[</span><br><span class="line">  (前19个帧最优路径)	     p</span><br><span class="line">  (前18个帧最优路径)    B P</span><br><span class="line">  (前17个帧最优路径)   BB p</span><br><span class="line">  (前16个帧最优路径)  BBB p</span><br><span class="line">  (前15个帧最优路径) BBBB p</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">计算上面每条路径的最优成本，根据上面已经计算过的参考帧成本</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">numFrames = 1, bframes = 4</span><br><span class="line">[</span><br><span class="line">    P</span><br><span class="line">]</span><br><span class="line">numFrames = 2, bframes = 4</span><br><span class="line">[</span><br><span class="line">    P P</span><br><span class="line">    B P  </span><br><span class="line">]</span><br><span class="line">numFrames = 3, bframes = 4</span><br><span class="line">[</span><br><span class="line">    BP  P</span><br><span class="line">    P B P</span><br><span class="line">     BB P</span><br><span class="line">]</span><br><span class="line">numFrames = 4, bframes = 4</span><br><span class="line">[</span><br><span class="line">    BBP  P</span><br><span class="line">    BP B P</span><br><span class="line">    P BB P</span><br><span class="line">     BBB P</span><br><span class="line">]</span><br><span class="line">numFrames = 5, bframes = 4</span><br><span class="line">[</span><br><span class="line">    BBBP  P</span><br><span class="line">    BBP B P</span><br><span class="line">    BP BB P</span><br><span class="line">    P BBB P</span><br><span class="line">     BBBB P</span><br><span class="line">]</span><br><span class="line">numFrames = 6, bframes = 4</span><br><span class="line">[</span><br><span class="line">    BBBBP  P</span><br><span class="line">    BBBP B P</span><br><span class="line">    BBP BB P</span><br><span class="line">    BP BBB P</span><br><span class="line">    P BBBB P</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_param-&gt;bFrameAdaptive == X265_B_ADAPT_TRELLIS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (numFrames &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> best_paths[X265_BFRAME_MAX + <span class="number">1</span>][X265_LOOKAHEAD_MAX + <span class="number">1</span>] = &#123; <span class="string">&quot;&quot;</span>, <span class="string">&quot;P&quot;</span> &#125;;</span><br><span class="line">        <span class="comment">// numFrames长度对应的路径，numFrames可能大于X265_BFRAME_MAX + 1，best_paths是循环存储的</span></span><br><span class="line">        <span class="type">int</span> best_path_index = numFrames % (X265_BFRAME_MAX + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算2~numFrames长度的帧最优路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= numFrames; j++)</span><br><span class="line">            <span class="built_in">slicetypePath</span>(frames, j, best_paths);</span><br><span class="line"></span><br><span class="line">        numBFrames = (<span class="type">int</span>)<span class="built_in">strspn</span>(best_paths[best_path_index], <span class="string">&quot;B&quot;</span>); <span class="comment">// 统计第一个连续B帧的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据最优路径结果设置帧类型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; numFrames; j++)</span><br><span class="line">            frames[j]-&gt;sliceType = best_paths[best_path_index][j - <span class="number">1</span>] == <span class="string">&#x27;B&#x27;</span> ? X265_TYPE_B : X265_TYPE_P;</span><br><span class="line">    &#125;</span><br><span class="line">    frames[numFrames]-&gt;sliceType = X265_TYPE_P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="X265-B-ADAPT-FAST"><a href="#X265-B-ADAPT-FAST" class="headerlink" title="X265_B_ADAPT_FAST"></a>X265_B_ADAPT_FAST</h5><p>快速决策就是遍历所有帧，每次决策下一帧的帧类型，对于下一帧来说，只有B帧和P帧两种情况。计算当下一帧为B帧时的成本为cost1b1，下下帧的成本为cost2p1；当下一帧为P帧时的成本为cost1p0，下下帧的成本为cost2p0。在快速决策策略下，假设每帧的参考帧都是前后相邻的两帧，只会考虑到前后相邻两帧的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">            <span class="function">CostEstimateGroup <span class="title">estGroup</span><span class="params">(*<span class="keyword">this</span>, frames)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int64_t</span> cost1p0, cost2p0, cost1b1, cost2p1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= numFrames - <span class="number">2</span>; )</span><br><span class="line">            &#123;</span><br><span class="line">                cost2p1 = estGroup.<span class="built_in">singleCost</span>(i + <span class="number">0</span>, i + <span class="number">2</span>, i + <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// i+2作为P帧，参考帧为i</span></span><br><span class="line">                cost1b1 = estGroup.<span class="built_in">singleCost</span>(i + <span class="number">0</span>, i + <span class="number">2</span>, i + <span class="number">1</span>); <span class="comment">// i+1作为B帧，参考帧为i和i+2</span></span><br><span class="line"></span><br><span class="line">                cost1p0 = estGroup.<span class="built_in">singleCost</span>(i + <span class="number">0</span>, i + <span class="number">1</span>, i + <span class="number">1</span>); <span class="comment">// i+1作为P帧，参考帧为i</span></span><br><span class="line">                cost2p0 = estGroup.<span class="built_in">singleCost</span>(i + <span class="number">1</span>, i + <span class="number">2</span>, i + <span class="number">2</span>); <span class="comment">// i+2作为P帧，参考帧为i+1</span></span><br><span class="line">								<span class="comment">// 如果下一帧作为P帧的成本小，则将下一帧设置为P帧</span></span><br><span class="line">                <span class="keyword">if</span> (cost1p0 + cost2p0 &lt; cost1b1 + cost2p1)</span><br><span class="line">                &#123;</span><br><span class="line">                    frames[i + <span class="number">1</span>]-&gt;sliceType = X265_TYPE_P;</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arbitrary and untuned</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTER_THRESH 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P_SENS_BIAS (50 - m_param-&gt;bFrameBias)</span></span><br><span class="line">                frames[i + <span class="number">1</span>]-&gt;sliceType = X265_TYPE_B; <span class="comment">// 否则，将下一帧设置为B帧，参考第i帧</span></span><br><span class="line">				<span class="comment">// 如果下一帧为B帧，则根据bframes，将后续帧尝试设置为B帧</span></span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">2</span>; j &lt;= <span class="built_in">X265_MIN</span>(i + m_param-&gt;bframes, numFrames - <span class="number">1</span>); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int64_t</span> pthresh = <span class="built_in">X265_MAX</span>(INTER_THRESH - P_SENS_BIAS * (j - i - <span class="number">1</span>), INTER_THRESH / <span class="number">10</span>);</span><br><span class="line">                    <span class="type">int64_t</span> pcost = estGroup.<span class="built_in">singleCost</span>(i + <span class="number">0</span>, j + <span class="number">1</span>, j + <span class="number">1</span>, <span class="literal">true</span>); <span class="comment">// 后续每一帧尝试参考第i帧，计算成本</span></span><br><span class="line">                    <span class="keyword">if</span> (pcost &gt; pthresh * cuCount || frames[j + <span class="number">1</span>]-&gt;intraMbs[j - i + <span class="number">1</span>] &gt; cuCount / <span class="number">3</span>) <span class="comment">// 如果该帧的运动矢量中帧内CU数量超过了1/3，则认为该帧不适合作为B帧</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    frames[j]-&gt;sliceType = X265_TYPE_B; </span><br><span class="line">                &#125;</span><br><span class="line">								<span class="comment">// j为连续B帧后的P帧</span></span><br><span class="line">                frames[j]-&gt;sliceType = X265_TYPE_P;</span><br><span class="line">                i = j; <span class="comment">// 从j开始</span></span><br><span class="line">            &#125;</span><br><span class="line">            frames[numFrames]-&gt;sliceType = X265_TYPE_P; <span class="comment">// 确保最后一帧是P帧</span></span><br><span class="line">            numBFrames = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (numBFrames &lt; numFrames &amp;&amp; frames[numBFrames + <span class="number">1</span>]-&gt;sliceType == X265_TYPE_B)</span><br><span class="line">                numBFrames++; <span class="comment">// 统计第一个连续B帧的数量</span></span><br></pre></td></tr></table></figure>

<h5 id="X265-B-ADAPT-NONE"><a href="#X265-B-ADAPT-NONE" class="headerlink" title="X265_B_ADAPT_NONE"></a>X265_B_ADAPT_NONE</h5><p>没有B帧决策策略就是完全根据bframes来，分配固定的连续B帧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">numBFrames = <span class="built_in">X265_MIN</span>(numFrames - <span class="number">1</span>, m_param-&gt;bframes); <span class="comment">// 统计第一个连续B帧的数量</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; numFrames; j++)</span><br><span class="line">    frames[j]-&gt;sliceType = (j % (numBFrames + <span class="number">1</span>)) ? X265_TYPE_B : X265_TYPE_P;</span><br><span class="line"></span><br><span class="line">frames[numFrames]-&gt;sliceType = X265_TYPE_P;</span><br></pre></td></tr></table></figure>



<h3 id="帧类型修正"><a href="#帧类型修正" class="headerlink" title="帧类型修正"></a>帧类型修正</h3><p>根据外部设定的最大连续数量、B参考帧数量、关键帧间隔数量等条件，对帧类型预测的结果进行修正，使结果满足外部设定的条件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> bframes, brefs; <span class="comment">// b帧的数量（包含b参考帧）, b参考帧的数量</span></span><br><span class="line"><span class="keyword">if</span> (!m_param-&gt;analysisLoad || m_param-&gt;bAnalysisType == HEVC_INFO)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 修正帧类型，直到下一个非b帧停止，bframes是循环次数，也是b帧的数量</span></span><br><span class="line">    <span class="keyword">for</span> (bframes = <span class="number">0</span>, brefs = <span class="number">0</span>;; bframes++)</span><br><span class="line">    &#123;</span><br><span class="line">        Lowres&amp; frm = list[bframes]-&gt;m_lowres;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理b参考帧数量超出情况</span></span><br><span class="line">        <span class="keyword">if</span> (frm.sliceType == X265_TYPE_BREF &amp;&amp; !m_param-&gt;bBPyramid &amp;&amp; brefs == m_param-&gt;bBPyramid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前帧是b参考帧，但是b参考帧没有开启或者已经超过了数量，则改为b帧（默认bBPyramid为1，一个连续的b帧中只能出现一次b参考帧）</span></span><br><span class="line">            frm.sliceType = X265_TYPE_B;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (frm.sliceType == X265_TYPE_BREF &amp;&amp; m_param-&gt;bBPyramid &amp;&amp; brefs &amp;&amp;</span><br><span class="line">            m_param-&gt;maxNumReferences &lt;= (brefs + <span class="number">3</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前帧是b参考帧，但是总参考帧数量已经超过了最大值，则改为b帧</span></span><br><span class="line">            frm.sliceType = X265_TYPE_B;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理gop首帧</span></span><br><span class="line">        <span class="keyword">if</span> (((!m_param-&gt;bIntraRefresh || frm.frameNum == <span class="number">0</span>) &amp;&amp; frm.frameNum - m_lastKeyframe &gt;= m_param-&gt;keyframeMax &amp;&amp;</span><br><span class="line">            (!m_extendGopBoundary || frm.frameNum - m_lastKeyframe &gt;= m_param-&gt;keyframeMax + m_param-&gt;gopLookahead)) ||</span><br><span class="line">            (frm.frameNum == (m_param-&gt;chunkStart - <span class="number">1</span>)) || (frm.frameNum == m_param-&gt;chunkEnd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Close GOP首帧为IDR，Open GOP只有第一个GOP的第一帧才是IDR，后面的首帧都是I</span></span><br><span class="line">            <span class="keyword">if</span> (frm.sliceType == X265_TYPE_AUTO || frm.sliceType == X265_TYPE_I)</span><br><span class="line">                frm.sliceType = m_param-&gt;bOpenGOP &amp;&amp; m_lastKeyframe &gt;= <span class="number">0</span> ? X265_TYPE_I : X265_TYPE_IDR;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (frm.bIsFadeEnd)&#123;</span><br><span class="line">            frm.sliceType = m_param-&gt;bOpenGOP &amp;&amp; m_lastKeyframe &gt;= <span class="number">0</span> ? X265_TYPE_I : X265_TYPE_IDR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键帧更新和标记</span></span><br><span class="line">        <span class="keyword">if</span> ((frm.sliceType == X265_TYPE_I &amp;&amp; frm.frameNum - m_lastKeyframe &gt;= m_param-&gt;keyframeMin) || (frm.frameNum == (m_param-&gt;chunkStart - <span class="number">1</span>)) || (frm.frameNum == m_param-&gt;chunkEnd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前帧是I帧，并且当前帧数距离上一个关键帧已经超过了最小关键帧的距离，需要产生新的关键帧</span></span><br><span class="line">            <span class="comment">// OpenGOP下将当前帧标记为关键帧，CloseGOP下将当前帧改为IDR帧</span></span><br><span class="line">            <span class="keyword">if</span> (m_param-&gt;bOpenGOP)</span><br><span class="line">            &#123;</span><br><span class="line">                m_lastKeyframe = frm.frameNum;</span><br><span class="line">                frm.bKeyframe = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                frm.sliceType = X265_TYPE_IDR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前帧是IDR，需要产生新的关键帧</span></span><br><span class="line">        <span class="keyword">if</span> (frm.sliceType == X265_TYPE_IDR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Closed GOP */</span></span><br><span class="line">            m_lastKeyframe = frm.frameNum;</span><br><span class="line">            frm.bKeyframe = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// b帧数量已经满了，或者下一帧为空</span></span><br><span class="line">        <span class="keyword">if</span> (bframes == m_param-&gt;bframes || !list[bframes + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前帧类型没有决策，或者当前帧类型是b帧或者b参考帧，则当前帧为P帧</span></span><br><span class="line">            <span class="comment">// 如果当前帧类型是I帧或者P帧，则不变</span></span><br><span class="line">            <span class="keyword">if</span> (frm.sliceType == X265_TYPE_AUTO || <span class="built_in">IS_X265_TYPE_B</span>(frm.sliceType))</span><br><span class="line">                frm.sliceType = X265_TYPE_P; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (frm.sliceType == X265_TYPE_BREF)</span><br><span class="line">            brefs++; <span class="comment">// b参考帧计数</span></span><br><span class="line">        <span class="keyword">if</span> (frm.sliceType == X265_TYPE_AUTO) <span class="comment">// 帧类型暂定为b帧</span></span><br><span class="line">            frm.sliceType = X265_TYPE_B;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">IS_X265_TYPE_B</span>(frm.sliceType)) <span class="comment">// 当前帧不是b帧也不是b参考帧，则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (bframes = <span class="number">0</span>, brefs = <span class="number">0</span>;; bframes++)</span><br><span class="line">    &#123;</span><br><span class="line">        Lowres&amp; frm = list[bframes]-&gt;m_lowres;</span><br><span class="line">        <span class="keyword">if</span> (frm.sliceType == X265_TYPE_BREF)</span><br><span class="line">            brefs++;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">IS_X265_TYPE_I</span>(frm.sliceType) &amp;&amp; frm.frameNum - m_lastKeyframe &gt;= m_param-&gt;keyframeMin)</span><br><span class="line">            || (frm.frameNum == (m_param-&gt;chunkStart - <span class="number">1</span>)) || (frm.frameNum == m_param-&gt;chunkEnd))</span><br><span class="line">        &#123;</span><br><span class="line">            m_lastKeyframe = frm.frameNum;</span><br><span class="line">            frm.bKeyframe = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IS_X265_TYPE_B</span>(frm.sliceType))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第bframes帧为非B帧，该帧记录前面的B帧数量</span></span><br><span class="line">list[bframes]-&gt;m_lowres.leadingBframes = bframes;</span><br><span class="line"><span class="comment">// 更新最新的非B帧</span></span><br><span class="line">m_lastNonB = &amp;list[bframes]-&gt;m_lowres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_param-&gt;bBPyramid &amp;&amp; bframes &gt; <span class="number">1</span> &amp;&amp; !brefs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果开启B参考帧（B帧），选取中间的b帧为参考B帧，参考B帧前面的b帧的后向参考为参考B帧，参考B帧后面的b帧的前向参考为参考B帧</span></span><br><span class="line">    list[bframes / <span class="number">2</span>]-&gt;m_lowres.sliceType = X265_TYPE_BREF;</span><br><span class="line">    brefs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加入输出队列"><a href="#加入输出队列" class="headerlink" title="加入输出队列"></a>加入输出队列</h3><p>入队顺序为先加入最后的非B帧，再加入B参考帧，最后再加入B帧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    m_inputLock.<span class="built_in">acquire</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集PTS</span></span><br><span class="line">    <span class="type">int64_t</span> pts[X265_BFRAME_MAX + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= bframes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Frame *curFrame;</span><br><span class="line">        curFrame = m_inputQueue.<span class="built_in">popFront</span>();</span><br><span class="line">        pts[i] = curFrame-&gt;m_pts;</span><br><span class="line">        maxSearch--;</span><br><span class="line">    &#125;</span><br><span class="line">    m_inputLock.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">    m_outputLock.<span class="built_in">acquire</span>();</span><br><span class="line">    <span class="comment">/* add non-B to output queue */</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// m_reorderedPts为DTS</span></span><br><span class="line">    list[bframes]-&gt;m_reorderedPts = pts[idx++];</span><br><span class="line">    m_outputQueue.<span class="built_in">pushBack</span>(*list[bframes]); <span class="comment">//先将最后的非B帧入队</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 加入B参考帧</span></span><br><span class="line">    <span class="keyword">if</span> (brefs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bframes; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list[i]-&gt;m_lowres.sliceType == X265_TYPE_BREF)</span><br><span class="line">            &#123;</span><br><span class="line">                list[i]-&gt;m_reorderedPts = pts[idx++];</span><br><span class="line">                m_outputQueue.<span class="built_in">pushBack</span>(*list[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入B帧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bframes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* push all the B frames into output queue except B-ref, which already pushed into output queue */</span></span><br><span class="line">        <span class="keyword">if</span> (list[i]-&gt;m_lowres.sliceType != X265_TYPE_BREF)</span><br><span class="line">        &#123;</span><br><span class="line">            list[i]-&gt;m_reorderedPts = pts[idx++];</span><br><span class="line">            m_outputQueue.<span class="built_in">pushBack</span>(*list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_outputLock.<span class="built_in">release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>x265</tag>
      </tags>
  </entry>
  <entry>
    <title>x265源码分析之码率控制</title>
    <url>/2021/11/17/av/x265%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h1><p>视频编码的目标是尽可能多的节省比特的同时尽量保持视频质量，码率控制是平衡码率和质量的重要工具。</p>
<p>码率控制并不是视频编码框架中具体的一个模块，而是在整个视频编码过程中扮演控制着的角色，一方面接收来自编码器外部的要求（编码缓冲区大小、人为要求的目标输出码率），另一方面分析并处理这些要求，为了完成要求对编码参数做出选择（量化参数、编码模式、运动矢量）。</p>
<p>在整个码率控制过程中，最为重要的三个编码参数是量化参数、编码模式、运动矢量。</p>
<p>在工业实现中一般都是选择量化参数建立率失真模型，将量化参数和编码模式、运动矢量分开，先有码率控制模块确定量化参数，再由RDO（率失真优化）确定编码模式和运动矢量。</p>
<p>所以码率控制就是负责量化参数的确定。</p>
<span id="more"></span>

<h1 id="帧间级码率控制"><a href="#帧间级码率控制" class="headerlink" title="帧间级码率控制"></a>帧间级码率控制</h1><h2 id="ABR、CRF"><a href="#ABR、CRF" class="headerlink" title="ABR、CRF"></a>ABR、CRF</h2><p>帧间级别码率控制需要为每一帧分配QP，也就是分配每一帧的大小，每一帧的大小主要取决于两个变量：本帧的复杂度、码率预算。首先会根据每帧的复杂度，在帧与帧之间分配码率比例，然后根据码率预算，将每帧缩放到合适大小，这个缩放系数称为RateFactor，如果开启了VBV，还会经过VBV模块调整。ABR和CRF模式都是通过调整RateFactor实现。</p>
<h3 id="QScale"><a href="#QScale" class="headerlink" title="QScale"></a>QScale</h3><h4 id="转换qp"><a href="#转换qp" class="headerlink" title="转换qp"></a>转换qp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">x265_qScale2qp</span><span class="params">(<span class="type">double</span> qScale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">12.0</span> + <span class="number">6.0</span> * (<span class="type">double</span>)<span class="built_in">X265_LOG2</span>(qScale / <span class="number">0.85</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">x265_qp2qScale</span><span class="params">(<span class="type">double</span> qp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.85</span> * <span class="built_in">pow</span>(<span class="number">2.0</span>, (qp - <span class="number">12.0</span>) / <span class="number">6.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h3><p>QScale的初始值由当前帧的复杂度计算得出</p>
<h4 id="复杂度SATD"><a href="#复杂度SATD" class="headerlink" title="复杂度SATD"></a>复杂度SATD</h4><p>在帧类型决策时，会对帧进行1&#x2F;2下采样，对下采样后的小图进行预测，并计算SATD值。</p>
<h5 id="帧内预测"><a href="#帧内预测" class="headerlink" title="帧内预测"></a>帧内预测</h5><p>在帧类型决策之前，会对每一帧都会进行预处理。在PreLookaheadGroup中进行下采样，并进行帧内预测，计算SATD值。</p>
<p>下采样后，遍历每个8x8的CU，在35中预测模式下选出最优的SATD值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LookaheadTLD::lowresIntraEstimate</span><span class="params">(Lowres&amp; fenc, <span class="type">uint32_t</span> qgSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cuY = <span class="number">0</span>; cuY &lt; heightInCU; cuY++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> cuX = <span class="number">0</span>; cuX &lt; widthInCU; cuX++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> cuXY = cuX + cuY * widthInCU;</span><br><span class="line">            ...</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/* DC and planar */</span></span><br><span class="line">            primitives.cu[sizeIdx].intra_pred[DC_IDX](prediction, cuSize, samples, <span class="number">0</span>, cuSize &lt;= <span class="number">16</span>);</span><br><span class="line">            cost = <span class="built_in">satd</span>(fencIntra, cuSize, prediction, cuSize);</span><br><span class="line">            <span class="built_in">COPY2_IF_LT</span>(icost, cost, ilowmode, DC_IDX);</span><br><span class="line"></span><br><span class="line">            primitives.cu[sizeIdx].intra_pred[PLANAR_IDX](prediction, cuSize, neighbours[planar], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            cost = <span class="built_in">satd</span>(fencIntra, cuSize, prediction, cuSize);</span><br><span class="line">            <span class="built_in">COPY2_IF_LT</span>(icost, cost, ilowmode, PLANAR_IDX);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* scan angular predictions */</span></span><br><span class="line">            <span class="type">int</span> filter, acost = me.COST_MAX;</span><br><span class="line">            <span class="type">uint32_t</span> mode, alowmode = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (mode = <span class="number">5</span>; mode &lt; <span class="number">35</span>; mode += <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                filter = !!(g_intraFilterFlags[mode] &amp; cuSize);</span><br><span class="line">                primitives.cu[sizeIdx].intra_pred[mode](prediction, cuSize, neighbours[filter], mode, cuSize &lt;= <span class="number">16</span>);</span><br><span class="line">                cost = <span class="built_in">satd</span>(fencIntra, cuSize, prediction, cuSize);</span><br><span class="line">                <span class="built_in">COPY2_IF_LT</span>(acost, cost, alowmode, mode);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fenc.costEst[<span class="number">0</span>][<span class="number">0</span>] = costEst;</span><br><span class="line">    fenc.costEstAq[<span class="number">0</span>][<span class="number">0</span>] = costEstAq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="帧间预测"><a href="#帧间预测" class="headerlink" title="帧间预测"></a>帧间预测</h5><p>在帧类型决策之后，如果当前的码控模式不是CQP，则会在CostEstimateGroup中提前对帧进行成本估计，计算帧的SATD值。</p>
<p>如果是I帧则直接使用帧内预测的SATD值，否则在参考帧中进行运动估计，计算每个8x8CU的运动矢量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">CostEstimateGroup::estimateFrameCost</span><span class="params">(LookaheadTLD&amp; tld, <span class="type">int</span> p0, <span class="type">int</span> p1, <span class="type">int</span> b, <span class="type">bool</span> bIntraPenalty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Lowres*     fenc  = m_frames[b];</span><br><span class="line">    x265_param* param = m_lookahead.m_param;</span><br><span class="line">    <span class="type">int64_t</span>     score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fenc-&gt;costEst[b - p0][p1 - b] &gt;= <span class="number">0</span> &amp;&amp; fenc-&gt;rowSatds[b - p0][p1 - b][<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">        score = fenc-&gt;costEst[b - p0][p1 - b];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Calculate MVs for 1/16th resolution*/</span></span><br><span class="line">            <span class="type">bool</span> lastRow;</span><br><span class="line">            lastRow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> cuY = m_lookahead.m_8x8Height - <span class="number">1</span>; cuY &gt;= <span class="number">0</span>; cuY--)</span><br><span class="line">            &#123;</span><br><span class="line">                fenc-&gt;rowSatds[b - p0][p1 - b][cuY] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> cuX = m_lookahead.m_8x8Width - <span class="number">1</span>; cuX &gt;= <span class="number">0</span>; cuX--)</span><br><span class="line">                    <span class="built_in">estimateCUCost</span>(tld, cuX, cuY, p0, p1, b, bDoSearch, lastRow, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                lastRow = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        score = fenc-&gt;costEst[b - p0][p1 - b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- more -->

<h4 id="模糊复杂度"><a href="#模糊复杂度" class="headerlink" title="模糊复杂度"></a>模糊复杂度</h4><p>模糊复杂度是基于邻近已编码帧的复杂度加权平均得到，避免QP波动。</p>
<p>m_shortTermCplxSum 当前非B帧及以前所有非B帧 satd * (fps&#x2F;25)的和，fps越大，权重越大<br>    Sum[i] &#x3D; Sum[i - 1] * 0.5 + satd * (fps &#x2F; 25)</p>
<p>m_shortTermCplxCount 当前帧以前非B帧个数 + 1<br>    Count[i] &#x3D; Count[i - 1] * 0.5 + 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_shortTermCplxSum *= <span class="number">0.5</span>;</span><br><span class="line">m_shortTermCplxCount *= <span class="number">0.5</span>;</span><br><span class="line">m_shortTermCplxSum += m_currentSatd / (<span class="built_in">CLIP_DURATION</span>(m_frameDuration) / BASE_FRAME_DURATION);</span><br><span class="line">m_shortTermCplxCount++;</span><br><span class="line"><span class="comment">/* coeffBits to be used in 2-pass */</span></span><br><span class="line">rce-&gt;coeffBits = (<span class="type">int</span>)m_currentSatd;</span><br><span class="line">rce-&gt;blurredComplexity = m_shortTermCplxSum / m_shortTermCplxCount;</span><br></pre></td></tr></table></figure>

<h4 id="感知编码优化"><a href="#感知编码优化" class="headerlink" title="感知编码优化"></a>感知编码优化</h4><p>对于复杂度高的场景，细节丢失比较难以发现，因此可以使用比较高的QP，可以对帧的复杂度进行压缩。qcomp是由外部控制的参数。</p>
<p>rceq &#x3D; BlurCplx^(1 - qcomp);</p>
<ul>
<li>当qcomp &#x3D; 1，各帧的rceq都一样，分配给平缓帧和复杂度的比特都一样；</li>
<li>当qcomp &#x3D; 0，相当于关闭了感知编码优化；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_param-&gt;rc.cuTree &amp;&amp; !m_param-&gt;rc.hevcAq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Scale and units are obtained from rateNum and rateDenom for videos with fixed frame rates.</span></span><br><span class="line">    <span class="type">double</span> timescale = (<span class="type">double</span>)m_param-&gt;fpsDenom / (<span class="number">2</span> * m_param-&gt;fpsNum);</span><br><span class="line">    q = <span class="built_in">pow</span>(BASE_FRAME_DURATION / <span class="built_in">CLIP_DURATION</span>(<span class="number">2</span> * timescale), <span class="number">1</span> - m_param-&gt;rc.qCompress);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    q = <span class="built_in">pow</span>(rce-&gt;blurredComplexity, <span class="number">1</span> - m_param-&gt;rc.qCompress);</span><br></pre></td></tr></table></figure>

<h3 id="RateFactor修正"><a href="#RateFactor修正" class="headerlink" title="RateFactor修正"></a>RateFactor修正</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QScale = rceq / RateFactor;</span><br></pre></td></tr></table></figure>

<h4 id="CRF"><a href="#CRF" class="headerlink" title="CRF"></a>CRF</h4><p>CRF（Constant RateFactor），可以保持整个视频流质量恒定。CRF接受一个固定的QP值，取值为0-51之间的整数，x265默认值时28，CRF增减6会导致码率减半或加倍。在CRF模式下，RateFactor是固定的，QScale是由每帧的复杂度决定。</p>
<h5 id="首帧"><a href="#首帧" class="headerlink" title="首帧"></a>首帧</h5><p>在CRF模式下，首帧的QScale由CRF接受的QP值来决定，外部指定的QP都是P帧的QP，对于I帧需要作用ipFactor。ipFactor是I帧与P帧QP的偏移系数，pbFactor是P帧和B帧QP的偏移系数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRF_INIT_QP (int)m_param-&gt;rc.rfConstant</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_qCompress != <span class="number">1</span> &amp;&amp; m_param-&gt;rc.rateControlMode == X265_RC_CRF)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="built_in">x265_qp2qScale</span>(CRF_INIT_QP) / <span class="built_in">fabs</span>(m_param-&gt;rc.ipFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="I帧、P帧"><a href="#I帧、P帧" class="headerlink" title="I帧、P帧"></a>I帧、P帧</h5><p>m_rateFactorConstant根据外部指定的QP来计算出来的固定RateFactor，除了首帧外，所有的非B帧都是使用该系数来压缩复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_param-&gt;rc.rateControlMode == X265_RC_CRF)</span><br><span class="line">&#123;</span><br><span class="line">    q = <span class="built_in">getQScale</span>(rce, m_rateFactorConstant);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>m_rateFactorConstant &#x3D; rceq &#x2F; QScale<br>m_rateFactorConstant根据公式反算回来，其中QScale为外部指定的QP，rceq为8x8CU个数 * 120。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> lowresCuWidth = ((m_param-&gt;sourceWidth / <span class="number">2</span>) + X265_LOWRES_CU_SIZE - <span class="number">1</span>) &gt;&gt; X265_LOWRES_CU_BITS;</span><br><span class="line"><span class="type">int</span> lowresCuHeight = ((m_param-&gt;sourceHeight / <span class="number">2</span>) + X265_LOWRES_CU_SIZE - <span class="number">1</span>) &gt;&gt; X265_LOWRES_CU_BITS;</span><br><span class="line">m_ncu = lowresCuWidth * lowresCuHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_param-&gt;rc.rateControlMode == X265_RC_CRF)</span><br><span class="line">&#123;</span><br><span class="line">    m_param-&gt;rc.qp = (<span class="type">int</span>)m_param-&gt;rc.rfConstant;</span><br><span class="line">    m_param-&gt;rc.bitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> baseCplx = m_ncu * (m_param-&gt;bframes ? <span class="number">120</span> : <span class="number">80</span>);</span><br><span class="line">    <span class="type">double</span> mbtree_offset = m_param-&gt;rc.cuTree ? (<span class="number">1.0</span> - m_param-&gt;rc.qCompress) * <span class="number">13.5</span> : <span class="number">0</span>;</span><br><span class="line">    m_rateFactorConstant = <span class="built_in">pow</span>(baseCplx, <span class="number">1</span> - m_qCompress) / <span class="built_in">x265_qp2qScale</span>(m_param-&gt;rc.rfConstant + mbtree_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="B帧"><a href="#B帧" class="headerlink" title="B帧"></a>B帧</h5><p>B帧是没有独立码控的，B帧的QP是由参考帧的QP来决定。</p>
<ul>
<li>前向参考帧和后向参考帧都是I帧，QP &#x3D; 平均QP值</li>
<li>前向参考帧为I帧，QP &#x3D; 后向参考帧</li>
<li>后向参考帧为I帧，QP &#x3D; 前向参考帧</li>
<li>都不是I帧，QP &#x3D; 按POC距离加权的平均QP值<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_sliceType == B_SLICE)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">/* B-frames don&#x27;t have independent rate control, but rather get the</span></span><br><span class="line"><span class="comment">      * average QP of the two adjacent P-frames + an offset */</span></span><br><span class="line">     Slice* prevRefSlice = m_curSlice-&gt;m_refFrameList[<span class="number">0</span>][<span class="number">0</span>]-&gt;m_encData-&gt;m_slice;</span><br><span class="line">     Slice* nextRefSlice = m_curSlice-&gt;m_refFrameList[<span class="number">1</span>][<span class="number">0</span>]-&gt;m_encData-&gt;m_slice;</span><br><span class="line">     <span class="type">double</span> q0 = m_curSlice-&gt;m_refFrameList[<span class="number">0</span>][<span class="number">0</span>]-&gt;m_encData-&gt;m_avgQpRc;</span><br><span class="line">     <span class="type">double</span> q1 = m_curSlice-&gt;m_refFrameList[<span class="number">1</span>][<span class="number">0</span>]-&gt;m_encData-&gt;m_avgQpRc;</span><br><span class="line">     <span class="type">bool</span> i0 = prevRefSlice-&gt;m_sliceType == I_SLICE;</span><br><span class="line">     <span class="type">bool</span> i1 = nextRefSlice-&gt;m_sliceType == I_SLICE;</span><br><span class="line">     <span class="type">int</span> dt0 = <span class="built_in">abs</span>(m_curSlice-&gt;m_poc - prevRefSlice-&gt;m_poc);</span><br><span class="line">     <span class="type">int</span> dt1 = <span class="built_in">abs</span>(m_curSlice-&gt;m_poc - nextRefSlice-&gt;m_poc);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (i0 &amp;&amp; i1)</span><br><span class="line">         q = (q0 + q1) / <span class="number">2</span> + m_ipOffset;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (i0)</span><br><span class="line">         q = q1;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (i1)</span><br><span class="line">         q = q0;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         q = (q0 * dt1 + q1 * dt0) / (dt0 + dt1);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">IS_REFERENCED</span>(curFrame))</span><br><span class="line">         q += m_pbOffset / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         q += m_pbOffset;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ABR"><a href="#ABR" class="headerlink" title="ABR"></a>ABR</h4><p>平均比特率（Average Bitrate），给定一个目标码率，编码器计算如何达到这个码率。但是由于编码器在编码当前帧时是不知道后面还未编码的内容，所以它不得不猜测如何达到给定码率，这意味着码率要一直变化，因此ABR不是一种恒定码率模式而是可变码率模式。在ABR模式下，就是通过不断调整RateFactor来实现的平均码率控制。</p>
<h5 id="I帧、P帧-1"><a href="#I帧、P帧-1" class="headerlink" title="I帧、P帧"></a>I帧、P帧</h5><p>在ABR模式下，RateFactor &#x3D; wanted_bits_window &#x2F; complexity_sum，其中wanted_bits_window表示已编码帧的目标文件大小，complexity_sum是系数。</p>
<p>wanted_bits_window是(bitrate &#x2F; fps)的累积值，bitrate是外部指定的平均比特率，bitrate &#x2F; fps表示平均一帧的比特率，所以wanted_bits_window表示累积的期望比特大小。<br>complexity_sum是(bits * qscale &#x2F; rceq)的累积值，bits表示实际编码得到的帧大小</p>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_cplxrSum = <span class="number">.01</span> * <span class="built_in">pow</span>(<span class="number">7.0e5</span>, m_qCompress) * <span class="built_in">pow</span>(m_ncu, <span class="number">0.5</span>) * tuneCplxFactor;</span><br><span class="line">m_wantedBitsWindow = m_bitrate * m_frameDuration;</span><br></pre></td></tr></table></figure>

<p>当前帧编码结束后，更新</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rce-&gt;sliceType != B_SLICE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The factor 1.5 is to tune up the actual bits, otherwise the cplxrSum is scaled too low</span></span><br><span class="line"><span class="comment">        * to improve short term compensation for next frame. */</span></span><br><span class="line">    m_cplxrSum += (bits * <span class="built_in">x265_qp2qScale</span>(rce-&gt;qpaRc) / rce-&gt;qRceq) - (rce-&gt;rowCplxrSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Depends on the fact that B-frame&#x27;s QP is an offset from the following P-frame&#x27;s.</span></span><br><span class="line"><span class="comment">        * Not perfectly accurate with B-refs, but good enough. */</span></span><br><span class="line">    m_cplxrSum += (bits * <span class="built_in">x265_qp2qScale</span>(rce-&gt;qpaRc) / (rce-&gt;qRceq * <span class="built_in">fabs</span>(m_param-&gt;rc.pbFactor))) - (rce-&gt;rowCplxrSum);</span><br><span class="line">&#125;</span><br><span class="line">m_wantedBitsWindow += m_frameDuration * m_bitrate;</span><br></pre></td></tr></table></figure>

<p>计算QScale</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> initialQScale = <span class="built_in">getQScale</span>(rce, m_wantedBitsWindow / m_cplxrSum);</span><br><span class="line">q = initialQScale;</span><br></pre></td></tr></table></figure>

<p>在ABR模式下，首帧的QP不能超过37。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABR_INIT_QP_MAX (37)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_framesDone == <span class="number">0</span> &amp;&amp; !m_isVbv &amp;&amp; m_param-&gt;rc.rateControlMode == X265_RC_ABR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* for ABR alone, clip the first I frame qp */</span></span><br><span class="line">    lqmax = (m_isGrainEnabled &amp;&amp; m_lstep) ? <span class="built_in">x265_qp2qScale</span>(ABR_INIT_QP_GRAIN_MAX) :</span><br><span class="line">                    <span class="built_in">x265_qp2qScale</span>(ABR_INIT_QP_MAX);</span><br><span class="line">    q = <span class="built_in">X265_MIN</span>(lqmax, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="B帧-1"><a href="#B帧-1" class="headerlink" title="B帧"></a>B帧</h5><p>同CRF</p>
<h3 id="VBV修正"><a href="#VBV修正" class="headerlink" title="VBV修正"></a>VBV修正</h3><h4 id="VBV"><a href="#VBV" class="headerlink" title="VBV"></a>VBV</h4><p>vbv模型假想编码码率通过一个容量受限的信道传输到解码设备，解码设备在解码前有一个缓存，解码器实时从缓存区取数据解码，vbv必须保证缓存区不上溢也不下溢。</p>
<p>解码器的缓存可以理解成一个水池，如下图所示，水池的输入速度是恒定的，也就是设定的码率，水池的输出是不恒定的，就是视频的实际瞬时码率。</p>
<p><img src="/2021/11/17/av/x265%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6/151546001_3_20190108085209443.jpg" alt="vbv model"></p>
<p>缓存区的存在使得视频的瞬时码率可以在一定范围内波动，但是如果视频实际瞬时码率过大，从缓存区取数据的速度就会大于填数据的速度，这时缓存区有可能就被取空了，这叫做缓冲区的下溢。相反，如果视频实际瞬时码率过小，从缓存区取数据的速度就会小于填数据的速度，这时缓存区有可能就会溢出，这叫做缓存区的上溢。</p>
<p>参数设置：<br>    –vbv-maxrate：设置缓存区最大填入速度（非CBR模式下，实际码率可以小于最大码率）<br>    –vbv-bufsize：设置缓存区大小<br>    –vbv-init：缓冲区初始充盈度，默认0.9<br>    –min-vbv-fullness：缓冲区最小充盈度，默认50<br>    –max-vbv-fullness：缓冲区最大充盈度，默认80</p>
<p>vbv能容忍的最大码率波动和缓存区的大小，以及缓存区初始充盈程度有关。<br>假如：设置maxrate&#x3D;1M，bufsize &#x3D; 2M，缓存区初始是充盈的，假设某时峰值率是2M，那么能容忍的峰值的最大长度为2&#x2F;(2-1) &#x3D; 2s；<br>假如：某时峰值率是3M，那么能容忍的峰值的最大长度为2&#x2F;(3-1) &#x3D; 1s；</p>
<p>获取速度：当前帧的预测大小<br>填入速度：vbv-maxrate &#x2F; fps</p>
<p>CQP模式下<br>    无VBV<br>ABR模式下<br>    vbvBufferSize 必须设置<br>    vbvMaxBitrate &#x3D;&#x3D; 0 ? vbvMaxBitrate &#x3D; bitrate<br>    vbvMaxBitrate &lt; bitrate ? bitrate &#x3D; vbvMaxBitrate<br>    也就是在ABR模式下，vbvMaxBitrate必须&gt;&#x3D;bitrate</p>
<p>CRF模式下<br>    vbvBufferSize 必须设置<br>    vbvMaxBitrate 必须设置</p>
<h4 id="预测大小"><a href="#预测大小" class="headerlink" title="预测大小"></a>预测大小</h4><p>帧类型预测器，有四种类型小B帧、P帧、I帧、大B帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p是当前预测类型对应的预测器，q是当前帧的QScale，var是当前帧的SATD值。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">RateControl::predictSize</span><span class="params">(Predictor *p, <span class="type">double</span> q, <span class="type">double</span> var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;coeff * var + p-&gt;offset) / (q * p-&gt;count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一帧编码结束后，会根据实际编码的码率来调整对应类型的预测器，使得下一次同类型帧的预测更加准确。<br>(((bits * q) &#x2F; var) * var) &#x2F; q</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var是当前帧的SATD值，bits是当前帧最终编码的大小。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RateControl::updatePredictor</span><span class="params">(Predictor *p, <span class="type">double</span> q, <span class="type">double</span> var, <span class="type">double</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var &lt; <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> range = <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> old_coeff = p-&gt;coeff / p-&gt;count;</span><br><span class="line">    <span class="type">double</span> old_offset = p-&gt;offset / p-&gt;count;</span><br><span class="line">    <span class="type">double</span> new_coeff = <span class="built_in">X265_MAX</span>((bits * q - old_offset) / var, p-&gt;coeffMin );</span><br><span class="line">    <span class="type">double</span> new_coeff_clipped = <span class="built_in">x265_clip3</span>(old_coeff / range, old_coeff * range, new_coeff);</span><br><span class="line">    <span class="type">double</span> new_offset = bits * q - new_coeff_clipped * var;</span><br><span class="line">    <span class="keyword">if</span> (new_offset &gt;= <span class="number">0</span>)</span><br><span class="line">        new_coeff = new_coeff_clipped;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_offset = <span class="number">0</span>;</span><br><span class="line">    p-&gt;count  *= p-&gt;decay;</span><br><span class="line">    p-&gt;coeff  *= p-&gt;decay;</span><br><span class="line">    p-&gt;offset *= p-&gt;decay;</span><br><span class="line">    p-&gt;count++;</span><br><span class="line">    p-&gt;coeff  += new_coeff;</span><br><span class="line">    p-&gt;offset += new_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h4><p>预测当前帧以及后续帧的predictSize，模拟VBV的获取和填充，根据VBV剩余的充盈度来调整当前帧的QP，使得VBV充盈度保持在固定的范围内，当缓冲区保持在固定的水平，则说明输入和输出大致持平，也就是输出的实际码率和期望的码率相持平。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">RateControl::clipQscale</span><span class="params">(Frame* curFrame, RateControlEntry* rce, <span class="type">double</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_isVbv &amp;&amp; m_currentSatd &gt; <span class="number">0</span> &amp;&amp; curFrame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_param-&gt;lookaheadDepth || m_param-&gt;rc.cuTree ||</span><br><span class="line">            (m_param-&gt;scenecutThreshold || m_param-&gt;bHistBasedSceneCut) ||</span><br><span class="line">            (m_param-&gt;bFrameAdaptive &amp;&amp; m_param-&gt;bframes))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> loopTerminate = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* Avoid an infinite loop. */</span></span><br><span class="line">            <span class="comment">// 轮询调整QP，退出轮询有三种情况</span></span><br><span class="line">            <span class="comment">//      1. 使用当前QP进行模拟后，VBV充盈度在合理范围内</span></span><br><span class="line">            <span class="comment">//      2. 当前QP经过了上调又经过了下调，说明调整QP依旧无法使得VBV充盈度在合理范围内，继续下去只会浪费</span></span><br><span class="line">            <span class="comment">//      3. 轮询1000次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> iterations = <span class="number">0</span>; iterations &lt; <span class="number">1000</span> &amp;&amp; loopTerminate != <span class="number">3</span>; iterations++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">double</span> frameQ[<span class="number">3</span>];</span><br><span class="line">                <span class="type">double</span> curBits;</span><br><span class="line">                <span class="comment">// 预测当前帧的大小</span></span><br><span class="line">                curBits = <span class="built_in">predictSize</span>(&amp;m_pred[m_predType], q, (<span class="type">double</span>)m_currentSatd);</span><br><span class="line">                <span class="comment">// m_bufferFill是当前VBV的充盈度，这里是VBV中获取当前帧大小的buffer</span></span><br><span class="line">                <span class="type">double</span> bufferFillCur = m_bufferFill - curBits;</span><br><span class="line">                <span class="type">double</span> targetFill;</span><br><span class="line">                <span class="type">double</span> totalDuration = m_frameDuration;</span><br><span class="line">                <span class="comment">// 后续帧由于没有开始编码，没有QP，使用当前帧的QP进行预测</span></span><br><span class="line">                frameQ[P_SLICE] = m_sliceType == I_SLICE ? q * m_param-&gt;rc.ipFactor : (m_sliceType == B_SLICE ? q / m_param-&gt;rc.pbFactor : q);</span><br><span class="line">                frameQ[B_SLICE] = frameQ[P_SLICE] * m_param-&gt;rc.pbFactor;</span><br><span class="line">                frameQ[I_SLICE] = frameQ[P_SLICE] / m_param-&gt;rc.ipFactor;</span><br><span class="line">                <span class="comment">/* Loop over the planned future frames. */</span></span><br><span class="line">                <span class="type">bool</span> iter = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 模拟后续1秒内所有帧的获取和填充</span></span><br><span class="line">                <span class="comment">// 退出模拟有三种情况</span></span><br><span class="line">                <span class="comment">//      1. VBV的充盈度小于0，发生了下溢</span></span><br><span class="line">                <span class="comment">//      2. 已经预测了一秒内所有帧</span></span><br><span class="line">                <span class="comment">//      3. 后续帧类型还没有预测</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; bufferFillCur &gt;= <span class="number">0</span> &amp;&amp; iter ; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> type = curFrame-&gt;m_lowres.plannedType[j];</span><br><span class="line">                    <span class="keyword">if</span> (type == X265_TYPE_AUTO || totalDuration &gt;= <span class="number">1.0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 时间累加    </span></span><br><span class="line">                    totalDuration += m_frameDuration;</span><br><span class="line">                    <span class="comment">// 填入速度</span></span><br><span class="line">                    <span class="type">double</span> wantedFrameSize = m_vbvMaxRate * m_frameDuration;</span><br><span class="line">                    <span class="comment">// 没有上溢，填入</span></span><br><span class="line">                    <span class="keyword">if</span> (bufferFillCur + wantedFrameSize &lt;= m_bufferSize)</span><br><span class="line">                        bufferFillCur += wantedFrameSize;</span><br><span class="line">                    <span class="comment">// 获取下一帧SATD    </span></span><br><span class="line">                    <span class="type">int64_t</span> satd = curFrame-&gt;m_lowres.plannedSatd[j] &gt;&gt; (X265_DEPTH - <span class="number">8</span>);</span><br><span class="line">                    type = <span class="built_in">IS_X265_TYPE_I</span>(type) ? I_SLICE : <span class="built_in">IS_X265_TYPE_B</span>(type) ? B_SLICE : P_SLICE;</span><br><span class="line">                    <span class="type">int</span> predType = <span class="built_in">getPredictorType</span>(curFrame-&gt;m_lowres.plannedType[j], type);</span><br><span class="line">                    <span class="comment">// 预测下一帧大小</span></span><br><span class="line">                    curBits = <span class="built_in">predictSize</span>(&amp;m_pred[predType], frameQ[type], (<span class="type">double</span>)satd);</span><br><span class="line">                    <span class="comment">// 从VBV中获取</span></span><br><span class="line">                    bufferFillCur -= curBits;</span><br><span class="line">                    <span class="keyword">if</span> (!m_param-&gt;bResetZoneConfig &amp;&amp; ((<span class="type">uint64_t</span>)j == (m_param-&gt;reconfigWindowSize - <span class="number">1</span>)))</span><br><span class="line">                        iter = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Try to get the buffer at least 50% filled, but don&#x27;t set an impossible goal. */</span></span><br><span class="line">                    <span class="type">double</span> finalDur = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (m_param-&gt;rc.bStrictCbr)</span><br><span class="line">                    &#123;</span><br><span class="line">                        finalDur = <span class="built_in">x265_clip3</span>(<span class="number">0.4</span>, <span class="number">1.0</span>, totalDuration);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// m_bufferSize * (1 - m_minBufferFill * finalDur) 是外部设置的最小充盈度</span></span><br><span class="line">                    targetFill = <span class="built_in">X265_MIN</span>(m_bufferFill + totalDuration * m_vbvMaxRate * <span class="number">0.5</span>, m_bufferSize * (<span class="number">1</span> - m_minBufferFill * finalDur));</span><br><span class="line">                    <span class="keyword">if</span> (bufferFillCur &lt; targetFill)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 充盈度小于最小充盈度时，说明predictSize过大，需要提高QP</span></span><br><span class="line">                        q *= <span class="number">1.01</span>;</span><br><span class="line">                        loopTerminate |= <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/* Try to get the buffer not more than 80% filled, but don&#x27;t set an impossible goal. */</span></span><br><span class="line">                    <span class="comment">// m_bufferSize * (1 - m_maxBufferFill * finalDur) 是外部设置的最大充盈度</span></span><br><span class="line">                    targetFill = <span class="built_in">x265_clip3</span>(m_bufferSize * (<span class="number">1</span> - m_maxBufferFill * finalDur), m_bufferSize, m_bufferFill - totalDuration * m_vbvMaxRate * <span class="number">0.5</span>);</span><br><span class="line">                    <span class="comment">// 非CBR模式下，实际码率可以小于最大码率</span></span><br><span class="line">                    <span class="keyword">if</span> ((m_isCbr || m_2pass) &amp;&amp; bufferFillCur &gt; targetFill &amp;&amp; !m_isSceneTransition)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 充盈度大于最大充盈度，说明predictSize过小，需要减小QP</span></span><br><span class="line">                        q /= <span class="number">1.01</span>;</span><br><span class="line">                        loopTerminate |= <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q = <span class="built_in">X265_MAX</span>(q0 / <span class="number">2</span>, q);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">x265_clip3</span>(lmin, lmax, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CBR"><a href="#CBR" class="headerlink" title="CBR"></a>CBR</h4><p>在ABR+VBV模式下，并且bitrate&#x3D;&#x3D;vbvMaxBitrate，开启CBR模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当bitrate == MaxBitrate时，开启cbr；</span></span><br><span class="line">m_isCbr = m_param-&gt;rc.rateControlMode == X265_RC_ABR &amp;&amp; m_isVbv &amp;&amp; m_param-&gt;rc.vbvMaxBitrate &lt;= m_param-&gt;rc.bitrate;</span><br></pre></td></tr></table></figure>

<p>开启CBR后，再VBV修正时，才会将码率控制在指定码率上，码率不足会降低QP</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CBR模式下，降低QP，提高码率到指定码率</span></span><br><span class="line"><span class="keyword">if</span> ((m_isCbr || m_2pass) &amp;&amp; bufferFillCur &gt; targetFill &amp;&amp; !m_isSceneTransition)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 充盈度大于最大充盈度，说明predictSize过小，需要减小QP</span></span><br><span class="line">    q /= <span class="number">1.01</span>;</span><br><span class="line">    loopTerminate |= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="StrictCbr"><a href="#StrictCbr" class="headerlink" title="StrictCbr"></a>StrictCbr</h5><p>只有在CBR模式下，才能开启严格CBR模式，开启StrictCbr模式后，当VBV上溢时，会将溢出的部分取出，填入oxff数据到编码数据中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RateControl::updateVbv</span><span class="params">(<span class="type">int64_t</span> bits, RateControlEntry* rce)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> predType = rce-&gt;sliceType;</span><br><span class="line">    <span class="type">int</span> filler = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> bufferBits;</span><br><span class="line"></span><br><span class="line">    m_bufferFillFinal -= bits;</span><br><span class="line">    m_bufferFillFinal = <span class="built_in">X265_MAX</span>(m_bufferFillFinal, <span class="number">0</span>);</span><br><span class="line">    m_bufferFillFinal += rce-&gt;bufferRate;</span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;csvLogLevel &gt;= <span class="number">2</span>)</span><br><span class="line">        m_unclippedBufferFillFinal = m_bufferFillFinal;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_param-&gt;rc.bStrictCbr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 当缓冲区充盈度超过了缓冲区大小，发生上溢</span></span><br><span class="line">        <span class="keyword">if</span> (m_bufferFillFinal &gt; m_bufferSize)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 取出上溢的部分</span></span><br><span class="line">            filler = (<span class="type">int</span>)(m_bufferFillFinal - m_bufferSize);</span><br><span class="line">            filler += FILLER_OVERHEAD * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 消除溢出</span></span><br><span class="line">        m_bufferFillFinal -= filler;</span><br><span class="line">        bufferBits = <span class="built_in">X265_MIN</span>(bits + filler + m_bufferExcess, rce-&gt;bufferRate);</span><br><span class="line">        m_bufferExcess = <span class="built_in">X265_MAX</span>(m_bufferExcess - bufferBits + bits + filler, <span class="number">0</span>);</span><br><span class="line">        m_bufferFillActual += bufferBits - bits - filler;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> filler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (filler &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    filler = (filler - FILLER_OVERHEAD * <span class="number">8</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    m_bs.<span class="built_in">resetBits</span>();</span><br><span class="line">    <span class="comment">// 向编码数据流中写入0xff，强行增加NALU的大小，解码器会忽略这些数据</span></span><br><span class="line">    <span class="keyword">while</span> (filler &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_bs.<span class="built_in">write</span>(<span class="number">0xff</span>, <span class="number">8</span>);</span><br><span class="line">        filler--;</span><br><span class="line">    &#125;</span><br><span class="line">    m_bs.<span class="built_in">writeByteAlignment</span>();</span><br><span class="line">    m_nalList.<span class="built_in">serialize</span>(NAL_UNIT_FILLER_DATA, m_bs);</span><br><span class="line">    bytes += m_nalList.m_nal[m_nalList.m_numNal - <span class="number">1</span>].sizeBytes;</span><br><span class="line">    bytes -= <span class="number">3</span>; <span class="comment">//exclude start code prefix</span></span><br><span class="line">    m_accessUnitBits = bytes &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="CQP"><a href="#CQP" class="headerlink" title="CQP"></a>CQP</h2><p>固定QP（Constant QP），量化参数控制着压缩的大小，QP越大压缩率越高同时质量越低，QP越小压缩率越低同时质量越高，在H.265中QP的范围是0-51之间的整数，采用CQP模式会导致根据场景复杂度不同比特率波动很大，无法控制实际比特率。CQP模式下没有VBV。</p>
<p>在无损模式下，P帧、I帧、B帧的QP都是一样的，在非无损模式下，外部设置的是P帧的QP，I帧和B帧会根据偏移系数进行偏移。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_qp = m_param-&gt;rc.qp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_param-&gt;rc.rateControlMode == X265_RC_CQP)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_qp &amp;&amp; !m_param-&gt;bLossless)</span><br><span class="line">    &#123;</span><br><span class="line">        m_qpConstant[P_SLICE] = m_qp;</span><br><span class="line">        m_qpConstant[I_SLICE] = <span class="built_in">x265_clip3</span>(QP_MIN, QP_MAX_MAX, (<span class="type">int</span>)(m_qp - m_ipOffset + <span class="number">0.5</span>));</span><br><span class="line">        m_qpConstant[B_SLICE] = <span class="built_in">x265_clip3</span>(QP_MIN, QP_MAX_MAX, (<span class="type">int</span>)(m_qp + m_pbOffset + <span class="number">0.5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_qpConstant[P_SLICE] = m_qpConstant[I_SLICE] = m_qpConstant[B_SLICE] = m_qp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于大B帧，其QP是B帧和P帧的平均值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_sliceType == B_SLICE &amp;&amp; <span class="built_in">IS_REFERENCED</span>(curFrame))</span><br><span class="line">    m_qp = (m_qpConstant[B_SLICE] + m_qpConstant[P_SLICE]) / <span class="number">2</span>; <span class="comment">// Bref</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    m_qp = m_qpConstant[m_sliceType]; <span class="comment">// I/B/P</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>x265</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用JNI</title>
    <url>/2020/05/28/av/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JNI/</url>
    <content><![CDATA[<h1 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h1><p>JNI是Java与C&#x2F;C++连接的桥梁，是通过动态库的动态装载机制来实现的。（在前面将静态库和动态库的时候，讲过动态库的动态装载）<br>对于动态装载涉及到两个核心的函数：</p>
<ul>
<li>dlopen(): 打开一个动态库，并创建一个引用该动态库的句柄</li>
<li>dlsym(): 根据动态库的句柄以及函数符号，返回该符号对应函数的地址，从而可以执行该函数</li>
</ul>
<p>在Java中一般通过System类的loadLibrary函数来加载一个动态库，该函数底层就是通过调用dlopen函数来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.loadLibrary(libraryName);</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="JNI函数注册"><a href="#JNI函数注册" class="headerlink" title="JNI函数注册"></a>JNI函数注册</h2><p>注册JNI方法有两种方式，一种是静态注册，一种是动态注册。</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>因为JNI允许我们提供一个函数映射表(native函数和jni函数对应表)。而在执行System.loadLibrary加载so库时，会执行该so的JNI_OnLoad函数，利用这个时机可以动态注册JIN方法。具体实现的话是通过JNINativeMethod结构保存映射关系，然后通过RegisterNatives函数来将该映射关系注册。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义映射关系</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;native_init&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">     (<span class="type">void</span> *)com_zhenyu_martlet_MartletFormatEngine_native_init&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;native_setup&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;)V&quot;</span>,</span><br><span class="line">     (<span class="type">void</span> *)com_zhenyu_martlet_MartletFormatEngine_native_setup&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;native_demuxer&quot;</span>,</span><br><span class="line">     <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)J&quot;</span>,</span><br><span class="line">     (<span class="type">void</span> *)com_zhenyu_martlet_MartletFormatEngine_native_demuxer&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;native_muxer&quot;</span>,</span><br><span class="line">     <span class="string">&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)J&quot;</span>,</span><br><span class="line">     (<span class="type">void</span> *)com_zhenyu_martlet_MartletFormatEngine_native_muxer&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;native_release&quot;</span>, <span class="string">&quot;()V&quot;</span>,</span><br><span class="line">     (<span class="type">void</span> *)com_zhenyu_martlet_MartletFormatEngine_native_release&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">jint <span class="title">register_com_zhenyu_martlet_MartletFormatEngine</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">  jclass clazz;</span><br><span class="line">  <span class="comment">// 找到native函数所在的类</span></span><br><span class="line">  clazz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;com/zhenyu/martlet/format/MartletFormatEngine&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> numMethods = (<span class="built_in">sizeof</span>(gMethods) / <span class="built_in">sizeof</span>((gMethods)[<span class="number">0</span>]));</span><br><span class="line">  <span class="comment">// 注册映射关系</span></span><br><span class="line">  <span class="keyword">if</span> (env-&gt;<span class="built_in">RegisterNatives</span>(clazz, gMethods, numMethods) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    env-&gt;<span class="built_in">DeleteLocalRef</span>(clazz);</span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">  &#125;</span><br><span class="line">  env-&gt;<span class="built_in">DeleteLocalRef</span>(clazz);</span><br><span class="line">  <span class="keyword">return</span> JNI_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>如果没有在JNI_OnLoad中将JNI方法注册(将方法在进程中的地址增加到ClassObject-&gt;directMethods中)，则在调用的时候解析javah风格的函数(比如Java_com_example_hellojni_HelloJni_stringFromJNI)，进行静态注册。静态注册根据函数名来建立java方法和jni函数的对应关系。静态注册需要根据方法名本地搜索，比较耗时。</p>
<h2 id="JNI线程"><a href="#JNI线程" class="headerlink" title="JNI线程"></a>JNI线程</h2><p>对于JNI来说，有两个比较重要的对象，一个是JavaVM，另一个是JNIEnv。其中JavaVM代表着JVM虚拟机，一个进程只有一个，可以通过JNI_OnLoad函数获取。而JNIEnv封装了JNI提供的所有API，是JNI执行的环境，一个线程只能有一个。</p>
<p>对于Java层的每一次JNI调用，都会通过JavaVM在当前线程中创建一个JNIEnv，当JNI调用执行完成时，会通过JavaVM销毁当前线程中的JNIEnv。</p>
<p>所以对于C++中手动创建的线程，默认是无法调用JNI方法的，需要通过JavaVM的AttachCurrentThread函数为当前线程创建一个JNIEnv后，才可以调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNIHelper::attachThreadJNIEnv</span><span class="params">(JNIEnv **p_env)</span> </span>&#123;</span><br><span class="line">  JavaVM *jvm = g_jvm;</span><br><span class="line">  JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">// 如果当前线程已经有JNIEnv，则会返回JNI_OK</span></span><br><span class="line">  jint status = jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">  <span class="keyword">if</span> (status == JNI_OK) &#123;</span><br><span class="line">    *p_env = env;</span><br><span class="line">    <span class="built_in">MLOG</span>(<span class="string">&quot;Already AttachCurrentThread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 为当前线程创建JNIEnv</span></span><br><span class="line">  <span class="keyword">if</span> (jvm-&gt;<span class="built_in">AttachCurrentThread</span>(&amp;env, <span class="literal">NULL</span>) == JNI_OK) &#123;</span><br><span class="line">    <span class="built_in">MLOG</span>(<span class="string">&quot;AttachCurrentThread&quot;</span>);</span><br><span class="line">    *p_env = env;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当C++线程执行完成的时候，一定要手动的销毁JNIEnv,否则会造成内存泄露。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JNIHelper::detachThreadJNIEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  JavaVM *jvm = g_jvm;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (jvm-&gt;<span class="built_in">DetachCurrentThread</span>() == JNI_OK) &#123;</span><br><span class="line">    <span class="built_in">MLOG</span>(<span class="string">&quot;DetachCurrentThread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JNI引用"><a href="#JNI引用" class="headerlink" title="JNI引用"></a>JNI引用</h2><p>对于JNI来说，引用类型分为Local引用、Global引用、Weak Global引用。（这里的引用都是指JNI类型的变量）</p>
<h3 id="Local引用"><a href="#Local引用" class="headerlink" title="Local引用"></a>Local引用</h3><p>对于Local引用是无法夸线程使用的，其生命周期在Native方法执行完成后，就会被结束。每次JNI调用的时候，JVM都会分配一块内存给当前线程，用于创建一个Local引用表，在native方法中创建的所有JNI类型变量都会保存在该表中。对于这些变量，当Native方法结束时，JNI会自动释放，也可以手动调用DeleteLocalRef函数来删除。</p>
<h3 id="Global引用"><a href="#Global引用" class="headerlink" title="Global引用"></a>Global引用</h3><p>当一个JNI类型的对象需要跨线程使用时，就需要将其转换为Global引用，通过NewGlobalRef函数。对于Global引用，GC是不会回收其内存，只能手动调用DeleteGlobalRef函数来释放。</p>
<h3 id="Weak-Global引用"><a href="#Weak-Global引用" class="headerlink" title="Weak Global引用"></a>Weak Global引用</h3><p>如果一个对象想要进行跨线程使用，但是又想让GC可以回收，那么可以使用Weak Global引用。可以通过NewWeakGlobakRef和DeleteWeakGlobalRef函数来创建和删除。</p>
<blockquote>
<p>在使用的时候需要注意一点，由于其GC的时机是不确定的，所以最好先通过NewLocalRef将Weak Global引用转换成Local引用再使用。</p>
</blockquote>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频基础介绍</title>
    <url>/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="本篇重点"><a href="#本篇重点" class="headerlink" title="本篇重点"></a>本篇重点</h1><blockquote>
<p>音视频基础概念与相关术语的讲解</p>
</blockquote>
<h1 id="什么是视频"><a href="#什么是视频" class="headerlink" title="什么是视频"></a>什么是视频</h1><h2 id="图像的组成"><a href="#图像的组成" class="headerlink" title="图像的组成"></a>图像的组成</h2><p>在说视频之前，我们来聊一下图像，<strong>图像是人对视觉感知的物质再现</strong>。图像是使用像素点阵来表示的，每个像素点都分配有特定的颜色和位置值。像素也是图像显示的基本单位，通常一幅1080x1920的图片，就是长度1920个像素点，宽度1080个像素点组成的矩阵。</p>
<h2 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h2><p>像素点除了有位置外还需要有颜色信息，那么颜色在计算机中是如何表示呢？</p>
<p>在计算机中颜色空间有很多，这里我们介绍下常用的两种颜色空间，RGB颜色空间和YUV颜色空间。</p>
<span id="more"></span>

<h3 id="RGB颜色空间"><a href="#RGB颜色空间" class="headerlink" title="RGB颜色空间"></a>RGB颜色空间</h3><p>RGB颜色空间是由红绿蓝三原色来定义，通过三原色混合成所有的颜色，这应该是我们最熟悉的一种颜色空间。</p>
<h3 id="YUV颜色空间"><a href="#YUV颜色空间" class="headerlink" title="YUV颜色空间"></a>YUV颜色空间</h3><p>Y表示亮度，U和V表示色度和浓度。早期的YUV实际上是用在彩色电视和黑白电视的交替上，感兴趣历史的同学可以点击<a href="https://zh.wikipedia.org/wiki/YUV">YUV</a>查看相关资料。YUV颜色空间在数字媒体中广泛使用是由于人类对亮度的的敏感度高于对色度的敏感度，但是在数字媒体中使用的是个变体，叫YCbCr，其中Cb是指蓝色色度，Cr就是红色色度。像JPEG、MPEG都是采用此格式，后续一般讲的YUV都是指YCbCr。(Y的值是根据RGB值计算出来的，所以Cg的值可以通过CbCr计算出来，所以在传输的时候只需要传输YCbCr)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">计算公式: </span><br><span class="line">    Y = KrR+KgG+Kb*B（k为权重值,ITU-R推荐的BT.601中定义Kb=0.114,Kr=0.299,Kb+Kr+Kg=1）</span><br><span class="line">    Cb=B-Y</span><br><span class="line">    Cr=R-Y</span><br><span class="line">    Cg=G-Y</span><br></pre></td></tr></table></figure>

<p>YCbCr会按照一定的采样比对色度数据进行采样，采样比通常表示为 __J​ : a : ​b__，表示在一个宽为J像素、高为2像素的采样区域中进行采样，J表示采样的宽度，通常是4，a表示第一行色度采样数，b表示第二行色度采样数与第一行色度采样的不同样点数。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/ycbcr.png" alt="YCbCr采样比"></p>
<p>最常见的采样比是 4:2:0 ，表示宽为4，第一行有两个色度采样点，第二行与第一行完全相同。所以总共有八个亮度采样点和两个色度采样点，每个亮度采样点需要记录一个值Y，而每个色度采样点都需要记录两个值Cb和Cr。最终需要记录的值为 8Y+2Cr+2Cb &#x3D; 12，而如果使用RGB来记录则会需要3x8&#x3D;24。</p>
<blockquote>
<p>YCbCr的优势就在于，在达到最大压缩率的情况下，能够保证对人眼感知的失真度最小。拿4:2:0来说足足压缩了一半。</p>
</blockquote>
<p>YUV按照存储方式又可以分为下面两种</p>
<h4 id="planar"><a href="#planar" class="headerlink" title="planar"></a>planar</h4><p>YCbCr分别存储在不同的平面中。根据CbCr存储的顺序不同，又分为I420和YV12。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/yuv420p.png"></p>
<ul>
<li>I420 : 也叫YU12，先存储Y，再存Cb，最后存Cr，最终数据结果是 YYYY CbCb CrCr，也就是上图所展示的。</li>
<li>YV12：先存储Y，再存Cr，最后存Cb，最终数据结果是 YYYY CrCr CbCb</li>
</ul>
<h4 id="semi-planar"><a href="#semi-planar" class="headerlink" title="semi planar"></a>semi planar</h4><p>Y单独一个平面，CbCr共用一个平面。根据CbCr存储的顺序不同，又分为NV12和NV21。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/yuv420sp.png"></p>
<ul>
<li>NV12：先存储Y，然后CbCr交替存储，最终数据结果为 YYYY CbCr CbCr，也就是上图所展示的。（IOS中使用）</li>
<li>NV21：先存储Y，然后CrCb交替存储，最终数据结果为 YYYY CrCb CrCb。（Android中使用）</li>
</ul>
<h2 id="视频的组成"><a href="#视频的组成" class="headerlink" title="视频的组成"></a>视频的组成</h2><p>前面说了这么多图像，现在我们来说说视频，所谓视频就像下面动图中展示的一样，<strong>视频是由连续的图像组成</strong>。视频的原理就是利用人眼的特殊结构，当画面在快速切换时，画面会有残留，所以人感觉起来就像是连贯的动作。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/video_basic_demo.gif"></p>
<h3 id="视频帧"><a href="#视频帧" class="headerlink" title="视频帧"></a>视频帧</h3><p>帧是视频流的一个基本单位，可以将其联想成一幅静态图像，一个YCbCr格式的图像。</p>
<h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>帧率指的是视频每秒包含的帧数（FPS，Frame per second），帧率是衡量视频质量的一个重要指标。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/video_fps_demo.gif"></p>
<p>帧率越高，则视频会越流畅，一般视频都是24-30帧之间，电影一般都保持在24帧，而手机一般拍摄都默认在30帧，最高可以拍摄60帧的视频。</p>
<h3 id="色彩位数"><a href="#色彩位数" class="headerlink" title="色彩位数"></a>色彩位数</h3><p>表示一个像素中存储颜色所用的位数，位数越高，则颜色越丰富。常见的有8位、16位、24位、32位，其中24位是最常用的，称为真彩，而32位是在24位上加了8位表示透明度。</p>
<h3 id="场（扩展）"><a href="#场（扩展）" class="headerlink" title="场（扩展）"></a>场（扩展）</h3><p>大家应该都听说过1080P，这是一种视频显示格式，那么大家有没有听过说1080I呢？</p>
<p>1080I指的是在电视信号中，采用隔行交错扫描视频的信号格式。而1080P指的是用逐行扫描视频的显示格式。</p>
<p>为什么会有隔行扫描呢？因为早期电视机没办法处理大量复杂的数据，没发观看高清电视，所以采用了隔行扫描，将每一帧图像，按照单行和双行分为两场，顶场和低场，两场交替显示。在PAL制式的电视台规定是每秒25帧，每帧两场，也就是每秒50场，所以PAL制式的扫描频率就是50HZ。</p>
<h2 id="人类视觉系统HVS（扩展）"><a href="#人类视觉系统HVS（扩展）" class="headerlink" title="人类视觉系统HVS（扩展）"></a>人类视觉系统HVS（扩展）</h2><p>HVS由眼睛+神经+大脑组成。视频的一些设计就是根据HVS的特点来的。</p>
<ul>
<li>对高频信息不敏感 -&gt;  丢弃高频信息，只编码低频信息</li>
<li>对高对比度更敏感 -&gt; 提高边缘信息的主观质量</li>
<li>对亮度信息比色度信息更敏感 -&gt; 降低色度的解析度</li>
<li>对运动的信息更敏感 -&gt; 对ROI区域进行特殊处理</li>
</ul>
<h1 id="什么是音频"><a href="#什么是音频" class="headerlink" title="什么是音频"></a>什么是音频</h1><p>上面讲了图像的数字化表现形式，那么声音如何数字化呢？</p>
<h2 id="声音的产生"><a href="#声音的产生" class="headerlink" title="声音的产生"></a>声音的产生</h2><p>声音是由物体振动产生的，再通过空气、固体、液体等传输，传入人耳后振动耳膜，再通过听觉神经传递给大脑</p>
<h3 id="声音的三要素"><a href="#声音的三要素" class="headerlink" title="声音的三要素"></a>声音的三要素</h3><ul>
<li>音调 ：音频振动的快慢 （男生 &lt; 女生 &lt; 儿童）</li>
<li>音量 ：振动的幅度</li>
<li>音色 ：声波是由基波和谐波组合成，不同频谱的谐波比例不同，音色也就不同</li>
</ul>
<blockquote>
<p>​	人类听觉范围 &#x3D; 次声波 ~ 20Hz ~ 20kHz ~ 超声波</p>
</blockquote>
<h2 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h2><p>声音是一种波，是一种模拟信号，模拟信号是指时间上和数值上连续的信号。而模拟信号想要用于计算机，就必须将模拟信号转为数字信号。而PCM（脉冲编码调制）就是将输入的模拟信号进行采样、量化、编码，最终输出为数字信号。</p>
<blockquote>
<p>​	模拟信号 -&gt; 采样 -&gt; 量化 -&gt; 编码 -&gt; 数字信号</p>
</blockquote>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>采样就是把时间连续的模拟信号变成时间离散、幅度连续的数字信号。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/pcm_encoded_signal.jpeg"></p>
<h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率就是指每秒采集的样本数，常见的有 8k、16k、32k、44.1k、48k等。</p>
<blockquote>
<p>Nyquist采样定律：采样率大于或等于连续信号最高频率分量的2倍时，采样信号可以用来完美重构连续信号。而人类正常感知的频率在22.05kHz以下，所以最常见的采样率是44.1kHz，也就是每秒采样44100个采样点。</p>
</blockquote>
<h3 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h3><p>就是采样值的范围，一般有8位、16位、32位。位数越多，音量起伏的大小变化就能够更精细的被记录下来，还原度越高。一般采用的都是16位，32位太扩张了。</p>
<h3 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h3><p>声音的通道的数目，指声音在录制和播放的时候在不同空间位置采集或回放的相互独立的音频信号，简单来说就是声音录制时的音频源数量或回放时相应的扬声器数量。分为单声道、双声道、多声道。其中双声道是使用最普遍的。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><p>采样后的信号虽然在时间上是离散的，但是其值的取值范围依旧是无限的，所以需要将无限的值量化到一定范围内的有限值。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>将量化后的采样值编码成二进制码流的过程称为编码。</p>
<h1 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h1><p>当一个音视频文件生产的时候，就面临了两个问题：</p>
<ul>
<li>存储</li>
<li>传输</li>
</ul>
<p>为什么存储和传输会是个问题呢？我们来计算下一个原始未压缩的视频会有多大，已一个1080x1920分辨率、帧率是30的90分钟视频为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单帧大小 1920x1080 = 2073600个像素点，按照RGB来算就是 2073600x3byte = 6220800byte ≈ 5.9MB，按照YUV来计算就是 ≈ 2.9MB。</span><br><span class="line"></span><br><span class="line">一秒视频大小 2.9MBx30 = 87MB</span><br><span class="line">一秒音频大小 44100x2bytex2(声道) = 176400byte 约等于 0.168MB</span><br><span class="line"></span><br><span class="line">90分钟的视频大小 = 87MBx60x90 = 469800MB ≈ 459GB</span><br><span class="line">90分钟的音频大小 = 0.168MBx60x90 = 907.2MB</span><br></pre></td></tr></table></figure>

<p>是不是很恐怖？一部电影居然就接近460GB了，想想当前的硬盘大小和网速，怎么可能存储和传输呢。</p>
<p>所以必须要对视频进行编码，编码就是按指定的方式，将信息从一种形式转换成另一种形式。编码的目的，就是为了压缩，各种视频编码方式，都是为了将视频变得更小，便于存储和传输。</p>
<h2 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h2><h3 id="编码原理"><a href="#编码原理" class="headerlink" title="编码原理"></a>编码原理</h3><p>压缩编码的核心思想就是去除冗余信息。常见的编码方式有预测编码和变换编码以及熵编码，其中预测编码是压缩率最大的一种。</p>
<h4 id="预测编码"><a href="#预测编码" class="headerlink" title="预测编码"></a>预测编码</h4><p>帧内预测编码</p>
<p>从空间角度出发，图像相邻像素之间有较强的相关性，可以从空间上去帧内像素之间的冗余。比如说下面这一帧，其中尘土的颜色、背景的颜色都是大致相同的，完全没有必要每个像素都记录一次颜色。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/spatial_redundancy.jpeg"></p>
<p>帧间预测编码</p>
<p>从时间角度出发，视频序列的相邻图像之间的内容有相似性，可以从时间上去除帧与帧之间的冗余。比如说下面这一个视频序列（假设这是一个2秒50帧的视频序列），我们可以发现这50帧里，除了结印的手在变动，其它地方都没有变化。那么其它未变的地方真的要存储50份一样的数据吗？是不是可以省略掉，存储一份就够了。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/time_redundancy.gif"></p>
<h4 id="变换编码"><a href="#变换编码" class="headerlink" title="变换编码"></a>变换编码</h4><p>大多数视频图像都和上面展示的一样，变动的区域只是一小部分，大部分区域是不变的，可就是说低频区占大部分，高频区占小部分。然后将空间域的图像变换到频率域，会产生相关性很小的变换系数，然后再对变换系数进行量化，利用上面人类视觉体统特点所说到的，人对高频信息不敏感的特征，对低频区的系数进行细量化，对高频区的系数进行粗量化，从而降低信息传递量，达到压缩的目的。</p>
<p>简单的解释变换，就是如下图所示，坐标系中有ABC三点，我们将坐标轴调整一下，ABC三点的坐标值就会变小。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/transform_coding.png"></p>
<p>一个8x8的像素区域，假设其像素颜色值如下图所示</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/transform_coding_1.png"></p>
<p>像素区域经过DCT（离散余弦变换）变换后，生产的变换系数，如下图所示</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/transform_coding_2.png"></p>
<p>对变换系数进行量化，量化后大部分都会变成0，此时只需要将这些非0的值进行编码即可，入下图所示</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/transform_coding_3.png"></p>
<h4 id="熵编码"><a href="#熵编码" class="headerlink" title="熵编码"></a>熵编码</h4><p>利用信息的统计特性，使用新的编码来表示输入的数据，比如说哈夫曼编码、CABAC。简单解释就是给高频数据短码，给低频数据长码，比如 A 是高频数据，则编码为 01，G是低频数据，则编码为 01010001。</p>
<h4 id="编码模型（扩展）"><a href="#编码模型（扩展）" class="headerlink" title="编码模型（扩展）"></a>编码模型（扩展）</h4><p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/video_encode_flow.jpeg"></p>
<h3 id="常见编码格式"><a href="#常见编码格式" class="headerlink" title="常见编码格式"></a>常见编码格式</h3><p>常见的编码格式有H.26x系列和MPEG系列，其中H.26x系统是由ITU组织（国际电信联盟）主导，而MPEG系列由ISO（国际标准化组织）下的MPEG（动态图像专家组）组织主导的。</p>
<p>目前主流的H.264和H.265编码格式是由ITU和MPEG两个组织合力制定的。</p>
<h3 id="H-264与MPEG-4-AVC的关系"><a href="#H-264与MPEG-4-AVC的关系" class="headerlink" title="H.264与MPEG-4 AVC的关系"></a>H.264与MPEG-4 AVC的关系</h3><p>在早期，ITU和MPEG两家组织都是各搞各的，ITU组织推行了H.261、H.262、H.263编码格式，而MPEG组织则推行了MPEG-1、MPEG-2、MPEG-3标准族群。后来两家组织准备合力制作新一代的视频编码标准，对于ITU组织来说，将这个新一代的编码标准命名为H.264，而对于MPEG来说，这个新一代的压缩标准只是其MPEG-4标准的第10部分，其第10部分叫做高级视频编码AVC（Advanced Video Coding）。</p>
<p>所以可以简单的认为H.264就是MPEG-4 AVC。</p>
<h4 id="Annex-B格式和AVCC格式（扩展）"><a href="#Annex-B格式和AVCC格式（扩展）" class="headerlink" title="Annex B格式和AVCC格式（扩展）"></a>Annex B格式和AVCC格式（扩展）</h4><ul>
<li>Annex B格式</li>
</ul>
<p>这种格式的H.264码流用于实时流的传播中，其特点是码流中每个NALU（单元块）之间通过起始码来分割，起始码分为两种，一帧开始则用四个字节的1来表示，不是一帧开始就用三个字节的1来表示。</p>
<blockquote>
<p>H.264原始码流是由一系列的NALU组成（Network Abstraction Layer Unit），不同的NALU数据量不同。</p>
</blockquote>
<ul>
<li>AVCC格式</li>
</ul>
<p>这种格式的H.264码流用于磁盘文件中（MP4等媒体文件），其特点是没有起始码，而是将起始码替换成了size，是为了应对存储文件的可随机访问特性。</p>
<h3 id="H-265与MPEG-H-HEVC"><a href="#H-265与MPEG-H-HEVC" class="headerlink" title="H.265与MPEG-H HEVC"></a>H.265与MPEG-H HEVC</h3><p>H.265和H.264一样，依旧是ITU和MPEG两家合力制定的。H.265被定义在MPEG-H的第2部分，称为高效率视频编码 High Efficiency Video Coding。</p>
<p>H.265的压缩率是H.264的两倍，并且支持4K清晰度，最高支持到8K。目前主流的设备基本都支持H.265编码。</p>
<h2 id="音频编码"><a href="#音频编码" class="headerlink" title="音频编码"></a>音频编码</h2><h3 id="编码原理-1"><a href="#编码原理-1" class="headerlink" title="编码原理"></a>编码原理</h3><p>音频编码是在保证信号在听觉方面不产生失真的前提下，对音频数据进行尽可能大的压缩。其原理是<strong>通过去除声音信号中冗余成分来实现</strong>，所谓冗余成分就是指<strong>不在人耳听觉范围内的音频信号</strong>以及<strong>被掩蔽掉的音频信号</strong>。</p>
<p>不在人耳听觉范围内的音频信号是因为人耳能够察觉的声音信号的频率范围为20Hz-20KHz，除此之外的频率是无法察觉的。</p>
<p>被掩蔽掉的音频信号是因为当一个强音信号与一个弱音信号同时存在时，弱音信号将被强音信号所掩蔽而听不见，所以此时弱音信号可以视为冗余而不用传输。</p>
<h4 id="频谱掩蔽效应"><a href="#频谱掩蔽效应" class="headerlink" title="频谱掩蔽效应"></a>频谱掩蔽效应</h4><p>相同音量下，频率低的被遮蔽；相同频率下，音量小的被遮蔽；</p>
<h4 id="时域掩蔽效应"><a href="#时域掩蔽效应" class="headerlink" title="时域掩蔽效应"></a>时域掩蔽效应</h4><p>时间上相邻的声音之间也有掩蔽现象，分为超前掩蔽和滞后掩蔽。产生时域掩蔽的主要原因是人的大脑处理信息需要花费一定的时间，超前掩蔽很短，只有大约5<del>20ms，而滞后掩蔽可以持续50</del>200ms。</p>
<h4 id="编码模型（扩展）-1"><a href="#编码模型（扩展）-1" class="headerlink" title="编码模型（扩展）"></a>编码模型（扩展）</h4><p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/audio_encode_flow.jpeg"></p>
<h3 id="常见编码格式-1"><a href="#常见编码格式-1" class="headerlink" title="常见编码格式"></a>常见编码格式</h3><p>如果说视频编码被H.264和H.265所统治，那么统治音频编码的就是AAC了。AAC全称是Advanced Audio Coding，是一个有损压缩的音频编码集。除了AAC编码外，Opus编码在即时通信领域上使用的比较广泛。</p>
<h4 id="ACC规格"><a href="#ACC规格" class="headerlink" title="ACC规格"></a>ACC规格</h4><ul>
<li>AAC-LC</li>
</ul>
<p>AAC-LC的全称是Advanced Audio Coding Low-Complexity，用于存储空间和计算能力有限的情况，这种类型没有使用预测和增益控制，瞬时噪声整形的阶数也比较低。</p>
<ul>
<li>AAC-LD</li>
</ul>
<p>AAC-LD的全称是Advanced Audio Coding Low-Delay，是源于AAC-LC，结合了感知音频编码和双向通道的低延时要求，减小的算法的延时。</p>
<ul>
<li><p>AAC-HE-V1</p>
<p>核心思想是按频谱保存，将时域转换为频域，将低频编码保存为主要部分，将高频单独放大编码保存。</p>
</li>
<li><p>AAC-HE-V2</p>
<p>核心思想是双声道中的声音存在某种相似性，只需存储一个声道的全部信息，然后花很少的字节用参数描述另一个声道和它不同的地方。</p>
</li>
</ul>
<h4 id="AAV格式"><a href="#AAV格式" class="headerlink" title="AAV格式"></a>AAV格式</h4><ul>
<li>ADIF格式</li>
</ul>
<p>ADIF是在MPEG-2中定义的，其特点是可以确定的找到这个音频数据的开始，解码必须在明确定义的开始处进行，这种格式常用在磁盘文件中。</p>
<ul>
<li>ADTS格式</li>
</ul>
<p>ADTS的特征是它有一个同步字的比特流，解码可以在这个流的任何位置开始，帧同步目的就是在于找出帧头在比特流中的位置，ADTS的同步字为三个字节的1111 1111 1111来表示。</p>
<ul>
<li>LATM格式</li>
</ul>
<p>LATM是在MPEG-4中制定的一种高效率的码流传输方式。</p>
<h1 id="为什么要封装？"><a href="#为什么要封装？" class="headerlink" title="为什么要封装？"></a>为什么要封装？</h1><p>所谓封装就是定义一个容器，将视频、音频、字幕等数据都混合封装在容器中。容器使得媒体内容的同步播放变得简单，另外容器中还会存储媒体内容的基本信息以及媒体内容的帧索引，方便快速拖动和跳转到指定位置。</p>
<h2 id="常见封装格式"><a href="#常见封装格式" class="headerlink" title="常见封装格式"></a>常见封装格式</h2><h3 id="MPEG格式"><a href="#MPEG格式" class="headerlink" title="MPEG格式"></a>MPEG格式</h3><p>后缀为（.mp4等），常用的一般是MPEG-4标准的第14部分定义的MP4文件格式。</p>
<h3 id="QuickTime-File-Format格式"><a href="#QuickTime-File-Format格式" class="headerlink" title="QuickTime File Format格式"></a>QuickTime File Format格式</h3><p>后缀为 .mov ，苹果公司推出的一种视频封装格式，常用于苹果设备。</p>
<h3 id="Flash-Video格式"><a href="#Flash-Video格式" class="headerlink" title="Flash Video格式"></a>Flash Video格式</h3><p>后缀为 .flv，Adobe Flash延伸出来的一种视频封装格式。</p>
<h1 id="硬解与软解的区别"><a href="#硬解与软解的区别" class="headerlink" title="硬解与软解的区别"></a>硬解与软解的区别</h1><h2 id="硬解码"><a href="#硬解码" class="headerlink" title="硬解码"></a>硬解码</h2><p>调用soc中的专门模块来进行编解码，减少了对CPU的占用，且更加省电，但是缺点是在Android手机上，由于国内产商使用的芯片参差不齐，会有很多兼容性的问题。</p>
<h3 id="SOC芯片"><a href="#SOC芯片" class="headerlink" title="SOC芯片"></a>SOC芯片</h3><p>手机SOC芯片，就是在一个芯片里面集成CPU、GPU、SP、ISP、RAM内存、WIFI控制器、基带芯片、音频芯片等。</p>
<p><img src="/2020/03/01/av/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/soc%E8%8A%AF%E7%89%87.png"></p>
<h3 id="Android平台MediaCodec"><a href="#Android平台MediaCodec" class="headerlink" title="Android平台MediaCodec"></a>Android平台MediaCodec</h3><p>在Android平台的上，提供的编解码API就是MediaCodec，该API在21之前都只有Java层实现，在21后提供了C实现。MediaCodec与底层硬件的交互，是通过OpenMax来实现的。</p>
<h3 id="IOS平台VideoToolBox"><a href="#IOS平台VideoToolBox" class="headerlink" title="IOS平台VideoToolBox"></a>IOS平台VideoToolBox</h3><h2 id="软解码"><a href="#软解码" class="headerlink" title="软解码"></a>软解码</h2><p>软解码是指通过CPU来对视频进行编解码处理，常用的开源库是FFmpeg，相对于硬解码来说，软解码的兼容性非常好，但是缺点也很明显，占用CPU，费电，在处理速度上会比硬解码慢。</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
  </entry>
  <entry>
    <title>c++类型推断</title>
    <url>/2022/11/24/c++/c++%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/</url>
    <content><![CDATA[<h1 id="为什么要了解类型推断？"><a href="#为什么要了解类型推断？" class="headerlink" title="为什么要了解类型推断？"></a>为什么要了解类型推断？</h1><p><img src="/2022/11/24/c++/c++%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD/zhihu_c++50.png"></p>
<h2 id="C-98"><a href="#C-98" class="headerlink" title="C++98"></a>C++98</h2><p>在c++98的年代，只有模板才有类型推断，如果你不使用模板，那么你完全不需要理解类型推断。</p>
<h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>在C++11中，类型推断在模板之外被大量应用。</p>
<ul>
<li>auto</li>
<li>lambda captures</li>
<li>function return</li>
<li>decltype</li>
</ul>
<p>想要熟练的使用上述新特性，那么就必须要了解类型推断的规则。</p>
<span id="more"></span>

<h2 id="C-14"><a href="#C-14" class="headerlink" title="C++14"></a>C++14</h2><p>在C++14中，对类型推断又有了进一步的扩展。</p>
<ul>
<li>decltype(auto)</li>
<li>lambda init captures</li>
</ul>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>在进行类型推断时，大家始终要记得一点，我们要推断的是两个类型，而非一个！</p>
<ul>
<li>T ：这是推断的类型</li>
<li>ParamType : 基于T，但是和T经常不一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(T* param)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-98-1"><a href="#C-98-1" class="headerlink" title="C++98"></a>C++98</h2><p>在C++98中，对于模板的类型推断，可以分为两条规则：</p>
<ul>
<li>T  </li>
<li>T&amp; &#x2F; T*</li>
</ul>
<h2 id="C-11-1"><a href="#C-11-1" class="headerlink" title="C++11"></a>C++11</h2><p>在C++11中，可以分为六条规则：</p>
<ul>
<li>template<ul>
<li>T</li>
<li>T&amp; &#x2F; T* </li>
<li>T&amp;&amp;</li>
</ul>
</li>
<li>lambda captures<ul>
<li>基于T&amp; &#x2F; T* 规则，有一些区别</li>
</ul>
</li>
<li>lambda return<ul>
<li>使用T规则</li>
</ul>
</li>
<li>decltype<ul>
<li>独立的一套规则</li>
</ul>
</li>
<li>auto<ul>
<li>基于模板规则，有些细节区别</li>
</ul>
</li>
</ul>
<h2 id="C-14-1"><a href="#C-14-1" class="headerlink" title="C++14"></a>C++14</h2><p>在C++14中，新增的扩展使用的还是上述六条规则：</p>
<ul>
<li>decltype(auto)<ul>
<li>使用decltype规则</li>
</ul>
</li>
<li>lambda init captures<ul>
<li>使用auto规则</li>
</ul>
</li>
</ul>
<h1 id="规则详解"><a href="#规则详解" class="headerlink" title="规则详解"></a>规则详解</h1><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><p>丢弃CVR（const、volatile、reference），剩下的就是T的类型</p>
<blockquote>
<blockquote>
<p>当传入的是函数名或者数组名时，T会是函数指针或数组指针</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>不支持大括号初始化，因为大括号初始化没有类型</p>
</blockquote>
</blockquote>
<p>因为当param类型为T时，表示param将会是重新定义的一个全新的变量，与传递进来的变量应该彼此独立，所以T不能是引用，引用需要丢弃！一个全新的变量，其CV修饰符应该有自身显示定义，不应该继承其它变量的修饰符，所以CV修饰符应该丢弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f1</span>(x);     <span class="comment">// T = int; param = int</span></span><br><span class="line">  <span class="built_in">f1</span>(cx);    <span class="comment">// T = int; param = int</span></span><br><span class="line">  <span class="built_in">f1</span>(rx);    <span class="comment">// T = int; param = int</span></span><br><span class="line">  <span class="built_in">f1</span>(rcx);   <span class="comment">// T = int; param = int</span></span><br><span class="line">  <span class="built_in">f1</span>(px);    <span class="comment">// T = int*; param = int*</span></span><br><span class="line">  <span class="built_in">f1</span>(pcx);   <span class="comment">// T = int const*; param = int const*</span></span><br><span class="line">  <span class="built_in">f1</span>(cpx);   <span class="comment">// T = int*; param = int*</span></span><br><span class="line">  <span class="built_in">f1</span>(<span class="number">22</span>);    <span class="comment">// T = int; param = int</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">f1</span>(test);  <span class="comment">// T = void (*)(int); param = void (*)(int)</span></span><br><span class="line">  <span class="built_in">f1</span>(arr);   <span class="comment">// T = int*; param = int*</span></span><br><span class="line">  <span class="comment">// f1(&#123;1, 2, 3&#125;);  // Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="T-amp-x2F-T"><a href="#T-amp-x2F-T" class="headerlink" title="T&amp;&#x2F;T*"></a>T&amp;&#x2F;T*</h3><h4 id="T-amp"><a href="#T-amp" class="headerlink" title="T&amp;"></a>T&amp;</h4><p>丢弃引用，剩下的就是T的类型（继承CV）</p>
<blockquote>
<blockquote>
<p>当传入的是函数名或者数组名时，T会是函数引用或数组引用</p>
</blockquote>
</blockquote>
<p>因为param的类型是T&amp;，已经有引用了，所以当传进来的变量是引用时，应该忽略引用；param是引用时，赋值是指向外部的变量本身，所以CV描述符不应该丢弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(T&amp; param)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">int</span>&amp;&amp; rx2 = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f2</span>(x);    <span class="comment">// T = int; param = int&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(cx);   <span class="comment">// T = int const; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(rx);   <span class="comment">// T = int; param = int&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(rcx);  <span class="comment">// T = int const; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(px);   <span class="comment">// T = int*; param = int*&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(pcx);  <span class="comment">// T = int const*; param = int const*&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(cpx);  <span class="comment">// T = int* const; param = int* const&amp;</span></span><br><span class="line">  <span class="built_in">f2</span>(rx2);  <span class="comment">// T = int; param = int&amp;</span></span><br><span class="line">  <span class="comment">// f2(22);</span></span><br><span class="line">  <span class="built_in">f2</span>(test); <span class="comment">// T = void (int); param = void (&amp;)(int)</span></span><br><span class="line">  <span class="built_in">f2</span>(arr);  <span class="comment">// T = int [3]; param = int (&amp;) [3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="const-T-amp"><a href="#const-T-amp" class="headerlink" title="const T&amp;"></a>const T&amp;</h4><p>当显示声明CV修饰符时，丢弃CV</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(<span class="type">const</span> T&amp; param)</span> </span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;const reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f3</span>(x);      <span class="comment">// T = int; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(cx);     <span class="comment">// T = int; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(rx);     <span class="comment">// T = int; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(rcx);    <span class="comment">// T = int; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(px);     <span class="comment">// T = int*; param = int* const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(pcx);    <span class="comment">// T = int const*; param = int const* const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(cpx);    <span class="comment">// T = int*; param = int* const&amp;</span></span><br><span class="line">  <span class="built_in">f3</span>(<span class="number">22</span>);     <span class="comment">// T = int*; param = int* const&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T-1"><a href="#T-1" class="headerlink" title="T*"></a>T*</h4><p>丢弃指针，丢弃CV，剩下的就是T的类型</p>
<p>因为param的类型是T*，已经有指针了，所以当传进来的变量是指针时，应该忽略指针；param是指针就表明是一个全新的变量，其CV修饰符应该有自身显示定义，不应该继承其它变量的修饰符，所以CV修饰符应该丢弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(T* param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f4</span>(px);   <span class="comment">// T = int; param = int*</span></span><br><span class="line">  <span class="built_in">f4</span>(pcx);  <span class="comment">// T = int const; param = int const*</span></span><br><span class="line">  <span class="built_in">f4</span>(cpx);  <span class="comment">// T = int; param = int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="T-amp-amp"><a href="#T-amp-amp" class="headerlink" title="T&amp;&amp;"></a>T&amp;&amp;</h3><p>表达式为左值时，T为表达式类型（丢弃引用后）的左值引用；表达式为右值时，T为表达式类型。（继承CV）</p>
<blockquote>
<blockquote>
<p>注意：param看起来是右值引用，但并不一定是右值引用，只有当表达式为右值时，param才是右值引用</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f7</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">int</span>&amp;&amp; rx2 = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;universal reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f7</span>(x);    <span class="comment">// T = int&amp;; param = int&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(cx);   <span class="comment">// T = int const&amp;; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(rx);   <span class="comment">// T = int&amp;; param = int&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(rx2);  <span class="comment">// T = int&amp;; param = int&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(rcx);  <span class="comment">// T = int const&amp;; param = int const&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(px);   <span class="comment">// T = int*&amp;; param = int*&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(pcx);  <span class="comment">// T = int const*&amp;; param = int const*&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(cpx);  <span class="comment">// T = int* const&amp;; param = int* const&amp;</span></span><br><span class="line">  <span class="built_in">f7</span>(<span class="number">22</span>);   <span class="comment">// T = int; param = int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-T-amp-amp"><a href="#const-T-amp-amp" class="headerlink" title="const T&amp;&amp;"></a>const T&amp;&amp;</h3><p>param一定是常量右值引用，只接收右值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f8</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;T = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;T&gt;().<span class="built_in">pretty_name</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;; param = &quot;</span> &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;const universal reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">f8</span>(<span class="number">22</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>丢弃CVR（const、volatile、reference），剩下的就是auto的类型</p>
<blockquote>
<blockquote>
<p>当传入的是函数名或者数组名时，auto会是函数指针或数组指针</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>支持大括号初始化，分为直接赋值和拷贝赋值两种情况，c++17之前的编译器，所有推断出来的都是std::initializer_list<int>，之后的编译器，拷贝赋值保持不变，直接赋值不支持多个元素，类型推断为第一个元素的类型</p>
</blockquote>
</blockquote>
<p>因为当变量类型为auto时，表示变量将会是重新定义的一个全新的变量，与传递进来的变量应该彼此独立，所以auto不能是引用，引用需要丢弃！一个全新的变量，其CV修饰符应该有自身显示定义，不应该继承其它变量的修饰符，所以CV修饰符应该丢弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> a_x = x;       <span class="comment">// int</span></span><br><span class="line">  <span class="keyword">auto</span> a_cx = cx;     <span class="comment">// int</span></span><br><span class="line">  <span class="keyword">auto</span> a_rx = rx;     <span class="comment">// int</span></span><br><span class="line">  <span class="keyword">auto</span> a_rcx = rcx;   <span class="comment">// int</span></span><br><span class="line">  <span class="keyword">auto</span> a_px = px;     <span class="comment">// int*</span></span><br><span class="line">  <span class="keyword">auto</span> a_pcx = pcx;   <span class="comment">// const int*</span></span><br><span class="line">  <span class="keyword">auto</span> a_cpx = cpx;   <span class="comment">// int*</span></span><br><span class="line">  <span class="keyword">auto</span> a_22 = <span class="number">22</span>;     <span class="comment">// int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> a_test = test; <span class="comment">// void (*)(int) </span></span><br><span class="line">  <span class="keyword">auto</span> a_arr = arr;   <span class="comment">// int*</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> a_init = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">// std::initializer_list&lt;int&gt;</span></span><br><span class="line">  <span class="comment">// auto a_init2&#123;1, 2, 3&#125;; // error</span></span><br><span class="line">  <span class="keyword">auto</span> a_init3 = &#123;<span class="number">1</span>&#125;;       <span class="comment">// std::initializer_list&lt;int&gt;</span></span><br><span class="line">  <span class="keyword">auto</span> a_init4&#123;<span class="number">1</span>&#125;;          <span class="comment">// int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto-amp-x2F-auto"><a href="#auto-amp-x2F-auto" class="headerlink" title="auto&amp;&#x2F;auto*"></a>auto&amp;&#x2F;auto*</h3><h4 id="auto-amp"><a href="#auto-amp" class="headerlink" title="auto&amp;"></a>auto&amp;</h4><p>丢弃引用，剩下的就是auto的类型（继承CV）</p>
<blockquote>
<blockquote>
<p>当传入的是函数名或者数组名时，T会是函数引用或数组引用<br>因为变量的类型是auto&amp;，已经有引用了，所以当传进来的变量是引用时，应该忽略引用；变量是引用时，赋值是指向外部的变量本身，所以CV描述符不应该丢弃。</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span>&amp; a_x = x;      <span class="comment">// int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_cx = cx;    <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_rx = rx;    <span class="comment">// int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_rcx = rcx;  <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_px = px;    <span class="comment">// int*&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_pcx = pcx;  <span class="comment">// const int*&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_cpx = cpx;  <span class="comment">// int *const &amp;</span></span><br><span class="line">  <span class="comment">// auto&amp; a_22 = 22; // error</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_test = test; <span class="comment">// void (&amp;)(int)</span></span><br><span class="line">  <span class="keyword">auto</span>&amp; a_arr = arr;   <span class="comment">// int &amp;[3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="const-auto-amp"><a href="#const-auto-amp" class="headerlink" title="const auto&amp;"></a>const auto&amp;</h4><p>当显示声明CV修饰符时，丢弃CV</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;const reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_x = x;      <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_cx = cx;    <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_rx = rx;    <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_rcx = rcx;  <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_px = px;    <span class="comment">// int *const&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_pcx = pcx;  <span class="comment">// const int *const&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_cpx = cpx;  <span class="comment">// int *const&amp;</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_22 = <span class="number">22</span>;    <span class="comment">// const int&amp;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_test = test; <span class="comment">// void(&amp;)(int)</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; a_arr = arr;   <span class="comment">// const int&amp;[3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="auto-1"><a href="#auto-1" class="headerlink" title="auto*"></a>auto*</h4><p>丢弃指针，丢弃CV，剩下的就是auto的类型</p>
<p>因为变量的类型是auto*，已经有指针了，所以当传进来的变量是指针时，应该忽略指针；变量是指针就表明是一个全新的变量，其CV修饰符应该有自身显示定义，不应该继承其它变量的修饰符，所以CV修饰符应该丢弃。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span>* a_px = px;      <span class="comment">// int*</span></span><br><span class="line">  <span class="keyword">auto</span>* a_pcx = pcx;    <span class="comment">// const int*</span></span><br><span class="line">  <span class="keyword">auto</span>* a_cpx = cpx;    <span class="comment">// int*</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>* a_test = test;  <span class="comment">// void(*)(int)</span></span><br><span class="line">  <span class="keyword">auto</span>* a_arr = arr;    <span class="comment">// int*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="auto-amp-amp"><a href="#auto-amp-amp" class="headerlink" title="auto&amp;&amp;"></a>auto&amp;&amp;</h3><p>表达式为左值时，auto为表达式类型（丢弃引用后）的左值引用；表达式为右值时，auto为表达式类型。（继承CV）</p>
<blockquote>
<blockquote>
<p>注意：auto变量看起来是右值引用，但并不一定是右值引用，只有当表达式为右值时，才是右值引用</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;universal reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_x = x;         <span class="comment">// int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_cx = cx;       <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_rx = rx;       <span class="comment">// int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_rcx = rcx;     <span class="comment">// const int&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_px = px;       <span class="comment">// int*&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_pcx = pcx;     <span class="comment">// const int*&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_cpx = cpx;     <span class="comment">// int *const&amp;</span></span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; a_22 = <span class="number">22</span>;       <span class="comment">// int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-auto-amp-amp"><a href="#const-auto-amp-amp" class="headerlink" title="const auto&amp;&amp;"></a>const auto&amp;&amp;</h3><p>只接收右值，一定是右值引用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;const universal reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; a_22 = <span class="number">22</span>;   <span class="comment">// const int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lambda-capture"><a href="#lambda-capture" class="headerlink" title="lambda capture"></a>lambda capture</h2><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p>引用捕捉，使用模板T&amp;规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;reference capture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> lam = [&amp;x] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam2 = [&amp;cx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam3 = [&amp;rx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam4 = [&amp;rcx] &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_16_14</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_16_14(__lambda_16_14 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_16_14(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_16_14 lam = __lambda_16_14(__lambda_16_14&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_17_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_17_15(__lambda_17_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_17_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_17_15 lam2 = __lambda_17_15(__lambda_17_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_18_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_18_15(__lambda_18_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_18_15(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_18_15 lam3 = __lambda_18_15(__lambda_18_15&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_19_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_19_15(__lambda_19_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_19_15(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_19_15 lam4 = __lambda_19_15(__lambda_19_15&#123;rcx&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>值捕捉，使用模板T规则，但是继承CV！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value capture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> lam = [x] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam2 = [cx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam3 = [rx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam4 = [rcx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam5 = [px] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam6 = [pcx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam7 = [cpx] &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_16_14</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_16_14(__lambda_16_14 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_16_14(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_16_14 lam = __lambda_16_14(__lambda_16_14&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_17_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_17_15(__lambda_17_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_17_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_17_15 lam2 = __lambda_17_15(__lambda_17_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_18_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_18_15(__lambda_18_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_18_15(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_18_15 lam3 = __lambda_18_15(__lambda_18_15&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_19_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_19_15(__lambda_19_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_19_15(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_19_15 lam4 = __lambda_19_15(__lambda_19_15&#123;rcx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_20_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> * px;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_20_15(__lambda_20_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_20_15(<span class="type">int</span> * _px)</span><br><span class="line">    : px&#123;_px&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_20_15 lam5 = __lambda_20_15(__lambda_20_15&#123;px&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_21_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * pcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_21_15(__lambda_21_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_21_15(<span class="type">const</span> <span class="type">int</span> * _pcx)</span><br><span class="line">    : pcx&#123;_pcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_21_15 lam6 = __lambda_21_15(__lambda_21_15&#123;pcx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_22_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> *<span class="type">const</span> cpx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_22_15(__lambda_22_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_22_15(<span class="type">int</span> *<span class="type">const</span> _cpx)</span><br><span class="line">    : cpx&#123;_cpx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_22_15 lam7 = __lambda_22_15(__lambda_22_15&#123;cpx&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="init-capture"><a href="#init-capture" class="headerlink" title="init capture"></a>init capture</h3><p>初始化捕捉，使用auto规则。</p>
<blockquote>
<blockquote>
<p>C++14的扩展，在std&#x3D;c++11时也可使用，但是会报警告warning: initialized lambda captures are a C++14 extension [-Wc++14-extensions]</p>
</blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;init capture&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> lam = [x = x] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam2 = [cx = cx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam3 = [rx = rx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam4 = [rcx = rcx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam5 = [px = px] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam6 = [pcx = pcx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam7 = [cpx = cpx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam8 = [&amp;x = x] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam9 = [&amp;cx = cx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam10 = [&amp;rx = rx] &#123;&#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam11 = [&amp;rcx = rcx] &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_16_14</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_16_14(__lambda_16_14 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_16_14(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_16_14 lam = __lambda_16_14(__lambda_16_14&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_17_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_17_15(__lambda_17_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_17_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_17_15 lam2 = __lambda_17_15(__lambda_17_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_18_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_18_15(__lambda_18_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_18_15(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_18_15 lam3 = __lambda_18_15(__lambda_18_15&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_19_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_19_15(__lambda_19_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_19_15(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_19_15 lam4 = __lambda_19_15(__lambda_19_15&#123;rcx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_20_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> * px;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_20_15(__lambda_20_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_20_15(<span class="type">int</span> * _px)</span><br><span class="line">    : px&#123;_px&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_20_15 lam5 = __lambda_20_15(__lambda_20_15&#123;px&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_21_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * pcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_21_15(__lambda_21_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_21_15(<span class="type">const</span> <span class="type">int</span> * _pcx)</span><br><span class="line">    : pcx&#123;_pcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_21_15 lam6 = __lambda_21_15(__lambda_21_15&#123;pcx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_22_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> * cpx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_22_15(__lambda_22_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_22_15(<span class="type">int</span> * _cpx)</span><br><span class="line">    : cpx&#123;_cpx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_22_15 lam7 = __lambda_22_15(__lambda_22_15&#123;cpx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_23_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_23_15(__lambda_23_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_23_15(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_23_15 lam8 = __lambda_23_15(__lambda_23_15&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_24_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_24_15(__lambda_24_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_24_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_24_15 lam9 = __lambda_24_15(__lambda_24_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_25_16</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_25_16(__lambda_25_16 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_25_16(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_25_16 lam10 = __lambda_25_16(__lambda_25_16&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_26_16</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_26_16(__lambda_26_16 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_26_16(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_26_16 lam11 = __lambda_26_16(__lambda_26_16&#123;rcx&#125;);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype对类型非常敏感，针对标识名和表达式的推断规则是不一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(x)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>((x))&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(*&amp;x)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="标识名"><a href="#标识名" class="headerlink" title="标识名"></a>标识名</h3><p>对于标识名，得到声明的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span>&amp;&amp; rrx = <span class="number">22</span>;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype name&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(x)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;    <span class="comment">// int</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(cx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;   <span class="comment">// int const</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(rx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;   <span class="comment">// int&amp;</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(rcx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;  <span class="comment">// int const&amp;</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(px)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;   <span class="comment">// int*</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(pcx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;  <span class="comment">// const int*</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(cpx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;  <span class="comment">// int* const</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(test)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl; <span class="comment">// void(int)</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(arr)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;  <span class="comment">// int[3]</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(rrx)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;  <span class="comment">// int&amp;&amp;</span></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; boost::typeindex::type_id_with_cvr&lt;decltype(&#123;1, 2, 3&#125;)&gt;().pretty_name() &lt;&lt; std::endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h4 id="亡值"><a href="#亡值" class="headerlink" title="亡值"></a>亡值</h4><p>表达式值为亡值，类型为T&amp;&amp;。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype expr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(x))&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl; <span class="comment">// int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h4><p>表达式值为左值，类型为T&amp;。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype expr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>((x))&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;    <span class="comment">// int&amp;</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(*&amp;x)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;    <span class="comment">// int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="纯右值"><a href="#纯右值" class="headerlink" title="纯右值"></a>纯右值</h4><p>表达式值为纯右值，类型为T。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;decltype expr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::<span class="built_in">type_id_with_cvr</span>&lt;<span class="keyword">decltype</span>(<span class="number">22</span>)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl;     <span class="comment">// int</span></span><br><span class="line">  std::cout &lt;&lt; boost::typeindex::type_id_with_cvr&lt;<span class="keyword">decltype</span>(std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;())&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; std::endl; <span class="comment">// std::shared_ptr&lt;int&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="function-return"><a href="#function-return" class="headerlink" title="function return"></a>function return</h2><h3 id="lambda-function"><a href="#lambda-function" class="headerlink" title="lambda function"></a>lambda function</h3><p>使用模板T的规则，去掉CVR，剩下的就是函数返回类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">22</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> cx = x;</span><br><span class="line">  <span class="type">int</span>&amp; rx = x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>&amp; rcx = cx;</span><br><span class="line">  <span class="type">int</span>* px = &amp;x;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>* pcx = &amp;cx;</span><br><span class="line">  <span class="type">int</span>* <span class="type">const</span> cpx = &amp;x;</span><br><span class="line">  <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;lambda function return&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> lam = [x] &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam2 = [cx] &#123; <span class="keyword">return</span> cx; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam3 = [rx] &#123; <span class="keyword">return</span> rx; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam4 = [rcx] &#123; <span class="keyword">return</span> rcx; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam8 = [&amp;x = x] &#123; <span class="keyword">return</span> x; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam9 = [&amp;cx = cx] &#123; <span class="keyword">return</span> cx; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam10 = [&amp;rx = rx] &#123; <span class="keyword">return</span> rx; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> lam11 = [&amp;rcx = rcx] &#123; <span class="keyword">return</span> rcx; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_16_14</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_16_14(__lambda_16_14 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_16_14(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_16_14 lam = __lambda_16_14(__lambda_16_14&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_17_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_17_15(__lambda_17_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_17_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_17_15 lam2 = __lambda_17_15(__lambda_17_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_18_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_18_15(__lambda_18_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_18_15(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_18_15 lam3 = __lambda_18_15(__lambda_18_15&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_19_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rcx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_19_15(__lambda_19_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_19_15(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_19_15 lam4 = __lambda_19_15(__lambda_19_15&#123;rcx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_20_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; x;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_20_15(__lambda_20_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_20_15(<span class="type">int</span> &amp; _x)</span><br><span class="line">    : x&#123;_x&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_20_15 lam8 = __lambda_20_15(__lambda_20_15&#123;x&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_21_15</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; cx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_21_15(__lambda_21_15 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_21_15(<span class="type">const</span> <span class="type">int</span> &amp; _cx)</span><br><span class="line">    : cx&#123;_cx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_21_15 lam9 = __lambda_21_15(__lambda_21_15&#123;cx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_22_16</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">int</span> &amp; rx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_22_16(__lambda_22_16 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_22_16(<span class="type">int</span> &amp; _rx)</span><br><span class="line">    : rx&#123;_rx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_22_16 lam10 = __lambda_22_16(__lambda_22_16&#123;rx&#125;);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">__lambda_23_16</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> rcx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; rcx;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// inline /*constexpr */ __lambda_23_16(__lambda_23_16 &amp;&amp;) noexcept = default;</span></span><br><span class="line">    __lambda_23_16(<span class="type">const</span> <span class="type">int</span> &amp; _rcx)</span><br><span class="line">    : rcx&#123;_rcx&#125;</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  __lambda_23_16 lam11 = __lambda_23_16(__lambda_23_16&#123;rcx&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="auto-2"><a href="#auto-2" class="headerlink" title="auto"></a>auto</h3><p>返回类型是auto时，使用auto规则。</p>
<h4 id="C-11-2"><a href="#C-11-2" class="headerlink" title="C++11"></a>C++11</h4><p>在C++11上，只能通过返回值后置来实现，局限太大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Add</span><span class="params">(U u, T t)</span> -&gt; <span class="title">decltype</span><span class="params">(u + t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> val = u + t;</span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-14-2"><a href="#C-14-2" class="headerlink" title="C++14"></a>C++14</h4><p>在C++14后只需要返回类型写auto就可以了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lookupvalue</span><span class="params">(<span class="type">const</span> <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> values[index];  <span class="comment">// int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p>返回类型是decltype(auto)时，使用decltype规则。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lookupvalue2</span><span class="params">(<span class="type">const</span> <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> values[index]; <span class="comment">// int&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">lookupvalue4</span><span class="params">(<span class="type">const</span> <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> val = values[index];</span><br><span class="line">  <span class="keyword">return</span> (val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>libc++源码分析之std::allocator</title>
    <url>/2022/02/03/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Ballocator/</url>
    <content><![CDATA[<h1 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h1><p>默认的内存分配器，负责内存的分配和销毁</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h3><p>分配内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span></span><br><span class="line"><span class="function"><span class="type">const</span> _Tp* <span class="title">allocate</span><span class="params">(<span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; allocator_traits&lt;allocator&gt;::<span class="built_in">max_size</span>(*<span class="keyword">this</span>))</span><br><span class="line">        __throw_length_error(<span class="string">&quot;allocator&lt;const T&gt;::allocate(size_t n)&quot;</span></span><br><span class="line">                             <span class="string">&quot; &#x27;n&#x27; exceeds maximum supported size&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (__libcpp_is_constant_evaluated()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Tp*&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(__n * <span class="built_in">sizeof</span>(_Tp)));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">const</span> _Tp*&gt;(_VSTD::__libcpp_allocate(__n * <span class="built_in">sizeof</span>(_Tp), _LIBCPP_ALIGNOF(_Tp)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h3><p>销毁内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">const</span> _Tp* __p, <span class="type">size_t</span> __n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__libcpp_is_constant_evaluated()) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">const_cast</span>&lt;_Tp*&gt;(__p))</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _VSTD::__libcpp_deallocate((<span class="type">void</span>*) <span class="built_in">const_cast</span>&lt;_Tp *&gt;(__p), __n * <span class="built_in">sizeof</span>(_Tp), _LIBCPP_ALIGNOF(_Tp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_DEPRECATED_IN_CXX17</span> rebind &#123;</span><br><span class="line">    <span class="keyword">typedef</span> allocator&lt;_Up&gt; other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="address"><a href="#address" class="headerlink" title="address"></a>address</h3><p>引用的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">const_pointer <span class="title">address</span><span class="params">(const_reference __x)</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::<span class="built_in">addressof</span>(__x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h3><p>对象最大分配的数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_INLINE_VISIBILITY size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size_type</span>(~<span class="number">0</span>) / <span class="built_in">sizeof</span>(_Tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p>调用对象的指定参数的构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="function">_LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(_Up* __p, _Args&amp;&amp;... __args)</span> </span>&#123;</span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span>*)__p) _Up(_VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><p>调用对象的析构函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_DEPRECATED_IN_CXX17 _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer __p)</span> </span>&#123;</span><br><span class="line">    __p-&gt;~_Tp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="std-allocator-traits"><a href="#std-allocator-traits" class="headerlink" title="std::allocator_traits"></a>std::allocator_traits</h1><p>允许自定义allocator实现，std::allocator只是默认实现，std::allocator_traits定义了allocator接口，自定义的allocator需要满足std::allocator_traits。</p>
<p>对于使用者来说，比如vector，会用std::allocator_traits来调用外部传递进来的allocator，而不会直接去使用allocator。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> allocator_traits</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> allocator_type = _Alloc;  <span class="comment">// 具体的allocator实现</span></span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> allocator_type::value_type; <span class="comment">// allocator管理的对象类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="allocate-1"><a href="#allocate-1" class="headerlink" title="allocate"></a>allocate</h3><p>通过allocator_traits来调用allocator的allocate函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span></span><br><span class="line"><span class="function"><span class="type">static</span> pointer <span class="title">allocate</span><span class="params">(allocator_type&amp; __a, size_type __n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __a.<span class="built_in">allocate</span>(__n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="deallocate-1"><a href="#deallocate-1" class="headerlink" title="deallocate"></a>deallocate</h3><p>通过allocator_traits来调用allocator的deallocate函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(allocator_type&amp; __a, pointer __p, size_type __n)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    __a.<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之std::__compressed_pair</title>
    <url>/2022/02/01/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bcompressed_pair/</url>
    <content><![CDATA[<h1 id="compressed-pair"><a href="#compressed-pair" class="headerlink" title="compressed_pair"></a>compressed_pair</h1><p>与pair相比，compressed_pair提供了空类优化，节省了空类的内存</p>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>看pair的实现可以看到，将first和second都作为属性进行保存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> pair : <span class="keyword">private</span> __non_trivially_copyable_base&lt;_T1, _T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _T1 first_type;</span><br><span class="line">    <span class="keyword">typedef</span> _T2 second_type;</span><br><span class="line"></span><br><span class="line">    _T1 first;</span><br><span class="line">    _T2 second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在下面的例子中，对于pair来说，A和B都是其属性，A类是空类，sizeof为1，B类sizeof为4，字节对齐后，整个pair是8，这就是空类所带来的内存浪费。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::pair&lt;A, B&gt; p;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">sizeof</span>(p);  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    std::__compressed_pair&lt;A, B&gt; cp;</span><br><span class="line">    <span class="type">int</span> size2 = <span class="built_in">sizeof</span>(cp); <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="compressed-pair-1"><a href="#compressed-pair-1" class="headerlink" title="compressed_pair"></a>compressed_pair</h2><p>compressed_pair通过继承优化了空类所带来的内存浪费，在上面的例子中compressed_pair继承了A和B，对于compressed_pair来说只有基类B有一个int属性，所以sizeof为4。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__compressed_pair</span> : <span class="keyword">private</span> __compressed_pair_elem&lt;_T1, <span class="number">0</span>&gt;,</span><br><span class="line">                          <span class="keyword">private</span> __compressed_pair_elem&lt;_T2, <span class="number">1</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __compressed_pair_elem&lt;_T1, <span class="number">0</span>&gt; _Base1;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE __compressed_pair_elem&lt;_T2, <span class="number">1</span>&gt; _Base2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_U1</span>, <span class="keyword">class</span> <span class="title class_">_U2</span>&gt;</span><br><span class="line">  _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line">  __compressed_pair(_U1&amp;&amp; __t1, _U2&amp;&amp; __t2)</span><br><span class="line">      : _Base1(_VSTD::forward&lt;_U1&gt;(__t1)), _Base2(_VSTD::forward&lt;_U2&gt;(__t2)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="keyword">typename</span> _Base1::reference <span class="title">first</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Base1&amp;&gt;(*<span class="keyword">this</span>).__get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">  <span class="keyword">typename</span> _Base2::reference <span class="title">second</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Base2&amp;&gt;(*<span class="keyword">this</span>).__get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之new和delete</title>
    <url>/2021/07/07/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bnew%E5%92%8Cdelete/</url>
    <content><![CDATA[<h1 id="示例：new-x2F-delete-一个对象"><a href="#示例：new-x2F-delete-一个对象" class="headerlink" title="示例：new&#x2F;delete 一个对象"></a>示例：new&#x2F;delete 一个对象</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  std::string* str = <span class="keyword">new</span> std::<span class="built_in">string</span>();</span><br><span class="line">  <span class="keyword">delete</span> str;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    <span class="number">0x108852450</span> &lt;+<span class="number">0</span>&gt;:   pushq  %rbp</span><br><span class="line">    <span class="number">0x108852451</span> &lt;+<span class="number">1</span>&gt;:   <span class="keyword">movq</span>   %rsp, %rbp</span><br><span class="line">    <span class="number">0x108852454</span> &lt;+<span class="number">4</span>&gt;:   subq   <span class="number">$0</span>x30, %rsp</span><br><span class="line">    <span class="number">0x108852458</span> &lt;+<span class="number">8</span>&gt;:   movl   <span class="number">$0</span>x0, -<span class="number">0x4</span>(%rbp)</span><br><span class="line">    <span class="number">0x10885245f</span> &lt;+<span class="number">15</span>&gt;:  movl   %edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line">    <span class="number">0x108852462</span> &lt;+<span class="number">18</span>&gt;:  <span class="keyword">movq</span>   %rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line">    <span class="number">0x108852466</span> &lt;+<span class="number">22</span>&gt;:  movl   <span class="number">$0</span>x18, %edi</span><br><span class="line">    <span class="number">0x10885246b</span> &lt;+<span class="number">27</span>&gt;:  callq  <span class="number">0x1088c26c6</span>               <span class="comment">; symbol stub for: operator new(unsigned long)</span></span><br><span class="line">    <span class="number">0x108852470</span> &lt;+<span class="number">32</span>&gt;:  <span class="keyword">movq</span>   %rax, %rdi</span><br><span class="line">    <span class="number">0x108852473</span> &lt;+<span class="number">35</span>&gt;:  <span class="keyword">movq</span>   %rax, -<span class="number">0x20</span>(%rbp)</span><br><span class="line">    <span class="number">0x108852477</span> &lt;+<span class="number">39</span>&gt;:  callq  <span class="number">0x1088524c0</span>               <span class="comment">; std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::basic_string at string:1725</span></span><br><span class="line">    <span class="number">0x10885247c</span> &lt;+<span class="number">44</span>&gt;:  <span class="keyword">movq</span>   -<span class="number">0x20</span>(%rbp), %rax</span><br><span class="line">    <span class="number">0x108852480</span> &lt;+<span class="number">48</span>&gt;:  <span class="keyword">movq</span>   %rax, -<span class="number">0x18</span>(%rbp)</span><br><span class="line">    <span class="number">0x108852484</span> &lt;+<span class="number">52</span>&gt;:  <span class="keyword">movq</span>   -<span class="number">0x18</span>(%rbp), %rcx</span><br><span class="line">    <span class="number">0x108852488</span> &lt;+<span class="number">56</span>&gt;:  cmpq   <span class="number">$0</span>x0, %rcx</span><br><span class="line">    <span class="number">0x10885248c</span> &lt;+<span class="number">60</span>&gt;:  <span class="keyword">movq</span>   %rcx, -<span class="number">0x28</span>(%rbp)</span><br><span class="line">    <span class="number">0x108852490</span> &lt;+<span class="number">64</span>&gt;:  <span class="keyword">je</span>     <span class="number">0x1088524ab</span>               <span class="comment">; &lt;+91&gt; at main.cpp</span></span><br><span class="line">    <span class="number">0x108852496</span> &lt;+<span class="number">70</span>&gt;:  <span class="keyword">movq</span>   -<span class="number">0x28</span>(%rbp), %rdi</span><br><span class="line">    <span class="number">0x10885249a</span> &lt;+<span class="number">74</span>&gt;:  callq  <span class="number">0x1088c240e</span>               <span class="comment">; symbol stub for: std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;::~basic_string()</span></span><br><span class="line">    <span class="number">0x10885249f</span> &lt;+<span class="number">79</span>&gt;:  <span class="keyword">movq</span>   -<span class="number">0x28</span>(%rbp), %rax</span><br><span class="line">    <span class="number">0x1088524a3</span> &lt;+<span class="number">83</span>&gt;:  <span class="keyword">movq</span>   %rax, %rdi</span><br><span class="line">    <span class="number">0x1088524a6</span> &lt;+<span class="number">86</span>&gt;:  callq  <span class="number">0x1088c26b4</span>               <span class="comment">; symbol stub for: operator delete(void*)</span></span><br><span class="line">    <span class="number">0x1088524ab</span> &lt;+<span class="number">91</span>&gt;:  xorl   %eax, %eax</span><br><span class="line">-&gt;  <span class="number">0x1088524ad</span> &lt;+<span class="number">93</span>&gt;:  addq   <span class="number">$0</span>x30, %rsp</span><br><span class="line">    <span class="number">0x1088524b1</span> &lt;+<span class="number">97</span>&gt;:  popq   %rbp</span><br><span class="line">    <span class="number">0x1088524b2</span> &lt;+<span class="number">98</span>&gt;:  retq   </span><br><span class="line">    <span class="number">0x1088524b3</span> &lt;+<span class="number">99</span>&gt;:  nopw   %cs:(%rax,%rax)</span><br><span class="line">    <span class="number">0x1088524bd</span> &lt;+<span class="number">109</span>&gt;: nopl   (%rax)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><em>new</em>关键字会触发三个步骤：</p>
<ol>
<li>调用函数operator new分配内存</li>
<li>调用对象的构造函数</li>
<li>返回对象的纯右值指针</li>
</ol>
<p><em>delete</em>关键字会触发两个步骤</p>
<ol>
<li>调用对象的析构函数</li>
<li>调用函数operator delete释放内存</li>
</ol>
<h1 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h1><p>operator new函数负责实现内存的分配，分为全局实现和对象实现，可以通过重写该函数来自定义内存的分配。</p>
<h2 id="STL实现"><a href="#STL实现" class="headerlink" title="STL实现"></a>STL实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span></span>;                                   <span class="comment">// replaceable, nodiscard in C++20</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::<span class="type">align_val_t</span> alignment)</span></span>;       <span class="comment">// replaceable, C++17, nodiscard in C++20</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// replaceable, nodiscard in C++20</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::<span class="type">align_val_t</span> alignment,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;                     <span class="comment">// replaceable, C++17, nodiscard in C++20</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span>  <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span>;             <span class="comment">// nodiscard in C++20</span></span><br></pre></td></tr></table></figure>

<p><strong>operator new(std::size_t size)</strong><br>最常用的实现，其中的size就是要分配的内存大小，如果size是0也就是空类，那么会默认分配1个字节的内存。默认分配内存是通过malloc来实现的，如果分配失败则会调用get_new_handler函数，然后再次尝试分配内存，所以可以通过注册get_new_handler函数当内存不足时进行内存释放。在默认的实现中，如果开启了exception，则分配失败会抛出std::bad_alloc异常，否则会返回nullptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size)</span> _THROW_BAD_ALLOC</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>* p;</span><br><span class="line">    <span class="keyword">while</span> ((p = ::<span class="built_in">malloc</span>(size)) == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If malloc fails and there is a new_handler,</span></span><br><span class="line">        <span class="comment">// call it to try free up memory.</span></span><br><span class="line">        std::new_handler nh = std::<span class="built_in">get_new_handler</span>();</span><br><span class="line">        <span class="keyword">if</span> (nh)</span><br><span class="line">            <span class="built_in">nh</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator new(std::size_t size, const std::nothrow_t&amp;) noexcept</strong><br>该重载是针对不想使用异常的情况，在该实现内部会自己捕捉异常，失败会直接返回nullptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span>* p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">        p = ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em><em>operator new(std::size_t size, void</em> ptr) noexcept</em>*<br>该重载就是placement new，多了一个指针参数，在该实现中不会分配内存，而是使用现有已分配内存，可以看出实现就是简单的返回参数指针。使用placement new可以方便的控制内存的分配，在STL内部大量的使用了该方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span>  <span class="params">(std::<span class="type">size_t</span>, <span class="type">void</span>* __p)</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __p;&#125;</span><br></pre></td></tr></table></figure>

<p>在下面的示例中通过malloc自己分配了内存，然后通过placement new调用了A的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A* a = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A)));</span><br><span class="line">a = <span class="built_in">new</span> (a) <span class="built_in">A</span>();</span><br></pre></td></tr></table></figure>


<p><strong>operator new(std::size_t size, std::align_val_t alignment)</strong><br>该重载是C++17添加的新函数，align_val_t参数可以强制内存对齐。*<strong>STDCPP_DEFAULT_NEW_ALIGNMENT</strong>*是默认的内存对齐值，也就是new的地址是该值的倍数。 通过align_val_t参数可以指定new的内存对齐。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span> size, std::<span class="type">align_val_t</span> alignment)</span> _THROW_BAD_ALLOC</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(alignment) &lt; <span class="built_in">sizeof</span>(<span class="type">void</span>*))</span><br><span class="line">      alignment = std::<span class="built_in">align_val_t</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try allocating memory. If allocation fails and there is a new_handler,</span></span><br><span class="line">    <span class="comment">// call it to try free up memory, and try again until it succeeds, or until</span></span><br><span class="line">    <span class="comment">// the new_handler decides to terminate.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If allocation fails and there is no new_handler, we throw bad_alloc</span></span><br><span class="line">    <span class="comment">// (or return nullptr if exceptions are disabled).</span></span><br><span class="line">    <span class="type">void</span>* p;</span><br><span class="line">    <span class="keyword">while</span> ((p = std::__libcpp_aligned_alloc(<span class="built_in">static_cast</span>&lt;std::<span class="type">size_t</span>&gt;(alignment), size)) == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::new_handler nh = std::<span class="built_in">get_new_handler</span>();</span><br><span class="line">        <span class="keyword">if</span> (nh)</span><br><span class="line">            <span class="built_in">nh</span>();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面的示例中将aligned_int对象的内存对齐指定为128，则分配的地址一定是128的倍数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* aligned_int = <span class="built_in">new</span> (std::<span class="built_in">align_val_t</span>(<span class="number">128</span>)) <span class="type">int</span>;</span><br><span class="line"><span class="type">bool</span> b = <span class="built_in">intptr_t</span>(aligned_int) % <span class="number">128</span> == <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>operator new(std::size_t size, std::align_val_t alignment, const std::nothrow_t&amp;) noexcept</strong><br>该重载是上面的无异常版本，内部会捕捉异常。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>C++11后，可以通过alignas关键字来改变对齐值，通过alignof来查询对齐值。</p>
<p>默认情况下，struct按照内部最大类型来进行对齐，在Align结构体中，最大类型是int，所以其对齐值为4。char占1个字节，后面补上3个0字节，int占4个字节，所以sizeeof为8。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Align</span> &#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> align2 = <span class="built_in">alignof</span>(align); <span class="comment">// 4</span></span><br><span class="line"><span class="type">size_t</span> size2 = <span class="built_in">sizeof</span>(align); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// a000 bbbb </span></span><br></pre></td></tr></table></figure>

<p>通过alignas设置结构体的对齐值位16，char占1个字节，后面补上3个0字节，int占4个字节，后面补上8个0字节，所以sizeof为16。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">16</span>)  Align &#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> align2 = <span class="built_in">alignof</span>(align); <span class="comment">// 16</span></span><br><span class="line"><span class="type">size_t</span> size2 = <span class="built_in">sizeof</span>(align); <span class="comment">// 16</span></span><br><span class="line"><span class="comment">// a000 bbbb 0000 0000</span></span><br></pre></td></tr></table></figure>

<p>通过alignas设置结构体内部int的对齐值为8，则结构体最大对齐值为8，char占1个字节，后面补上7个0字节，int占4个字节，后面补上4个0字节，所以sizeof为16。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Align</span> &#123;</span><br><span class="line">  <span class="type">char</span> a;</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="number">8</span>) <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> align2 = <span class="built_in">alignof</span>(align); <span class="comment">// 8</span></span><br><span class="line"><span class="type">size_t</span> size2 = <span class="built_in">sizeof</span>(align); <span class="comment">// 16</span></span><br><span class="line"><span class="comment">// c000 0000 bbbb 0000</span></span><br></pre></td></tr></table></figure>

<p>通过alignas设置结构体内部char的对齐值为8，则结构体最大对齐值为8，char占1一个字节，后面有7个字节的空位，int占4个字节，完全够用，则int直接在这次对齐内分配，不需要重新再起一行，所以sizeof为8。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Align</span> &#123;</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="number">8</span>) <span class="type">char</span> a;</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">size_t</span> align2 = <span class="built_in">alignof</span>(align); <span class="comment">// 8</span></span><br><span class="line"><span class="type">size_t</span> size2 = <span class="built_in">sizeof</span>(align); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// c000 bbbb</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>operator new函数时可以自定义的，分为全局自定义和对象自定义，全局自定义的operator new会导致所有的对象的new都应用该自定义函数。而对象自定义只会影响到该对象创建。当两种实现都自定义时，对象自定义优先。</p>
<p>全局自定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">void</span>* pVoid = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">return</span> pVoid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象自定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="operator-new-1"><a href="#operator-new-1" class="headerlink" title="operator new[]"></a>operator new[]</h1><p>operator new[]函数负责实现数组内存的分配，同样也分为全局实现和对象实现，可以通过重写该函数来自定义内存的分配。</p>
<h2 id="长度信息存储"><a href="#长度信息存储" class="headerlink" title="长度信息存储"></a>长度信息存储</h2><p>当创建的对象定义了析构函数时，为了在delete[] 时能够循环的调用每一个对象的析构函数，那么在new[]分配内存时会多分配一段内存，在这段内存中存储当前数据的长度信息，所以当new[]一个带析构函数的对象数组时，operator new[]的size参数会比整个数组长度要大，并且我们得到的数组指针并不是返回的void*地址，而是一个去掉前面一段的偏移地址。</p>
<p>在下面的实例中，当Align定义了析构函数时，size的值是11，当Align没有定义析构时，size的值是3。所以在这里用来存储数组长度的区域为8个字节，malloc分配的地址是0x7f8e40504b40，返回给a的地址是偏移8个字节后的0x7f8e40504b48。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;call global new[] size: &quot;</span> &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">void</span>* pVoid = <span class="built_in">malloc</span>(size); <span class="comment">// 0x7f8e40504b40</span></span><br><span class="line">  <span class="keyword">return</span> pVoid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Align</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Align</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  Align* a = <span class="keyword">new</span> Align[<span class="number">3</span>]; <span class="comment">// 0x7f8e40504b48</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="STL实现-1"><a href="#STL实现-1" class="headerlink" title="STL实现"></a>STL实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size);                                 <span class="comment">// replaceable, nodiscard in C++20</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size,</span><br><span class="line">                     std::<span class="type">align_val_t</span> alignment) <span class="keyword">noexcept</span>;              <span class="comment">// replaceable, C++17, nodiscard in C++20</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>; <span class="comment">// replaceable, nodiscard in C++20</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size, std::<span class="type">align_val_t</span> alignment,</span><br><span class="line">                     <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;                   <span class="comment">// replaceable, C++17, nodiscard in C++20</span></span><br><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr) <span class="keyword">noexcept</span>;             <span class="comment">// nodiscard in C++20</span></span><br></pre></td></tr></table></figure>

<p>operator new[]的实现默认都是直接调用operator new来分配，这里就不展开了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) _THROW_BAD_ALLOC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义实现-1"><a href="#自定义实现-1" class="headerlink" title="自定义实现"></a>自定义实现</h2><p>全局自定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123;</span><br><span class="line">  <span class="type">void</span>* pVoid = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">return</span> pVoid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象自定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123;</span><br><span class="line">  	<span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>[](size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="operator-delete"><a href="#operator-delete" class="headerlink" title="operator delete"></a>operator delete</h1><p>operator delete函数负责实现内存的释放，分为全局实现和对象实现，可以通过重写该函数来自定义内存的分配。operator delete需要和operator new配套实现，调用什么参数的operator new，内部在失败释放的时候就会调用什么参数的operator delete。</p>
<h2 id="STL实现-2"><a href="#STL实现-2" class="headerlink" title="STL实现"></a>STL实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span>;                              <span class="comment">// replaceable</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, std::<span class="type">size_t</span> size)</span> <span class="keyword">noexcept</span></span>;            <span class="comment">// replaceable, C++14</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, std::<span class="type">align_val_t</span> alignment)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, std::<span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::<span class="type">align_val_t</span> alignment)</span> <span class="keyword">noexcept</span></span>;             <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;       <span class="comment">// replaceable</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, std:<span class="type">align_val_t</span> alignment,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;                  <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">(<span class="type">void</span>* ptr, <span class="type">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>


<p><em><em>operator delete(void</em> ptr) noexcept</em>*<br>operator delete函数默认的实现是调用free来进行内存的释放，之所以free能够正确的释放，是因为在malloc得到的地址其实是一个handler，在内部都有一个私有簿记（book keeping）区域来记录每个handler对应的内存区域是多大。所以malloc和free必须要配套使用，这样才能正确的释放内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><em>operator delete(void</em> ptr, const std::nothrow_t&amp;) noexcept</em>*</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><em>operator delete(void</em> ptr, void</em>) noexcept**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>  <span class="keyword">operator</span> <span class="title">delete</span>  <span class="params">(<span class="type">void</span>*, <span class="type">void</span>*)</span> _NOEXCEPT </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="operator-delete-1"><a href="#operator-delete-1" class="headerlink" title="operator delete[]"></a>operator delete[]</h1><p>operator delete[]函数负责实现数组内存的释放，同样也分为全局实现和对象实现，可以通过重写该函数来自定义内存的分配。delete[]和new[]一样，对于拥有析构函数对象的数组，其前面会有一段内存用来存储数组长度，但是传递到operator delete[]函数上时，是去掉偏移值的地址。</p>
<h2 id="STL实现-3"><a href="#STL实现-3" class="headerlink" title="STL实现"></a>STL实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr) <span class="keyword">noexcept</span>;                            <span class="comment">// replaceable</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, std::<span class="type">size_t</span> size) <span class="keyword">noexcept</span>;          <span class="comment">// replaceable, C++14</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr,</span><br><span class="line">                        std::<span class="type">align_val_t</span> alignment) <span class="keyword">noexcept</span>;           <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, std::<span class="type">size_t</span> size,</span><br><span class="line">                        std::<span class="type">align_val_t</span> alignment) <span class="keyword">noexcept</span>;           <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;     <span class="comment">// replaceable</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, std::<span class="type">align_val_t</span> alignment,</span><br><span class="line">                        <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;                <span class="comment">// replaceable, C++17</span></span><br><span class="line"><span class="type">void</span>  <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, <span class="type">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之std::shared_ptr</title>
    <url>/2021/07/20/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bshared_ptr/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="keyword">typedef</span> weak_ptr&lt;T&gt; weak_type; <span class="comment">// C++17</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors:</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">shared_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(Y* p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="title">shared_ptr</span><span class="params">(Y* p, D d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D, <span class="keyword">class</span> A&gt; <span class="title">shared_ptr</span><span class="params">(Y* p, D d, A a)</span></span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">D</span>&gt; <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span> p, D d);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">D</span>, <span class="keyword">class</span> <span class="title class_">A</span>&gt; <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span> p, D d, A a);</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r, T *p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; r) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(shared_ptr&amp;&amp; r) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="title">shared_ptr</span><span class="params">(shared_ptr&lt;Y&gt;&amp;&amp; r)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(<span class="type">const</span> weak_ptr&lt;Y&gt;&amp; r)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="title">shared_ptr</span><span class="params">(auto_ptr&lt;Y&gt;&amp;&amp; r)</span></span>;          <span class="comment">// removed in C++17</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>, <span class="keyword">class</span> <span class="title class_">D</span>&gt; <span class="built_in">shared_ptr</span>(unique_ptr&lt;Y, D&gt;&amp;&amp; r);</span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">nullptr_t</span>) : <span class="built_in">shared_ptr</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor:</span></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment:</span></span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; r) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; shared_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;Y&gt;&amp; r) <span class="keyword">noexcept</span>;</span><br><span class="line">    shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&amp;&amp; r) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; shared_ptr&amp; <span class="keyword">operator</span>=(shared_ptr&lt;Y&gt;&amp;&amp; r);</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Y</span>&gt; shared_ptr&amp; <span class="keyword">operator</span>=(auto_ptr&lt;Y&gt;&amp;&amp; r); <span class="comment">// removed in C++17</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Y</span>, <span class="keyword">class</span> <span class="title class_">D</span>&gt; shared_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;Y, D&gt;&amp;&amp; r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modifiers:</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(shared_ptr&amp; r)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y&gt; <span class="type">void</span> <span class="title">reset</span><span class="params">(Y* p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D&gt; <span class="type">void</span> <span class="title">reset</span><span class="params">(Y* p, D d)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Y, <span class="keyword">class</span> D, <span class="keyword">class</span> A&gt; <span class="type">void</span> <span class="title">reset</span><span class="params">(Y* p, D d, A a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// observers:</span></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">noexcept</span>;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unique</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="type">bool</span> <span class="title">owner_before</span><span class="params">(shared_ptr&lt;U&gt; <span class="type">const</span>&amp; b)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt; <span class="type">bool</span> <span class="title">owner_before</span><span class="params">(weak_ptr&lt;U&gt; <span class="type">const</span>&amp; b)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="引用计数块"><a href="#引用计数块" class="headerlink" title="引用计数块"></a>引用计数块</h2><p>shared_ptr与unique_ptr的区别在于，shared_ptr内部会创建一个引用计数块，多个shared_ptr对象可以共享同一个引用计数块，来达到对同一个指针的状态进行共享的目的。</p>
<h3 id="shared-count"><a href="#shared-count" class="headerlink" title="__shared_count"></a>__shared_count</h3><p>shared_count定义了引用计数块的基本接口，__shared_owners_用来记录引用数，__add_shared函数用来对引用计数+1，__release_shared用来对引用计数-1，每一次操作都是原子操作。当引用计数归0的时候，会调用__on_zero_shared来进行销毁操作。use_count用来查询当前的引用计数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_count</span></span><br><span class="line">&#123;</span><br><span class="line">    __shared_count(<span class="type">const</span> __shared_count&amp;);</span><br><span class="line">    __shared_count&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __shared_count&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">long</span> __shared_owners_; <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_count();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_owners_(__refs) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_LIBCPP_BUILDING_LIBRARY) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)</span></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT;</span><br><span class="line">    <span class="type">bool</span> __release_shared() _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 引用计数+1</span></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_owners_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 引用计数-1，如果归0则调用__on_zero_shared</span></span><br><span class="line">    <span class="type">bool</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_owners_) == <span class="number">-1</span>) &#123;</span><br><span class="line">        __on_zero_shared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 返回引用计数</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __libcpp_relaxed_load(&amp;__shared_owners_) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="shared-weak-count"><a href="#shared-weak-count" class="headerlink" title="__shared_weak_count"></a>__shared_weak_count</h3><p>__shared_weak_count是__shared_count的派生类，在其基础上，定义了弱引用计数的接口。__shared_weak_owners_用来记录弱引用数，__add_weak函数用来对弱引用计数+1，__release_weak用来对弱引用计数-1，每一次操作都是原子操作。当弱引用计数归0或者强引用计数归0的时候，会调用__on_zero_shared_weak。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_weak_count</span></span><br><span class="line">    : <span class="keyword">private</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> __shared_weak_owners_; <span class="comment">// 弱引用计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __shared_weak_count(<span class="type">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_count(__refs),</span><br><span class="line">          __shared_weak_owners_(__refs) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_weak_count();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_LIBCPP_BUILDING_LIBRARY) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(_LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS)</span></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT;</span><br><span class="line">    <span class="type">void</span> __add_weak() _NOEXCEPT;</span><br><span class="line">    <span class="type">void</span> __release_shared() _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __shared_count::__add_shared();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 弱引用计数+1</span></span><br><span class="line">    <span class="type">void</span> __add_weak() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_weak_owners_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果强引用计数归0，则调用__release_weak</span></span><br><span class="line">    <span class="type">void</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__shared_count::__release_shared())</span><br><span class="line">        __release_weak();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">void</span> __release_weak() _NOEXCEPT;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __shared_count::<span class="built_in">use_count</span>();&#125;</span><br><span class="line">    <span class="function">__shared_weak_count* <span class="title">lock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> <span class="type">void</span>* __get_deleter(<span class="type">const</span> type_info&amp;) <span class="type">const</span> _NOEXCEPT;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用计数-1，如果归0，则调用__on_zero_shared_weak</span></span><br><span class="line"><span class="type">void</span> __shared_weak_count::__release_weak() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__libcpp_atomic_load(&amp;__shared_weak_owners_, _AO_Acquire) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __on_zero_shared_weak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_weak_owners_) == <span class="number">-1</span>)</span><br><span class="line">        __on_zero_shared_weak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果强引用计数没有归0，则强引用计数+1</span></span><br><span class="line"><span class="function">__shared_weak_count* <span class="title">__shared_weak_count::lock</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> object_owners = __libcpp_atomic_load(&amp;__shared_owners_);</span><br><span class="line">    <span class="keyword">while</span> (object_owners != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__libcpp_atomic_compare_exchange(&amp;__shared_owners_,</span><br><span class="line">                                             &amp;object_owners,</span><br><span class="line">                                             object_owners+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr-pointer"><a href="#shared-ptr-pointer" class="headerlink" title="__shared_ptr_pointer"></a>__shared_ptr_pointer</h3><p>__shared_ptr_pointer是引用计数块的实现类，派生自__shared_weak_count。模板参数_Tp为维护的对象类型，_Dp为删除器，_Alloc为分配器，__data_用来存储了这三个参数值。负责实现__on_zero_shared和__on_zero_shared_weak。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__shared_ptr_pointer</span></span><br><span class="line">    : <span class="keyword">public</span> __shared_weak_count</span><br><span class="line">&#123;</span><br><span class="line">    __compressed_pair&lt;__compressed_pair&lt;_Tp, _Dp&gt;, _Alloc&gt; __data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)</span><br><span class="line">        :  __data_(__compressed_pair&lt;_Tp, _Dp&gt;(__p, _VSTD::<span class="built_in">move</span>(__d)), _VSTD::<span class="built_in">move</span>(__a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_RTTI</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> <span class="type">void</span>* __get_deleter(<span class="type">const</span> type_info&amp;) <span class="type">const</span> _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared() _NOEXCEPT;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __on_zero_shared_weak() _NOEXCEPT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强引用计数归0时，进行销毁，将维护的指针交给删除器进行删除，然后调用删除器的析构销毁删除器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> __shared_ptr_pointer&lt;_Tp, _Dp, _Alloc&gt;::__on_zero_shared() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    __data_.<span class="built_in">first</span>().<span class="built_in">second</span>()(__data_.<span class="built_in">first</span>().<span class="built_in">first</span>());</span><br><span class="line">    __data_.<span class="built_in">first</span>().<span class="built_in">second</span>().~_Dp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱引用计数归0时，销毁分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="type">void</span> __shared_ptr_pointer&lt;_Tp, _Dp, _Alloc&gt;::__on_zero_shared_weak() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __allocator_traits_rebind&lt;_Alloc, __shared_ptr_pointer&gt;::type _Al;</span><br><span class="line">    <span class="keyword">typedef</span> allocator_traits&lt;_Al&gt; _ATraits;</span><br><span class="line">    <span class="keyword">typedef</span> pointer_traits&lt;<span class="keyword">typename</span> _ATraits::pointer&gt; _PTraits;</span><br><span class="line"></span><br><span class="line">    _Al __a(__data_.<span class="built_in">second</span>());</span><br><span class="line">    __data_.<span class="built_in">second</span>().~_Alloc();</span><br><span class="line">    __a.<span class="built_in">deallocate</span>(_PTraits::<span class="built_in">pointer_to</span>(*<span class="keyword">this</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类型定义"><a href="#内部类型定义" class="headerlink" title="内部类型定义"></a>内部类型定义</h2><p><strong>weak_type</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">    <span class="keyword">typedef</span> weak_ptr&lt;_Tp&gt; weak_type;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>element_type</strong><br>表示维护对象的类型，remove_extent_t用于获取数组内元素的类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">remove_extent_t</span>&lt;_Tp&gt; element_type;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong>_<em>ptr</em></strong><br>__ptr_就是维护的指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">element_type*      __ptr_;</span><br></pre></td></tr></table></figure>

<p><strong>_<em>cntrl</em></strong><br>__cntrl_是引用计数块的指针，是shared_ptr_pointer类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__shared_weak_count* __cntrl_;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><em><em>shared_ptr(_Yp</em> __p)</em>*</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> = _EnableIf&lt;</span><br><span class="line">        _And&lt;</span><br><span class="line">            __compatible_with&lt;_Yp, _Tp&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(_LIBCPP_CXX03_LANG) &amp;&amp; !defined(_LIBCPP_COMPILER_GCC)</span></span><br><span class="line">            , _If&lt;is_array&lt;_Tp&gt;::value, __is_array_deletable&lt;_Yp*&gt;, __is_deletable&lt;_Yp*&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &gt;::value</span><br><span class="line">    &gt; &gt;</span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(_Yp* __p) : __ptr_(__p) &#123;</span><br><span class="line">        unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">        <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">        __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, __shared_ptr_default_delete&lt;_Tp, _Yp&gt;(), _AllocT()); <span class="comment">// 创建引用计数块</span></span><br><span class="line">        __hold.<span class="built_in">release</span>();</span><br><span class="line">        __enable_weak_this(__p, __p); <span class="comment">// 如果p继承了enable_shared_from_this，则保存一份weak_ptr在enable_shared_from_this中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr(const shared_ptr&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared(); <span class="comment">// 引用计数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr(shared_ptr&amp;&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(shared_ptr&amp;&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    __r.__ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">    __r.__cntrl_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if</span><br><span class="line">                            &lt;</span><br><span class="line">                                !is_lvalue_reference&lt;_Dp&gt;::value &amp;&amp;</span><br><span class="line">                                is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Yp, _Dp&gt;::pointer, element_type*&gt;::value,</span><br><span class="line">                                __nat</span><br><span class="line">                            &gt;::type)</span><br><span class="line">    : __ptr_(__r.<span class="built_in">get</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 11</span></span><br><span class="line">    <span class="keyword">if</span> (__ptr_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __cntrl_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">        <span class="keyword">typedef</span> __shared_ptr_pointer&lt;<span class="keyword">typename</span> unique_ptr&lt;_Yp, _Dp&gt;::pointer, _Dp, _AllocT &gt; _CntrlBlk;</span><br><span class="line">        __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__r.<span class="built_in">get</span>(), __r.<span class="built_in">get_deleter</span>(), _AllocT()); <span class="comment">// 创建引用计数块</span></span><br><span class="line">        __enable_weak_this(__r.<span class="built_in">get</span>(), __r.<span class="built_in">get</span>()); </span><br><span class="line">    &#125;</span><br><span class="line">    __r.<span class="built_in">release</span>(); <span class="comment">// 放弃控制权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(<span class="type">const</span> weak_ptr&lt;_Yp&gt;&amp; __r,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_ ? __r.__cntrl_-&gt;<span class="built_in">lock</span>() : __r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_ == <span class="literal">nullptr</span>)</span><br><span class="line">        __throw_bad_weak_ptr(); <span class="comment">// 如果weak_ptr为空，则抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__release_shared(); <span class="comment">// 引用计数-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值函数"><a href="#赋值函数" class="headerlink" title="赋值函数"></a>赋值函数</h2><p><strong>operator&#x3D;(const shared_ptr&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;&amp;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(__r).<span class="built_in">swap</span>(*<span class="keyword">this</span>); <span class="comment">// 旧引用计数-1，新引用计数+1</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;(shared_ptr&amp;&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;&amp;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(shared_ptr&amp;&amp; __r) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_VSTD::<span class="built_in">move</span>(__r)).<span class="built_in">swap</span>(*<span class="keyword">this</span>); <span class="comment">// 旧引用计数-1，新引用计数不变</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Yp, _Dp&gt;::pointer,</span><br><span class="line">                   <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type*&gt;::value,</span><br><span class="line">    shared_ptr&lt;_Tp&gt;&amp;</span><br><span class="line">&gt;::type</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="keyword">operator</span>=(unique_ptr&lt;_Yp, _Dp&gt;&amp;&amp; __r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(_VSTD::<span class="built_in">move</span>(__r)).<span class="built_in">swap</span>(*<span class="keyword">this</span>); <span class="comment">// unique_ptr放弃控制，新引用计数==1</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p><strong>swap(shared_ptr&amp; __r)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">swap</span>(shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    _VSTD::<span class="built_in">swap</span>(__ptr_, __r.__ptr_);</span><br><span class="line">    _VSTD::<span class="built_in">swap</span>(__cntrl_, __r.__cntrl_); <span class="comment">// 引用计数不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reset()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">reset</span>() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>().<span class="built_in">swap</span>(*<span class="keyword">this</span>); <span class="comment">// 旧引用计数-1，新引用计数==0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><em>reset(_Yp</em> __p)</em>*</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Yp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    __compatible_with&lt;_Yp, <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type&gt;::value,</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">&gt;::type</span><br><span class="line">shared_ptr&lt;_Tp&gt;::<span class="built_in">reset</span>(_Yp* __p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(__p).<span class="built_in">swap</span>(*<span class="keyword">this</span>); <span class="comment">// 旧引用计数-1，新引用计数==1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> ..._Args, <span class="keyword">class</span> = _EnableIf&lt;!is_array&lt;_Tp&gt;::value&gt; &gt;</span><br><span class="line">_LIBCPP_HIDE_FROM_ABI</span><br><span class="line">shared_ptr&lt;_Tp&gt; <span class="built_in">make_shared</span>(_Args&amp;&amp; ...__args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _VSTD::<span class="built_in">allocate_shared</span>&lt;_Tp&gt;(<span class="built_in">allocator</span>&lt;_Tp&gt;(), _VSTD::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> ..._Args, <span class="keyword">class</span> = _EnableIf&lt;!is_array&lt;_Tp&gt;::value&gt; &gt;</span><br><span class="line">_LIBCPP_HIDE_FROM_ABI</span><br><span class="line">shared_ptr&lt;_Tp&gt; <span class="built_in">allocate_shared</span>(<span class="type">const</span> _Alloc&amp; __a, _Args&amp;&amp; ...__args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> _ControlBlock = __shared_ptr_emplace&lt;_Tp, _Alloc&gt;;</span><br><span class="line">    <span class="keyword">using</span> _ControlBlockAllocator = <span class="keyword">typename</span> __allocator_traits_rebind&lt;_Alloc, _ControlBlock&gt;::type;</span><br><span class="line">    __allocation_guard&lt;_ControlBlockAllocator&gt; __guard(__a, <span class="number">1</span>);</span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span>*)_VSTD::<span class="built_in">addressof</span>(*__guard.__get())) _ControlBlock(__a, _VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 创建Tp对象，创建引用计数块</span></span><br><span class="line">    <span class="keyword">auto</span> __control_block = __guard.__release_ptr();</span><br><span class="line">    <span class="keyword">return</span> shared_ptr&lt;_Tp&gt;::__create_with_control_block((*__control_block).__get_elem(), _VSTD::<span class="built_in">addressof</span>(*__control_block)); <span class="comment">// 创建shared_ptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>对shared_ptr内的指针进行类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Up&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">static_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;_Up&gt;&amp; __r)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__r,</span><br><span class="line">                           <span class="keyword">static_cast</span>&lt;</span><br><span class="line">                               <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type*&gt;(__r.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Up&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">dynamic_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;_Up&gt;&amp; __r)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type _ET;</span><br><span class="line">    _ET* __p = <span class="built_in">dynamic_cast</span>&lt;_ET*&gt;(__r.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> __p ? <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__r, __p) : <span class="built_in">shared_ptr</span>&lt;_Tp&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Up&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">const_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;_Up&gt;&amp; __r)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type _RTp;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__r, <span class="built_in">const_cast</span>&lt;_RTp*&gt;(__r.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp, <span class="keyword">class</span> _Up&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;_Tp&gt;</span></span><br><span class="line"><span class="function"><span class="title">reinterpret_pointer_cast</span><span class="params">(<span class="type">const</span> shared_ptr&lt;_Up&gt;&amp; __r)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__r,</span><br><span class="line">                           <span class="keyword">reinterpret_cast</span>&lt;</span><br><span class="line">                               <span class="keyword">typename</span> shared_ptr&lt;_Tp&gt;::element_type*&gt;(__r.<span class="built_in">get</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h2><p>提供enable_shared_from_this接口，用于通过Tp指针获取到已经创建过的shared_ptr对象，用于共享同一个shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> enable_shared_from_this</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">mutable</span> weak_ptr&lt;_Tp&gt; __weak_this_; <span class="comment">// shared_ptr创建后，会保存一份weak_ptr在这里</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span></span><br><span class="line"><span class="function">    <span class="title">enable_shared_from_this</span><span class="params">()</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    <span class="title">enable_shared_from_this</span><span class="params">(enable_shared_from_this <span class="type">const</span>&amp;)</span> _NOEXCEPT </span>&#123;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    enable_shared_from_this&amp; <span class="keyword">operator</span>=(enable_shared_from_this <span class="type">const</span>&amp;) _NOEXCEPT</span><br><span class="line">        &#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    ~<span class="built_in">enable_shared_from_this</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;_Tp&gt;(__weak_this_);&#125; <span class="comment">// 返回共享的shared_ptr，（weak_ptr如果没有初始化则会抛出异常）</span></span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    shared_ptr&lt;_Tp <span class="type">const</span>&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">const</span> _Tp&gt;(__weak_this_);&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    weak_ptr&lt;_Tp&gt; <span class="title">weak_from_this</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">       </span>&#123; <span class="keyword">return</span> __weak_this_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">    weak_ptr&lt;<span class="type">const</span> _Tp&gt; <span class="title">weak_from_this</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> __weak_this_; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_STD_VER &gt; 14</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">shared_ptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之std::string</title>
    <url>/2022/01/30/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bstring/</url>
    <content><![CDATA[<h1 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="type">char</span>, char_traits&lt;<span class="type">char</span>&gt;, allocator&lt;<span class="type">char</span>&gt; &gt; string;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在basic_string实现中，对短字符串进行了优化，长短字符长存储的数据结构是不一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__rep</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        __long  __l;</span><br><span class="line">        __short __s;</span><br><span class="line">        __raw   __r;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__compressed_pair&lt;__rep, allocator_type&gt; __r_;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="长字符串"><a href="#长字符串" class="headerlink" title="长字符串"></a>长字符串</h3><p>长字符串会根据字符大小动态分配内存，data中存储字符数组的指针，当字符大小超过分配的长度时，会进行扩容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 总共24个字节</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__long</span></span><br><span class="line">&#123;</span><br><span class="line">    size_type __cap_; <span class="comment">// 分配的字符数组长度</span></span><br><span class="line">    size_type __size_; <span class="comment">// 字符串长度</span></span><br><span class="line">    pointer   __data_; <span class="comment">// 字符数组指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="短字符串"><a href="#短字符串" class="headerlink" title="短字符串"></a>短字符串</h3><p>短字符串最多存储22个字符（最后一位为0），所以小于23长度的都是短字符串存储，超过都是长字符串存储。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 23</span></span><br><span class="line"><span class="keyword">enum</span> &#123;__min_cap = (<span class="built_in">sizeof</span>(__long) - <span class="number">1</span>)/<span class="built_in">sizeof</span>(value_type) &gt; <span class="number">2</span> ?</span><br><span class="line">                  (<span class="built_in">sizeof</span>(__long) - <span class="number">1</span>)/<span class="built_in">sizeof</span>(value_type) : <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总共24个字节</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__short</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> __size_; <span class="comment">// 字符串长度</span></span><br><span class="line">        value_type __lx;</span><br><span class="line">    &#125;;</span><br><span class="line">    value_type __data_[__min_cap]; <span class="comment">// 字符数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="长短字符串标记"><a href="#长短字符串标记" class="headerlink" title="长短字符串标记"></a>长短字符串标记</h3><p>通过在数据结构的第一个字节插入标记来区分当前是长字符还是短字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LIBCPP_BIG_ENDIAN</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> size_type __short_mask = <span class="number">0x80</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> size_type __long_mask  = ~(<span class="built_in">size_type</span>(~<span class="number">0</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>  <span class="comment">// _LIBCPP_BIG_ENDIAN</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> size_type __short_mask = <span class="number">0x01</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> size_type __long_mask  = <span class="number">0x1</span>ul;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_BIG_ENDIAN</span></span></span><br><span class="line"></span><br><span class="line">在小端环境下，对于短字符，会把size字段的最低位标记为<span class="number">0</span>（通过左移）。大端环境下，由于短字符的size最大为<span class="number">22</span>，所以最高位一定是<span class="number">0.</span></span><br><span class="line">```c++</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    <span class="type">void</span> __set_short_size(size_type __s) _NOEXCEPT</span><br><span class="line"><span class="meta">#   <span class="keyword">ifdef</span> _LIBCPP_BIG_ENDIAN</span></span><br><span class="line">        &#123;__r_.<span class="built_in">first</span>().__s.__size_ = (<span class="type">unsigned</span> <span class="type">char</span>)(__s);&#125;</span><br><span class="line"><span class="meta">#   <span class="keyword">else</span></span></span><br><span class="line">        &#123;__r_.<span class="built_in">first</span>().__s.__size_ = (<span class="type">unsigned</span> <span class="type">char</span>)(__s &lt;&lt; <span class="number">1</span>);&#125;</span><br><span class="line"><span class="meta">#   <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>对于长字符，其分配的内存大小都是经过字节对齐的，所以其最低位一定是0，通过把cap字段的最低位标记为1（大端环境下是把最高位标记为1），来标记是长字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span> __set_long_cap(size_type __s) _NOEXCEPT</span><br><span class="line">    &#123;__r_.<span class="built_in">first</span>().__l.__cap_  = __long_mask | __s;&#125;</span><br></pre></td></tr></table></figure>

<p>所以判断是否是长字符，只需要判断其第一个字节的最低位是否是1即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">bool</span> __is_long() <span class="type">const</span> _NOEXCEPT</span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="built_in">bool</span>(__r_.<span class="built_in">first</span>().__s.__size_ &amp; __short_mask);&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>basic_string提供了多种构造，可以方便的创建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">basic_string</span>() <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">basic_string</span><span class="params">(<span class="type">const</span> allocator_type&amp; a)</span></span>;</span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp; str);</span><br><span class="line"><span class="built_in">basic_string</span>(basic_string&amp;&amp; str) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp; str, size_type pos, <span class="type">const</span> allocator_type&amp; a = <span class="built_in">allocator_type</span>());</span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp; str, size_type pos, size_type n, <span class="type">const</span> Allocator&amp; a = <span class="built_in">Allocator</span>());</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="title">basic_string</span><span class="params">(<span class="type">const</span> T&amp; t, size_type pos, size_type n, <span class="type">const</span> Allocator&amp; a = Allocator())</span></span>; <span class="comment">// C++17</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">basic_string</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> Allocator&amp; a = Allocator())</span></span>; <span class="comment">// C++17</span></span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> value_type* s, <span class="type">const</span> allocator_type&amp; a = <span class="built_in">allocator_type</span>());</span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> value_type* s, size_type n, <span class="type">const</span> allocator_type&amp; a = <span class="built_in">allocator_type</span>());</span><br><span class="line"><span class="built_in">basic_string</span>(size_type n, value_type c, <span class="type">const</span> allocator_type&amp; a = <span class="built_in">allocator_type</span>());</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator&gt; <span class="title">basic_string</span><span class="params">(InputIterator begin, InputIterator end, <span class="type">const</span> allocator_type&amp; a = allocator_type())</span></span>;</span><br><span class="line"><span class="built_in">basic_string</span>(initializer_list&lt;value_type&gt;, <span class="type">const</span> Allocator&amp; = <span class="built_in">Allocator</span>());</span><br><span class="line"><span class="built_in">basic_string</span>(<span class="type">const</span> basic_string&amp;, <span class="type">const</span> Allocator&amp;);</span><br><span class="line"><span class="built_in">basic_string</span>(basic_string&amp;&amp;, <span class="type">const</span> Allocator&amp;);</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>一个string构造初始化流程基本如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::__init(<span class="type">const</span> value_type* __s, size_type __sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__sz &gt; <span class="built_in">max_size</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line">    pointer __p;</span><br><span class="line">    <span class="keyword">if</span> (__sz &lt; __min_cap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前初始化的字符长度小于23，则判定为短字符</span></span><br><span class="line">        __set_short_size(__sz); <span class="comment">// 存储字符长度（不包含尾部的0）</span></span><br><span class="line">        __p = __get_short_pointer(); <span class="comment">// 获取存储数据的字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        size_type __cap = __recommend(__sz); <span class="comment">// 根据字符长度进行字节对齐，返回结果会-1</span></span><br><span class="line">        __p = __alloc_traits::<span class="built_in">allocate</span>(__alloc(), __cap+<span class="number">1</span>); <span class="comment">// 分配内存</span></span><br><span class="line">        __set_long_pointer(__p); <span class="comment">// 存储指针</span></span><br><span class="line">        __set_long_cap(__cap+<span class="number">1</span>); <span class="comment">// 存储分配大小</span></span><br><span class="line">        __set_long_size(__sz); <span class="comment">// 存储字符长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    traits_type::<span class="built_in">copy</span>(_VSTD::__to_address(__p), __s, __sz); <span class="comment">// 字符拷贝</span></span><br><span class="line">    traits_type::<span class="built_in">assign</span>(__p[__sz], <span class="built_in">value_type</span>()); <span class="comment">// 尾部插0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="append"><a href="#append" class="headerlink" title="append"></a>append</h2><p>通过+&#x3D;操作符进行字符串加操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;&amp;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">append</span>(<span class="type">const</span> value_type* __s, size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__n == <span class="number">0</span> || __s != <span class="literal">nullptr</span>, <span class="string">&quot;string::append received nullptr&quot;</span>);</span><br><span class="line">    size_type __cap = <span class="built_in">capacity</span>();</span><br><span class="line">    size_type __sz = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__cap - __sz &gt;= __n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果追加后的字符长度小于当前分配的长度，则直接拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (__n)</span><br><span class="line">        &#123;</span><br><span class="line">            value_type* __p = _VSTD::__to_address(__get_pointer()); <span class="comment">// 获取字符数组</span></span><br><span class="line">            traits_type::<span class="built_in">copy</span>(__p + __sz, __s, __n); <span class="comment">// 拷贝</span></span><br><span class="line">            __sz += __n;</span><br><span class="line">            __set_size(__sz); <span class="comment">// 更新字符长度</span></span><br><span class="line">            traits_type::<span class="built_in">assign</span>(__p[__sz], <span class="built_in">value_type</span>()); <span class="comment">// 尾部插0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, <span class="number">0</span>, __n, __s); <span class="comment">// 长度不够，扩容</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据扩容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::__grow_by_and_replace</span><br><span class="line">    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,</span><br><span class="line">     size_type __n_copy,  size_type __n_del,     size_type __n_add, <span class="type">const</span> value_type* __p_new_stuff)</span><br><span class="line">&#123;</span><br><span class="line">    size_type __ms = <span class="built_in">max_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__delta_cap &gt; __ms - __old_cap - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line">    pointer __old_p = __get_pointer();</span><br><span class="line">    <span class="comment">// 扩容最小扩大一倍，如果不够，则根据需要大小来扩容</span></span><br><span class="line">    size_type __cap = __old_cap &lt; __ms / <span class="number">2</span> - __alignment ?</span><br><span class="line">                          __recommend(_VSTD::<span class="built_in">max</span>(__old_cap + __delta_cap, <span class="number">2</span> * __old_cap)) :</span><br><span class="line">                          __ms - <span class="number">1</span>;</span><br><span class="line">    pointer __p = __alloc_traits::<span class="built_in">allocate</span>(__alloc(), __cap+<span class="number">1</span>); <span class="comment">// 重新分配内存</span></span><br><span class="line">    __invalidate_all_iterators();</span><br><span class="line">    <span class="keyword">if</span> (__n_copy != <span class="number">0</span>)</span><br><span class="line">        traits_type::<span class="built_in">copy</span>(_VSTD::__to_address(__p),</span><br><span class="line">                          _VSTD::__to_address(__old_p), __n_copy); <span class="comment">// 将已有数据拷贝到新分配内存上</span></span><br><span class="line">    <span class="keyword">if</span> (__n_add != <span class="number">0</span>)</span><br><span class="line">        traits_type::<span class="built_in">copy</span>(_VSTD::__to_address(__p) + __n_copy, __p_new_stuff, __n_add); <span class="comment">// 将新数据拷贝到新分配内存上</span></span><br><span class="line">    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;</span><br><span class="line">    <span class="keyword">if</span> (__sec_cp_sz != <span class="number">0</span>)</span><br><span class="line">        traits_type::<span class="built_in">copy</span>(_VSTD::__to_address(__p) + __n_copy + __n_add,</span><br><span class="line">                          _VSTD::__to_address(__old_p) + __n_copy + __n_del, __sec_cp_sz); <span class="comment">// 将部分数据移动到新分配数据后面，insert pos情况下</span></span><br><span class="line">    <span class="keyword">if</span> (__old_cap+<span class="number">1</span> != __min_cap)</span><br><span class="line">        __alloc_traits::<span class="built_in">deallocate</span>(__alloc(), __old_p, __old_cap+<span class="number">1</span>); <span class="comment">// 如果已有数据是长字符，则需要销毁之前分配的内存</span></span><br><span class="line">    __set_long_pointer(__p); <span class="comment">// 需要扩容的一定是长字符</span></span><br><span class="line">    __set_long_cap(__cap+<span class="number">1</span>);</span><br><span class="line">    __old_sz = __n_copy + __n_add + __sec_cp_sz;</span><br><span class="line">    __set_long_size(__old_sz);</span><br><span class="line">    traits_type::<span class="built_in">assign</span>(__p[__old_sz], <span class="built_in">value_type</span>()); <span class="comment">// 尾部插0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>设置字符长度，设置的是size长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY <span class="type">void</span> <span class="title">resize</span><span class="params">(size_type __n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(__n, <span class="built_in">value_type</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">resize</span>(size_type __n, value_type __c)</span><br><span class="line">&#123;</span><br><span class="line">    size_type __sz = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; __sz)</span><br><span class="line">        <span class="built_in">append</span>(__n - __sz, __c); <span class="comment">// 如果resize的长度超过已有字符长度，则向当前字符后面追加超过长度的0字符</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __erase_to_end(__n); <span class="comment">// 如果resize的长度小于已有字符长度，则将n位置置位0，更新字符长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h2><p>设置分配内存大小，设置的是cap大小，size不会变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">reserve</span>(size_type __requested_capacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__requested_capacity &gt; <span class="built_in">max_size</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 17</span></span><br><span class="line">    <span class="comment">// Reserve never shrinks as of C++20.</span></span><br><span class="line">    <span class="keyword">if</span> (__requested_capacity &lt;= <span class="built_in">capacity</span>()) <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    size_type __target_capacity = _VSTD::<span class="built_in">max</span>(__requested_capacity, <span class="built_in">size</span>());</span><br><span class="line">    __target_capacity = __recommend(__target_capacity);</span><br><span class="line">    <span class="keyword">if</span> (__target_capacity == <span class="built_in">capacity</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    __shrink_or_extend(__target_capacity); <span class="comment">// 对于长字符，重新分配内存，将已有字符拷贝到新内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>清空字符长度，并不会销毁内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">clear</span>() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    __invalidate_all_iterators();</span><br><span class="line">    <span class="comment">// 将字符数组第一个设置为0，并将字符长度设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (__is_long())</span><br><span class="line">    &#123;</span><br><span class="line">        traits_type::<span class="built_in">assign</span>(*__get_long_pointer(), <span class="built_in">value_type</span>());</span><br><span class="line">        __set_long_size(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        traits_type::<span class="built_in">assign</span>(*__get_short_pointer(), <span class="built_in">value_type</span>());</span><br><span class="line">        __set_short_size(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Allocator&gt;::reference</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __pos) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__pos &lt;= <span class="built_in">size</span>(), <span class="string">&quot;string index out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> *(__get_pointer() + __pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>at多了一个越界的检查，会抛出异常，里面也是调用[]操作符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Allocator&gt;::reference</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">at</span>(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_out_of_range();</span><br><span class="line">    <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>在指定位置插入新字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;&amp;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">insert</span>(size_type __pos, <span class="type">const</span> value_type* __s, size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__n == <span class="number">0</span> || __s != <span class="literal">nullptr</span>, <span class="string">&quot;string::insert received nullptr&quot;</span>);</span><br><span class="line">    size_type __sz = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__pos &gt; __sz)</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_out_of_range();</span><br><span class="line">    size_type __cap = <span class="built_in">capacity</span>();</span><br><span class="line">    <span class="keyword">if</span> (__cap - __sz &gt;= __n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果分配的内存大小够用</span></span><br><span class="line">        <span class="keyword">if</span> (__n)</span><br><span class="line">        &#123;</span><br><span class="line">            value_type* __p = _VSTD::__to_address(__get_pointer());</span><br><span class="line">            size_type __n_move = __sz - __pos;</span><br><span class="line">            <span class="keyword">if</span> (__n_move != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__p + __pos &lt;= __s &amp;&amp; __s &lt; __p + __sz)</span><br><span class="line">                    __s += __n;</span><br><span class="line">                traits_type::<span class="built_in">move</span>(__p + __pos + __n, __p + __pos, __n_move); <span class="comment">// 将pos后面的字符移动到后面，空出n个字符位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            traits_type::<span class="built_in">move</span>(__p + __pos, __s, __n); <span class="comment">// 将新字符插入到指定位置</span></span><br><span class="line">            __sz += __n;</span><br><span class="line">            __set_size(__sz); <span class="comment">// 更新字符长度</span></span><br><span class="line">            traits_type::<span class="built_in">assign</span>(__p[__sz], <span class="built_in">value_type</span>()); <span class="comment">// 尾部插0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, <span class="number">0</span>, __n, __s); <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2><p>删除指定位置后面的指定长度的数据，只是改变了size，并没有销毁内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;&amp;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">erase</span>(size_type __pos,</span><br><span class="line">                                                 size_type __n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__pos &gt; <span class="built_in">size</span>()) <span class="keyword">this</span>-&gt;__throw_out_of_range();</span><br><span class="line">  <span class="keyword">if</span> (__n == npos) &#123;</span><br><span class="line">    __erase_to_end(__pos); <span class="comment">// 默认删除指定位置后面所有数据</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    __erase_external_with_move(__pos, __n); <span class="comment">// 删除指定位置后面n个数据，pos+n后面的数据会移动到pos位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p>pos到pos+n1位置的数据用s到s+n2的数据来替换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;&amp;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">replace</span>(size_type __pos, size_type __n1, <span class="type">const</span> value_type* __s, size_type __n2)</span><br><span class="line">    _LIBCPP_DISABLE_UBSAN_UNSIGNED_INTEGER_CHECK</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__n2 == <span class="number">0</span> || __s != <span class="literal">nullptr</span>, <span class="string">&quot;string::replace received nullptr&quot;</span>);</span><br><span class="line">    size_type __sz = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__pos &gt; __sz)</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_out_of_range();</span><br><span class="line">    __n1 = _VSTD::<span class="built_in">min</span>(__n1, __sz - __pos);</span><br><span class="line">    size_type __cap = <span class="built_in">capacity</span>();</span><br><span class="line">    <span class="keyword">if</span> (__cap - __sz + __n1 &gt;= __n2)</span><br><span class="line">    &#123;</span><br><span class="line">        value_type* __p = _VSTD::__to_address(__get_pointer());</span><br><span class="line">        <span class="keyword">if</span> (__n1 != __n2)</span><br><span class="line">        &#123;</span><br><span class="line">            size_type __n_move = __sz - __pos - __n1;</span><br><span class="line">            <span class="keyword">if</span> (__n_move != <span class="number">0</span>)</span><br><span class="line">            &#123;   <span class="comment">// 如果 pos + n1后面还有数据</span></span><br><span class="line">                <span class="keyword">if</span> (__n1 &gt; __n2)</span><br><span class="line">                &#123;   <span class="comment">// 如果n1大于n2，直接将n2放入到n1，再将n1后面的数据移动到n2后面</span></span><br><span class="line">                    traits_type::<span class="built_in">move</span>(__p + __pos, __s, __n2); <span class="comment">// 移动[s,s+n2]的数据到[p,p+n2]</span></span><br><span class="line">                    traits_type::<span class="built_in">move</span>(__p + __pos + __n2, __p + __pos + __n1, __n_move); <span class="comment">// 移动[pos,n1]后面的数据到[p+p2, n_move]</span></span><br><span class="line">                    <span class="keyword">goto</span> __finish;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (__p + __pos &lt; __s &amp;&amp; __s &lt; __p + __sz)</span><br><span class="line">                &#123;   <span class="comment">// 如果n1小于n2，需要先将n1后面的数据向后移动，才能放得下n2</span></span><br><span class="line">                    <span class="keyword">if</span> (__p + __pos + __n1 &lt;= __s)</span><br><span class="line">                        __s += __n2 - __n1;</span><br><span class="line">                    <span class="keyword">else</span> <span class="comment">// __p + __pos &lt; __s &lt; __p + __pos + __n1</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        traits_type::<span class="built_in">move</span>(__p + __pos, __s, __n1);</span><br><span class="line">                        __pos += __n1;</span><br><span class="line">                        __s += __n2;</span><br><span class="line">                        __n2 -= __n1;</span><br><span class="line">                        __n1 = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                traits_type::<span class="built_in">move</span>(__p + __pos + __n2, __p + __pos + __n1, __n_move);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        traits_type::<span class="built_in">move</span>(__p + __pos, __s, __n2);</span><br><span class="line">__finish:</span><br><span class="line"><span class="comment">// __sz += __n2 - __n1; in this and the below function below can cause unsigned</span></span><br><span class="line"><span class="comment">// integer overflow, but this is a safe operation, so we disable the check.</span></span><br><span class="line">        __sz += __n2 - __n1;</span><br><span class="line">        __set_size(__sz);</span><br><span class="line">        __invalidate_iterators_past(__sz);</span><br><span class="line">        traits_type::<span class="built_in">assign</span>(__p[__sz], <span class="built_in">value_type</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s); <span class="comment">// 扩容</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h2><p>会重新拷贝一份数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;</span><br><span class="line">basic_string&lt;_CharT, _Traits, _Allocator&gt;::<span class="built_in">substr</span>(size_type __pos, size_type __n) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">basic_string</span>(*<span class="keyword">this</span>, __pos, __n, __alloc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="operator-std-string-view"><a href="#operator-std-string-view" class="headerlink" title="operator std::string_view"></a>operator std::string_view</h2><p>支持隐式转换为std::string_view</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">operator</span> __self_view() <span class="type">const</span> _NOEXCEPT &#123; </span><br><span class="line">    <span class="keyword">return</span> __self_view(<span class="built_in">data</span>(), <span class="built_in">size</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h1><p>string_view是一个轻量级的字符串类，相比string每次都会拷贝数据，在string_view中只会存储数据的指针。string_view相比较char*提供了很多字符操作，也就是说如果想要使用string里面的字符操作函数，但是又不想到拷贝一份数据，可以使用string_view。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string_view&lt;<span class="type">char</span>&gt;     string_view;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span>   value_type* __data; <span class="comment">// 字符数组的指针</span></span><br><span class="line">    size_type           __size; <span class="comment">// 字符数组的长度</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h2><p>string_view的构造只是简单的记录了外部传入的字符数组的指针和长度，并不会和string一样自身拷贝一份。string对象可以隐式转换为string_view，所以可以直接将string对象作为参数进行构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">basic_string_view</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">basic_string_view</span><span class="params">(<span class="type">const</span> basic_string_view&amp;)</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">basic_string_view&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_string_view&amp;) <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Allocator&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">basic_string_view</span><span class="params">(<span class="type">const</span> charT* str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">basic_string_view</span><span class="params">(<span class="type">const</span> charT* str, size_type len)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="title">basic_string_view</span><span class="params">(<span class="type">const</span> _CharT* __s, size_type __len)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    : __data(__s), __size(__len) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="title">basic_string_view</span><span class="params">(<span class="type">const</span> _CharT* __s)</span></span></span><br><span class="line"><span class="function">    : __data(__s), __size(_VSTD::__char_traits_length_checked&lt;_Traits&gt;(__s)) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="substr-1"><a href="#substr-1" class="headerlink" title="substr"></a>substr</h3><p>string_view的substr并不会重新拷贝一份</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_CONSTEXPR _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">basic_string_view <span class="title">substr</span><span class="params">(size_type __pos = <span class="number">0</span>, size_type __n = npos)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __pos &gt; <span class="built_in">size</span>()</span><br><span class="line">        ? (__throw_out_of_range(<span class="string">&quot;string_view::substr&quot;</span>), <span class="built_in">basic_string_view</span>())</span><br><span class="line">        : <span class="built_in">basic_string_view</span>(<span class="built_in">data</span>() + __pos, _VSTD::<span class="built_in">min</span>(__n, <span class="built_in">size</span>() - __pos));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之std::unique_ptr</title>
    <url>/2021/07/11/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bunique_ptr/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义类模板，T为要删除的指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;U&gt;&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line">	   <span class="comment">// 重写()操作符，外部调用该操作符将T类型的指针传递进来进行删除</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T*)</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类模板，T为管理的指针类型，D为负责删除指针的结构体类型，默认实现为default_delete</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">D</span> = default_delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> see below pointer; <span class="comment">// 默认为T*，除非default_delete里定义了pointer类型</span></span><br><span class="line">    <span class="keyword">typedef</span> T element_type; <span class="comment">// 管理的指针类型</span></span><br><span class="line">    <span class="keyword">typedef</span> D deleter_type; <span class="comment">// 删除指针的结构体类型</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">unique_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(pointer p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer p, see below d1) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer p, see below d2) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> : <span class="built_in">unique_ptr</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt;</span><br><span class="line">        <span class="built_in">unique_ptr</span>(unique_ptr&lt;U, E&gt;&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt;</span><br><span class="line">        <span class="built_in">unique_ptr</span>(auto_ptr&lt;U&gt;&amp;&amp; u) <span class="keyword">noexcept</span>;       <span class="comment">// removed in C++17</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment</span></span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>, <span class="keyword">class</span> <span class="title class_">E</span>&gt; unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;U, E&gt;&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// observers</span></span><br><span class="line">    <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type <span class="keyword">operator</span>*() <span class="type">const</span>;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modifiers</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer p = pointer())</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; u)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>unique_ptr支持维护数组类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组类型偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">D</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span>&lt;T[], D&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> implementation-defined pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T element_type;</span><br><span class="line">    <span class="keyword">typedef</span> D deleter_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructors</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">unique_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span><span class="params">(pointer p)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer p, see below d) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(pointer p, see below d) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span> : <span class="built_in">unique_ptr</span>() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// destructor</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assignment</span></span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; u) <span class="keyword">noexcept</span>;</span><br><span class="line">    unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// observers</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> i) <span class="type">const</span>;</span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// modifiers</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer p = pointer())</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">nullptr_t</span>)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(U)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; u)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="内部类型定义"><a href="#内部类型定义" class="headerlink" title="内部类型定义"></a>内部类型定义</h2><p><strong>pointer</strong><br>pointer类型默认是_Tp*，除非default_delete中定义了pointer类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> __pointer&lt;_Tp, deleter_type&gt;::type pointer; <span class="comment">// _Tp*</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(NAME, PROPERTY)                \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;class _Tp, class = void&gt;</span> struct NAME : false_type &#123; &#125;;    \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;class _Tp&gt;</span>               struct NAME<span class="string">&lt;_Tp, typename __void_t&lt;typename _Tp:: PROPERTY &gt;</span>::type&gt; : true_type &#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __pointer</span></span><br><span class="line">_LIBCPP_ALLOCATOR_TRAITS_HAS_XXX(__has_pointer, pointer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove_reference&lt;_Alloc&gt;::type获取到的是去掉引用后的真实类型，如果_Alloc不是引用，则返回_Alloc；</span></span><br><span class="line"><span class="comment">// __has_pointer是通过__void_t来判断一个类型内是否存在指定的子类型，如果在_Alloc中定义了子类型pointer，则匹配偏特化版本，返回true_type，否则匹配默认版本，返回false_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>,</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">_RawAlloc</span> = <span class="keyword">typename</span> remove_reference&lt;_Alloc&gt;::type,</span><br><span class="line">          <span class="type">bool</span> = __has_pointer&lt;_RawAlloc&gt;::value&gt;</span><br><span class="line"><span class="keyword">struct</span> __pointer &#123;</span><br><span class="line">	  <span class="comment">// 此时__pointer&lt;_Tp, deleter_type&gt;::type = deleter_type::pointer</span></span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _RawAlloc::pointer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化，__has_pointer&lt;_RawAlloc&gt;::value&gt;为false时匹配</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_RawAlloc</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__pointer</span>&lt;_Tp, _Alloc, _RawAlloc, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">		<span class="comment">// 此时__pointer&lt;_Tp, deleter_type&gt;::type = _Tp*</span></span><br><span class="line">    <span class="keyword">using</span> type _LIBCPP_NODEBUG_TYPE = _Tp*;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>_DeleterSFINAE</strong></p>
<p>根据deleter_type的类型，定义了不同的子类型，通过enable_if在模板函数的参数Substitution时进行类型限定。在deleter_type是值类型时，定义__good_rval_ref_type，在deleter_type是引用类型时，定义了__bad_rval_ref_type。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __unique_ptr_deleter_sfinae&lt;_Dp&gt; _DeleterSFINAE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy&gt;</span><br><span class="line"><span class="keyword">using</span> _LValRefType  =</span><br><span class="line">    <span class="keyword">typename</span> __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__lval_ref_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy&gt;</span><br><span class="line"><span class="keyword">using</span> _GoodRValRefType  =</span><br><span class="line">    <span class="keyword">typename</span> __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__good_rval_ref_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy&gt;</span><br><span class="line"><span class="keyword">using</span> _BadRValRefType   =</span><br><span class="line">    <span class="keyword">typename</span> __dependent_type&lt;_DeleterSFINAE, _Dummy&gt;::__bad_rval_ref_type;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span> &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!is_reference&lt;_Deleter&gt;::value, <span class="string">&quot;incorrect specialization&quot;</span>);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp;&amp; __good_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> true_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span>&lt;_Deleter <span class="type">const</span>&amp;&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Deleter&amp;&amp; __bad_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> false_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Deleter</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__unique_ptr_deleter_sfinae</span>&lt;_Deleter&amp;&gt; &#123;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp; __lval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Deleter&amp;&amp; __bad_rval_ref_type;</span><br><span class="line">  <span class="keyword">typedef</span> false_type __enable_rval_overload;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>_EnableIfDeleterDefaultConstructible</strong></p>
<p>_EnableIfDeleterDefaultConstructible是用来限定deleter_type必须要有默认构造且不能是指针类型。</p>
<p>_Deleter得到的就是deleter_type类型，enable_if中判断如果_Deleter有默认构造且不是指针类型，才会有子类型type，否则_EnableIfDeleterDefaultConstructible不会被定义，则函数模板不匹配。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy, <span class="keyword">class</span> <span class="title class_">_Deleter</span> = <span class="keyword">typename</span> __dependent_type&lt;</span><br><span class="line">                           __identity&lt;deleter_type&gt;, _Dummy&gt;::type&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfDeleterDefaultConstructible =</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_default_constructible&lt;_Deleter&gt;::value &amp;&amp;</span><br><span class="line">                       !is_pointer&lt;_Deleter&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure>

<p><strong>_EnableIfDeleterConstructible</strong></p>
<p>用来判断deleter_type是否有指定类型作为参数的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ArgType</span>&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfDeleterConstructible  =</span><br><span class="line">    <span class="keyword">typename</span> enable_if&lt;is_constructible&lt;deleter_type, _ArgType&gt;::value&gt;::type;</span><br></pre></td></tr></table></figure>

<p><strong>_EnableIfMoveConvertible</strong></p>
<p>判断_Uptr的pointer和当前的pointer两个类型能否进行转换，并且_Up不是数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UPtr</span>, <span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfMoveConvertible  = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">    is_convertible&lt;<span class="keyword">typename</span> _UPtr::pointer, pointer&gt;::value &amp;&amp;</span><br><span class="line">    !is_array&lt;_Up&gt;::value</span><br><span class="line">&gt;::type;</span><br></pre></td></tr></table></figure>

<p><strong>_EnableIfDeleterConvertible</strong></p>
<p>如果当前的deleter_type是引用，则判断当前的deleter_type和_UDel是否相同类型，相同类型的引用才允许；如果当前的deleter_type是值类型，则判断当前的deleter_type和_UDel是否可以进行转换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_UDel</span>&gt;</span><br><span class="line"><span class="keyword">using</span> _EnableIfDeleterConvertible  = <span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">    (is_reference&lt;_Dp&gt;::value &amp;&amp; is_same&lt;_Dp, _UDel&gt;::value) ||</span><br><span class="line">    (!is_reference&lt;_Dp&gt;::value &amp;&amp; is_convertible&lt;_UDel, _Dp&gt;::value)</span><br><span class="line">  &gt;::type;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong>_<em>ptr</em></strong><br>__compressed_pair是一个空类型优化的pair实现，__ptr_用来保存维护的指针和删除器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__compressed_pair&lt;pointer, deleter_type&gt; __ptr_;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>unique_ptr()</strong></p>
<p>默认初始化pair，pointer()为创建_Tp*的空实例，__default_init_tag()为空类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt; &gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>() _NOEXCEPT : __ptr_(<span class="built_in">pointer</span>(), __default_init_tag()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(nullptr_t)</strong></p>
<p>传nullptr和不传其实是一样的，都是做默认初始化，pointer()为创建_Tp*的空实例，__default_init_tag()为空类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt; &gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">nullptr_t</span>) _NOEXCEPT : __ptr_(<span class="built_in">pointer</span>(), __default_init_tag()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(pointer __p)</strong></p>
<p>该构造函数必须显示调用，__p就是需要管理的裸指针，__default_init_tag()为空类对象。pair的first就是__p指针，second就是空对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterDefaultConstructible&lt;_Dummy&gt; &gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) _NOEXCEPT : __ptr_(__p, __default_init_tag()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(pointer p, _LValRefType&lt;_Dummy&gt; d)</strong></p>
<p>_LValRefType的类型根据deleter_type的类型走不同的特化版本， __p是需要管理的裸指针，而__d就是deleter_type类型的左值，使用这两个值重新创建pair。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_LValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, _LValRefType&lt;_Dummy&gt; __d) _NOEXCEPT</span><br><span class="line">    : __ptr_(__p, __d) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(pointer p, _GoodRValRefType&lt;_Dummy&gt; d)</strong></p>
<p>_GoodRValRefType的类型只有在deleter_type的类型是值类型时才有定义，也就是说只有是deleter_type是值类型时，才允许其右值引用作为参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_GoodRValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, _GoodRValRefType&lt;_Dummy&gt; __d) _NOEXCEPT</span><br><span class="line">    : __ptr_(__p, _VSTD::<span class="built_in">move</span>(__d)) &#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">                <span class="string">&quot;rvalue deleter bound to reference&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(pointer p, _BadRValRefType&lt;_Dummy&gt; d) &#x3D; delete</strong></p>
<p>当deleter_type的类型为引用类型时，才定义了_BadRValRefType，也就是说当传递进来的deleter_type是引用类型时，则不允许传递右值参数进来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> _Dummy = <span class="literal">true</span>,</span><br><span class="line">          <span class="keyword">class</span> = _EnableIfDeleterConstructible&lt;_BadRValRefType&lt;_Dummy&gt; &gt; &gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, _BadRValRefType&lt;_Dummy&gt; __d) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(unique_ptr&amp;&amp; __u)</strong></p>
<p>移动构造，__u释放管理的裸指针，将其转交给当前对象，将__u的deleter也进行转发成deleter_type类型给当前对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">    : __ptr_(__u.<span class="built_in">release</span>(), _VSTD::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>unique_ptr(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT</strong></p>
<p>接收一个类型不一致的右值引用，如果__u中维护的裸指针类型和当前对象中定义的类型可以转换，并且__u中的类型不是数组，则_EnableIfMoveConvertible满足；如果__u中维护的deleter_type和当前的deleter_type可以转换，那么_EnableIfDeleterConvertible满足。__u释放管理的裸指针，将其转交给当前对象，将__u的deleter也按照自身的类型转发给当前对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_Ep</span>,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfDeleterConvertible&lt;_Ep&gt;</span><br><span class="line">&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">    : __ptr_(__u.<span class="built_in">release</span>(), _VSTD::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>())) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p><strong>~unique_ptr()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~<span class="built_in">unique_ptr</span>() &#123; <span class="built_in">reset</span>(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值函数"><a href="#赋值函数" class="headerlink" title="赋值函数"></a>赋值函数</h2><p><strong>operator&#x3D;(unique_ptr&amp;&amp; __u)</strong></p>
<p>接收一个右值引用，__u释放管理的裸指针，当前对象通过reset方法重新管理该裸指针，将__u的deleter也进行转发给当前对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) _NOEXCEPT &#123;</span><br><span class="line">  <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">  __ptr_.<span class="built_in">second</span>() = _VSTD::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u)</strong></p>
<p>接收一个类型不一致的右值引用的赋值。同上面的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>, <span class="keyword">class</span> <span class="title class_">_Ep</span>,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfMoveConvertible&lt;unique_ptr&lt;_Up, _Ep&gt;, _Up&gt;,</span><br><span class="line">    <span class="keyword">class</span> = _EnableIfDeleterAssignable&lt;_Ep&gt;</span><br><span class="line">&gt;</span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) _NOEXCEPT &#123;</span><br><span class="line">  <span class="built_in">reset</span>(__u.<span class="built_in">release</span>());</span><br><span class="line">  __ptr_.<span class="built_in">second</span>() = _VSTD::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;(nullptr_t) _NOEXCEPT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) _NOEXCEPT &#123;</span><br><span class="line">  <span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h2><p><strong>operator-&gt;() const _NOEXCEPT</strong><br>定义操作符-&gt;，返回__ptr_.first()，可以直接通过-&gt;访问内部裸指针的相关方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> _NOEXCEPT &#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><em>operator</em>() const</em>*<br>定义操作符<em>，返回</em>_<em>ptr</em>.first()，可以直接通过*来获取内部裸指针对应的对象值。返回_Tp的左值引用类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> add_lvalue_reference&lt;_Tp&gt;::type</span><br><span class="line"><span class="keyword">operator</span>*() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *__ptr_.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pointer get() const _NOEXCEPT</strong></p>
<p>获取内部的裸指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">first</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get_deleter() _NOEXCEPT</strong></p>
<p>获取内部的deleter</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">second</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get_deleter() const _NOEXCEPT</strong></p>
<p>获取内部的deleter，返回的是常亮。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">second</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>perator bool() const _NOEXCEPT</strong></p>
<p>定义bool操作符，对unique_ptr的bool化是判断内部的__ptr.first是否为空。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">first</span>() != <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get_deleter() const _NOEXCEPT</strong></p>
<p>获取内部的deleter，返回的是常亮。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.<span class="built_in">second</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>release() _NOEXCEPT</strong></p>
<p>释放裸指针的管理权，从__ptr中取出裸指针，将其返回，在__ptr_中放入一个空的裸指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">pointer <span class="title">release</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  pointer <span class="type">__t</span> = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">  __ptr_.<span class="built_in">first</span>() = <span class="built_in">pointer</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="type">__t</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>reset(pointer __p &#x3D; pointer()) _NOEXCEPT</strong></p>
<p>接收一个新的裸指针，如果没传参数默认为空的裸指针；将旧的裸指针从__ptr_中取出来，将新的裸指针放入到__ptr_中；然后调用deleter删除旧的裸指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  pointer __tmp = __ptr_.<span class="built_in">first</span>();</span><br><span class="line">  __ptr_.<span class="built_in">first</span>() = __p;</span><br><span class="line">  <span class="keyword">if</span> (__tmp)</span><br><span class="line">    __ptr_.<span class="built_in">second</span>()(__tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>swap(unique_ptr&amp; __u) _NOEXCEPT</strong></p>
<p>unique_ptr的交换就是把__ptr_进行交换。将pair中的裸指针和deleter进行交换。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr&amp; __u)</span> _NOEXCEPT </span>&#123;</span><br><span class="line">  __ptr_.<span class="built_in">swap</span>(__u.__ptr_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(__compressed_pair&amp; __x)</span></span></span><br><span class="line"><span class="function">  _<span class="title">NOEXCEPT_</span><span class="params">(__is_nothrow_swappable&lt;_T1&gt;::value &amp;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">             __is_nothrow_swappable&lt;_T2&gt;::value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> _VSTD::swap;</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">first</span>(), __x.<span class="built_in">first</span>());</span><br><span class="line">  <span class="built_in">swap</span>(<span class="built_in">second</span>(), __x.<span class="built_in">second</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>swap(unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, unique_ptr&lt;_Tp, _Dp&gt;&amp; __y) _NOEXCEPT</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Dp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">typename</span> enable_if&lt;</span><br><span class="line">    __is_swappable&lt;_Dp&gt;::value,</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">swap</span><span class="params">(unique_ptr&lt;_Tp, _Dp&gt;&amp; __x, unique_ptr&lt;_Tp, _Dp&gt;&amp; __y)</span> _NOEXCEPT </span>&#123;__x.<span class="built_in">swap</span>(__y);&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;&#x3D;</strong></p>
<p>定义&#x3D;&#x3D;比较操作符，直接比较内部的裸指针是否相等。其它比较符都一样都是直接比较裸指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_T1</span>, <span class="keyword">class</span> <span class="title class_">_D1</span>, <span class="keyword">class</span> <span class="title class_">_T2</span>, <span class="keyword">class</span> <span class="title class_">_D2</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="keyword">operator</span>==(<span class="type">const</span> unique_ptr&lt;_T1, _D1&gt;&amp; __x, <span class="type">const</span> unique_ptr&lt;_T2, _D2&gt;&amp; __y) &#123;<span class="keyword">return</span> __x.<span class="built_in">get</span>() == __y.<span class="built_in">get</span>();&#125;</span><br></pre></td></tr></table></figure>



<h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><p><strong>make_unique(Args&amp;&amp;… args)</strong></p>
<p>使用该函数创建时，_Tp不支持为数组。使用_Args参数来new一个_Tp对象，创建一个unique_ptr来维护该对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> __unique_if&lt;_Tp&gt;::<span class="function">__unique_single</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(_Args&amp;&amp;... __args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(_VSTD::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>make_unique(size_t n)</strong></p>
<p>该函数支持数组类型的创建，__n是数组的长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> __unique_if&lt;_Tp&gt;::<span class="function">__unique_array_unknown_bound</span></span><br><span class="line"><span class="function"><span class="title">make_unique</span><span class="params">(<span class="type">size_t</span> __n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_extent&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Up[__n]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>libc++源码分析之std::vector</title>
    <url>/2022/02/02/c++/libc++%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Bvector/</url>
    <content><![CDATA[<h1 id="std-vector"><a href="#std-vector" class="headerlink" title="std::vector"></a>std::vector</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="vector-base"><a href="#vector-base" class="headerlink" title="__vector_base"></a>__vector_base</h3><p>vector的基类，定义了vector的数据结构，在vector内部是使用对象数组来实现的，end - begin表示size，end_cap - begin表示capacity。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">__vector_base</span></span><br><span class="line">    : <span class="keyword">protected</span> __vector_base_common&lt;<span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pointer                                         __begin_; <span class="comment">// 数组第一个对象的首地址</span></span><br><span class="line">    pointer                                         __end_; <span class="comment">// 数组下一个待存储的对象的首地址</span></span><br><span class="line">    __compressed_pair&lt;pointer, allocator_type&gt; __end_cap_; <span class="comment">// 数组内存尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>vector(initializer_list<value_type> __il)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">vector</span>(initializer_list&lt;value_type&gt; __il)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    __get_db()-&gt;__insert_c(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (__il.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __vallocate(__il.<span class="built_in">size</span>()); <span class="comment">// 分配内存</span></span><br><span class="line">        __construct_at_end(__il.<span class="built_in">begin</span>(), __il.<span class="built_in">end</span>(), __il.<span class="built_in">size</span>()); <span class="comment">// 拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vector(size_type __n, const value_type&amp; __x)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">vector</span>(size_type __n, <span class="type">const</span> value_type&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    __get_db()-&gt;__insert_c(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (__n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __vallocate(__n); <span class="comment">// 分配内存</span></span><br><span class="line">        __construct_at_end(__n, __x); <span class="comment">// 拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vector(const vector&amp; __x)</strong><br>拷贝构造会拷贝整个对象数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">vector</span>(<span class="type">const</span> vector&amp; __x)</span><br><span class="line">    : __base(__alloc_traits::<span class="built_in">select_on_container_copy_construction</span>(__x.__alloc()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    __get_db()-&gt;__insert_c(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    size_type __n = __x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        __vallocate(__n); <span class="comment">// 分配内存</span></span><br><span class="line">        __construct_at_end(__x.__begin_, __x.__end_, __n); <span class="comment">// 拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vector(vector&amp;&amp; __x)</strong><br>移动构造只是简单的拷贝对象数组的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">vector</span>(vector&amp;&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">        _NOEXCEPT</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        _NOEXCEPT_(is_nothrow_move_constructible&lt;allocator_type&gt;::value)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    : __base(_VSTD::<span class="built_in">move</span>(__x.__alloc()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    __get_db()-&gt;__insert_c(<span class="keyword">this</span>);</span><br><span class="line">    __get_db()-&gt;<span class="built_in">swap</span>(<span class="keyword">this</span>, &amp;__x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__begin_ = __x.__begin_; <span class="comment">// 拷贝数组地址</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__end_ = __x.__end_;</span><br><span class="line">    <span class="keyword">this</span>-&gt;__end_cap() = __x.__end_cap();</span><br><span class="line">    __x.__begin_ = __x.__end_ = __x.__end_cap() = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p><strong>~vector()</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    ~<span class="built_in">vector</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        __annotate_delete();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">        __get_db()-&gt;__erase_c(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>~__vector_base()</strong><br>在基类的析构中，会对数据进行释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line">__vector_base&lt;_Tp, _Allocator&gt;::~__vector_base()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__begin_ != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">clear</span>(); <span class="comment">// 修改end指针，将size设置0，如果数组中存储的是对象，则调用对象的析构函数，如果是指针则跳过</span></span><br><span class="line">        __alloc_traits::<span class="built_in">deallocate</span>(__alloc(), __begin_, <span class="built_in">capacity</span>()); <span class="comment">// 释放分配的数组内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="vallocate"><a href="#vallocate" class="headerlink" title="__vallocate"></a>__vallocate</h3><p>分配指针大小的Tp数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__vallocate(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; <span class="built_in">max_size</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_length_error();</span><br><span class="line">    <span class="keyword">this</span>-&gt;__begin_ = <span class="keyword">this</span>-&gt;__end_ = __alloc_traits::<span class="built_in">allocate</span>(<span class="keyword">this</span>-&gt;__alloc(), __n); <span class="comment">// 分配Tp数组，将首地址保存到__begin，默认为空，所以__end也指向首地址</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__end_cap() = <span class="keyword">this</span>-&gt;__begin_ + __n; <span class="comment">// 保存分配的内存的尾指针</span></span><br><span class="line">    __annotate_new(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="construct-at-end"><a href="#construct-at-end" class="headerlink" title="__construct_at_end"></a>__construct_at_end</h3><p><strong>__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIterator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">    __is_cpp17_forward_iterator&lt;_ForwardIterator&gt;::value,</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">&gt;::type</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    _ConstructTransaction __tx(*<span class="keyword">this</span>, __n);</span><br><span class="line">    _VSTD::__construct_range_forward(<span class="keyword">this</span>-&gt;__alloc(), __first, __last, __tx.__pos_); <span class="comment">// 遍历填充，tx.pos为__end_指针，从end位置开始插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Alloc</span>, <span class="keyword">class</span> <span class="title class_">_Iter</span>, <span class="keyword">class</span> <span class="title class_">_Ptr</span>&gt;</span><br><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span> __construct_range_forward(_Alloc&amp; __a, _Iter __begin1, _Iter __end1, _Ptr&amp; __begin2) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> allocator_traits&lt;_Alloc&gt; _Traits;</span><br><span class="line">    <span class="keyword">for</span> (; __begin1 != __end1; ++__begin1, (<span class="type">void</span>) ++__begin2) &#123; </span><br><span class="line">        _Traits::<span class="built_in">construct</span>(__a, _VSTD::__to_address(__begin2), *__begin1); <span class="comment">// 循环拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>__construct_at_end(size_type __n, const_reference __x)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__construct_at_end(size_type __n, const_reference __x)</span><br><span class="line">&#123;</span><br><span class="line">    _ConstructTransaction __tx(*<span class="keyword">this</span>, __n);</span><br><span class="line">    const_pointer __new_end = __tx.__new_end_;</span><br><span class="line">    <span class="keyword">for</span> (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) &#123;</span><br><span class="line">        __alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;__alloc(), _VSTD::__to_address(__pos), __x); <span class="comment">// 循环拷贝数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>clear函数会修改end指针，将size设置为0，如果数组中存储的是对象，则调用对象的析构函数，如果是指针则跳过，并不会影响capacity，也不会释放内存。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size_type __old_size = <span class="built_in">size</span>();</span><br><span class="line">    __base::<span class="built_in">clear</span>(); <span class="comment">// 主要逻辑都在基类函数中</span></span><br><span class="line">    __annotate_shrink(__old_size);</span><br><span class="line">    __invalidate_all_iterators();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    __destruct_at_end(__begin_); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__vector_base&lt;_Tp, _Allocator&gt;::__destruct_at_end(pointer __new_last) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    pointer __soon_to_be_end = __end_;</span><br><span class="line">    <span class="keyword">while</span> (__new_last != __soon_to_be_end)</span><br><span class="line">        __alloc_traits::<span class="built_in">destroy</span>(__alloc(), _VSTD::__to_address(--__soon_to_be_end)); <span class="comment">// 遍历已经存储的对象，如果该对象不是指针，则会调用对象的析构函数</span></span><br><span class="line">    __end_ = __new_last; <span class="comment">// 更新end，指向begin，size为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="operator-x3D"><a href="#operator-x3D" class="headerlink" title="operator&#x3D;"></a>operator&#x3D;</h3><p><strong>operator&#x3D;(vector&amp;&amp; __x)</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;&amp;</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>=(vector&amp;&amp; __x)</span><br><span class="line">    _NOEXCEPT_((__noexcept_move_assign_container&lt;_Allocator, __alloc_traits&gt;::value))</span><br><span class="line">&#123;</span><br><span class="line">    __move_assign(__x, <span class="built_in">integral_constant</span>&lt;<span class="type">bool</span>,</span><br><span class="line">          __alloc_traits::propagate_on_container_move_assignment::value&gt;()); <span class="comment">// 销毁当前数组，拷贝x中数组的指针到当前对象，并将x中的数组置为空</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>operator&#x3D;(const vector&amp; __x)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;&amp;</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> vector&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;__x)</span><br><span class="line">    &#123;</span><br><span class="line">        __base::__copy_assign_alloc(__x);</span><br><span class="line">        <span class="built_in">assign</span>(__x.__begin_, __x.__end_); <span class="comment">// 替换数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h3><p>清除当前数据，再将first到last的数据拷贝过来，不足会自动扩容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIterator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> enable_if</span><br><span class="line">&lt;</span><br><span class="line">     __is_cpp17_input_iterator  &lt;_InputIterator&gt;::value &amp;&amp;</span><br><span class="line">    !__is_cpp17_forward_iterator&lt;_InputIterator&gt;::value &amp;&amp;</span><br><span class="line">    is_constructible&lt;</span><br><span class="line">       _Tp,</span><br><span class="line">       <span class="keyword">typename</span> iterator_traits&lt;_InputIterator&gt;::reference&gt;::value,</span><br><span class="line">    <span class="type">void</span></span><br><span class="line">&gt;::type</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">assign</span>(_InputIterator __first, _InputIterator __last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">clear</span>(); <span class="comment">// 清空当前数组，重置end指向begin</span></span><br><span class="line">    <span class="keyword">for</span> (; __first != __last; ++__first)</span><br><span class="line">        __emplace_back(*__first); <span class="comment">// 拷贝插入到end位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h3><p>根据参数构造对象，并插入到end位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::reference</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">emplace_back</span>(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__end_ &lt; <span class="keyword">this</span>-&gt;__end_cap()) </span><br><span class="line">    &#123;</span><br><span class="line">        __construct_one_at_end(_VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 如果不需要扩容，则直接拷贝到end位置，end++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __emplace_back_slow_path(_VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 需要扩容</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt; 14</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">back</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容前size为4，capacity为4<br>    . . . .<br>split_buffer会分配一段内存，capacity为8，并将end指向下标为4的位置<br>    。。。。。。。。<br>construct后，在end位置构造新对象<br>    。。。。. 。。。<br>swap_out_circular_buffer会先将当前数组中的对象拷贝到split_buffer的数组中，然后再把当前数组与split_buffer中的数组进行交换<br>    . . . . . 。。。<br>这样当前vector中保存的就是扩容后的新数组，在split_buffer中保存的就是旧数组，函数结束，split_buffer析构函数中会对旧数组进行销毁    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__emplace_back_slow_path(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">    <span class="comment">//2倍扩容，capacity = 2 * capacity</span></span><br><span class="line">    __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(<span class="built_in">size</span>() + <span class="number">1</span>), <span class="built_in">size</span>(), __a); <span class="comment">// 重新分配数组内存，从第size()位置开始存储</span></span><br><span class="line"><span class="comment">//    __v.emplace_back(_VSTD::forward&lt;_Args&gt;(__args)...);</span></span><br><span class="line">    __alloc_traits::<span class="built_in">construct</span>(__a, _VSTD::__to_address(__v.__end_), _VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 将当前对象构造到size()位置</span></span><br><span class="line">    __v.__end_++; <span class="comment">// end指向size()+1</span></span><br><span class="line">    __swap_out_circular_buffer(__v); <span class="comment">// 将[0,size-1]的数据拷贝到split_buffer中，并将交换数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emplace"><a href="#emplace" class="headerlink" title="emplace"></a>emplace</h3><p>根据参数构造对象，并插入到指定位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... _Args&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::iterator</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">emplace</span>(const_iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    _LIBCPP_ASSERT(__get_const_db()-&gt;__find_c_from_i(&amp;__position) == <span class="keyword">this</span>,</span><br><span class="line">        <span class="string">&quot;vector::emplace(iterator, x) called with an iterator not&quot;</span></span><br><span class="line">        <span class="string">&quot; referring to this vector&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    pointer __p = <span class="keyword">this</span>-&gt;__begin_ + (__position - <span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__end_ &lt; <span class="keyword">this</span>-&gt;__end_cap())</span><br><span class="line">    &#123;  <span class="comment">// 无需扩容</span></span><br><span class="line">        <span class="keyword">if</span> (__p == <span class="keyword">this</span>-&gt;__end_)</span><br><span class="line">        &#123; <span class="comment">// 插入到尾部</span></span><br><span class="line">            __construct_one_at_end(_VSTD::forward&lt;_Args&gt;(__args)...);  <span class="comment">// 插入到end</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// 插入到中间</span></span><br><span class="line">            __temp_value&lt;value_type, _Allocator&gt; __tmp(<span class="keyword">this</span>-&gt;__alloc(), _VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 构造对象</span></span><br><span class="line">            __move_range(__p, <span class="keyword">this</span>-&gt;__end_, __p + <span class="number">1</span>);  <span class="comment">// 将position后面的元素后移一位</span></span><br><span class="line">            *__p = _VSTD::<span class="built_in">move</span>(__tmp.<span class="built_in">get</span>()); <span class="comment">// 将构造的对象放入到position位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">        __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(<span class="built_in">size</span>() + <span class="number">1</span>), __p - <span class="keyword">this</span>-&gt;__begin_, __a); <span class="comment">// 扩容，end位置指向position</span></span><br><span class="line">        __v.<span class="built_in">emplace_back</span>(_VSTD::forward&lt;_Args&gt;(__args)...); <span class="comment">// 向end位置插入对象</span></span><br><span class="line">        __p = __swap_out_circular_buffer(__v, __p); <span class="comment">// 拷贝数据，交换数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __make_iter(__p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(<span class="keyword">this</span>-&gt;__end_ - <span class="keyword">this</span>-&gt;__begin_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">_LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;size_type&gt;(__end_cap() - __begin_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__begin_ == <span class="keyword">this</span>-&gt;__end_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="reserve"><a href="#reserve" class="headerlink" title="reserve"></a>reserve</h3><p>设置分配内存大小，设置的是cap大小，size不会变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">reserve</span>(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt; <span class="built_in">capacity</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">        __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__n, <span class="built_in">size</span>(), __a); <span class="comment">// 扩容</span></span><br><span class="line">        __swap_out_circular_buffer(__v); <span class="comment">// 拷贝数据，并交换数组指针，__split_buffer析构时销毁旧数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit"></a>shrink_to_fit</h3><p>将capacity缩小为size大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">shrink_to_fit</span>() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">capacity</span>() &gt; <span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">            allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">            __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(<span class="built_in">size</span>(), <span class="built_in">size</span>(), __a);</span><br><span class="line">            __swap_out_circular_buffer(__v);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::reference</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="keyword">operator</span>[](size_type __n) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__n &lt; <span class="built_in">size</span>(), <span class="string">&quot;vector[] index out of bounds&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__begin_[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="at"><a href="#at" class="headerlink" title="at"></a>at</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::reference</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">at</span>(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= <span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">this</span>-&gt;__throw_out_of_range();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;__begin_[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h3><p>将对象插入到end位置，和emplace_back逻辑一致，只是一个接收的对象，一个接收的构造对象的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">push_back</span>(const_reference __x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__end_ != <span class="keyword">this</span>-&gt;__end_cap())</span><br><span class="line">    &#123;</span><br><span class="line">        __construct_one_at_end(__x); <span class="comment">// 直接插入到end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __push_back_slow_path(__x); <span class="comment">// 扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑和__emplace_back_slow_path一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Up</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LIBCPP_CXX03_LANG</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__push_back_slow_path(_Up&amp;&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::__push_back_slow_path(_Up&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">    __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(<span class="built_in">size</span>() + <span class="number">1</span>), <span class="built_in">size</span>(), __a); <span class="comment">// 扩容</span></span><br><span class="line">    <span class="comment">// __v.push_back(_VSTD::forward&lt;_Up&gt;(__x));</span></span><br><span class="line">    __alloc_traits::<span class="built_in">construct</span>(__a, _VSTD::__to_address(__v.__end_), _VSTD::forward&lt;_Up&gt;(__x)); <span class="comment">// 构造对象到end位置</span></span><br><span class="line">    __v.__end_++; <span class="comment">// end++</span></span><br><span class="line">    __swap_out_circular_buffer(__v); <span class="comment">// 交换数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>插入对象到指定位置，和emplace逻辑一致，只是一个接收的对象，一个接收的构造对象的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::iterator</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">insert</span>(const_iterator __position, const_reference __x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    _LIBCPP_ASSERT(__get_const_db()-&gt;__find_c_from_i(&amp;__position) == <span class="keyword">this</span>,</span><br><span class="line">        <span class="string">&quot;vector::insert(iterator, x) called with an iterator not&quot;</span></span><br><span class="line">        <span class="string">&quot; referring to this vector&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    pointer __p = <span class="keyword">this</span>-&gt;__begin_ + (__position - <span class="built_in">begin</span>());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;__end_ &lt; <span class="keyword">this</span>-&gt;__end_cap())</span><br><span class="line">    &#123; <span class="comment">// 无需扩容</span></span><br><span class="line">        <span class="keyword">if</span> (__p == <span class="keyword">this</span>-&gt;__end_)</span><br><span class="line">        &#123; <span class="comment">// 插入到尾部</span></span><br><span class="line">            __construct_one_at_end(__x); <span class="comment">// 插入到end</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="comment">// 插入到中间</span></span><br><span class="line">            __move_range(__p, <span class="keyword">this</span>-&gt;__end_, __p + <span class="number">1</span>); <span class="comment">// 将position后面的元素后移一位</span></span><br><span class="line">            const_pointer __xr = pointer_traits&lt;const_pointer&gt;::<span class="built_in">pointer_to</span>(__x);</span><br><span class="line">            <span class="keyword">if</span> (__p &lt;= __xr &amp;&amp; __xr &lt; <span class="keyword">this</span>-&gt;__end_)</span><br><span class="line">                ++__xr;</span><br><span class="line">            *__p = *__xr; <span class="comment">// 将构造的对象放入到position位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        allocator_type&amp; __a = <span class="keyword">this</span>-&gt;__alloc();</span><br><span class="line">        __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(<span class="built_in">size</span>() + <span class="number">1</span>), __p - <span class="keyword">this</span>-&gt;__begin_, __a); <span class="comment">// 扩容，end位置指向position</span></span><br><span class="line">        __v.<span class="built_in">push_back</span>(__x); <span class="comment">// 向end位置插入对象</span></span><br><span class="line">        __p = __swap_out_circular_buffer(__v, __p); <span class="comment">// 拷贝数据，交换数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __make_iter(__p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><p>删除指定位置的对象，需要注意的是<strong>erase所触发的析构函数并不是删除的那个对象的析构函数，而是最后一个元素的析构函数</strong>。<br>假设vector中有元素1 2 3 4，此时删除2这个元素，那么首先erase会进行move操作，变成1 3 4 4，对于整个数组来说，最后一位的4明显应该为空且应该被销毁的，并且对于删除操作来说，一次删除只应该调用一次析构，所以此处选择调用最后一个4的析构，而并不是删除的2的析构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span><br><span class="line"><span class="keyword">typename</span> vector&lt;_Tp, _Allocator&gt;::iterator</span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">erase</span>(const_iterator __position)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    _LIBCPP_ASSERT(__get_const_db()-&gt;__find_c_from_i(&amp;__position) == <span class="keyword">this</span>,</span><br><span class="line">        <span class="string">&quot;vector::erase(iterator) called with an iterator not&quot;</span></span><br><span class="line">        <span class="string">&quot; referring to this vector&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    _LIBCPP_ASSERT(__position != <span class="built_in">end</span>(),</span><br><span class="line">        <span class="string">&quot;vector::erase(iterator) called with a non-dereferenceable iterator&quot;</span>);</span><br><span class="line">    difference_type __ps = __position - <span class="built_in">cbegin</span>();</span><br><span class="line">    pointer __p = <span class="keyword">this</span>-&gt;__begin_ + __ps; <span class="comment">// 计算position</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__destruct_at_end(_VSTD::<span class="built_in">move</span>(__p + <span class="number">1</span>, <span class="keyword">this</span>-&gt;__end_, __p)); <span class="comment">// 通过std::move将[position+1, end-1]位置的元素移动到[position, end-2]位置，并调用end-1位置对象的析构函数</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;__invalidate_iterators_past(__p<span class="number">-1</span>);</span><br><span class="line">    iterator __r = __make_iter(__p);</span><br><span class="line">    <span class="keyword">return</span> __r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>设置添加的元素长度，设置的是size长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">resize</span>(size_type __sz)</span><br><span class="line">&#123;</span><br><span class="line">    size_type __cs = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (__cs &lt; __sz)</span><br><span class="line">        <span class="keyword">this</span>-&gt;__append(__sz - __cs); <span class="comment">// 如果当前size不足，则填充（通过无参构造构造出对象）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (__cs &gt; __sz)</span><br><span class="line">        <span class="keyword">this</span>-&gt;__destruct_at_end(<span class="keyword">this</span>-&gt;__begin_ + __sz); <span class="comment">// 如果当前size超出，重新调整end位置，并调用超出部分的析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>交换两个vector中的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">vector&lt;_Tp, _Allocator&gt;::<span class="built_in">swap</span>(vector&amp; __x)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_STD_VER &gt;= 14</span></span><br><span class="line">    _NOEXCEPT</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||</span><br><span class="line">                __is_nothrow_swappable&lt;allocator_type&gt;::value)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#123;</span><br><span class="line">    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||</span><br><span class="line">                   <span class="keyword">this</span>-&gt;__alloc() == __x.__alloc(),</span><br><span class="line">                   <span class="string">&quot;vector::swap: Either propagate_on_container_swap must be true&quot;</span></span><br><span class="line">                   <span class="string">&quot; or the allocators must compare equal&quot;</span>);</span><br><span class="line">    _VSTD::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;__begin_, __x.__begin_);</span><br><span class="line">    _VSTD::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;__end_, __x.__end_);</span><br><span class="line">    _VSTD::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;__end_cap(), __x.__end_cap());</span><br><span class="line">    _VSTD::__swap_allocator(<span class="keyword">this</span>-&gt;__alloc(), __x.__alloc(),</span><br><span class="line">        <span class="built_in">integral_constant</span>&lt;<span class="type">bool</span>,__alloc_traits::propagate_on_container_swap::value&gt;());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _LIBCPP_DEBUG_LEVEL == 2</span></span><br><span class="line">    __get_db()-&gt;<span class="built_in">swap</span>(<span class="keyword">this</span>, &amp;__x);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="std-vector-lt-bool-gt"><a href="#std-vector-lt-bool-gt" class="headerlink" title="std::vector&lt;bool&gt;"></a>std::vector&lt;bool&gt;</h1><p>vector&lt;bool&gt;是vector对bool的特化，但是特殊的是，vector&lt;bool&gt;为了节省内存，其内部存储的并不是bool，因为一个bool占用了一个字节，而对于bool来说只有true和false，一位就可以表示，所以在vector&lt;bool&gt;中是按照位来存储的，而通过operator[]和at获取到的也并不是对应的bool值，而是其内部的一个bit_reference类。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> __bit_reference&lt;vector&gt;                  reference;</span><br></pre></td></tr></table></figure>

<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="vector-lt-bool-gt"><a href="#vector-lt-bool-gt" class="headerlink" title="vector&lt;bool&gt;"></a>vector&lt;bool&gt;</h3><p>vector&lt;bool&gt;并没有继承vector_base基类，所以其数据结构是自己定义的，里面维护了一个size_t类型的数组，数组的每个元素有32位，可以存储32个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Allocator</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_LIBCPP_TEMPLATE_VIS</span> vector&lt;<span class="type">bool</span>, _Allocator&gt;</span><br><span class="line">    : <span class="keyword">private</span> __vector_base_common&lt;<span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __storage_pointer                                      __begin_; <span class="comment">// size_t指针，32位，可以存储32个元素</span></span><br><span class="line">    size_type                                              __size_;  <span class="comment">// 存储元素的个数</span></span><br><span class="line">    __compressed_pair&lt;size_type, __storage_allocator&gt; __cap_alloc_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><h3 id="operator-1"><a href="#operator-1" class="headerlink" title="operator[]"></a>operator[]</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY reference <span class="keyword">operator</span>[](size_type __n) &#123;</span><br><span class="line">    <span class="keyword">return</span> __make_ref(__n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个元素都可以存储32个值，所以对于pos需要对__bits_per_word进行转换，当pos为40时，需要查找的数组的第2个元素也就是begin+1位置，而对应的位就是第8位。reference接收两个参数，一个是对应的元素，一个是对应的位。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">reference __make_ref(size_type __pos) _NOEXCEPT &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reference</span>(__begin_ + __pos / __bits_per_word, __storage_type(<span class="number">1</span>) &lt;&lt; __pos % __bits_per_word); <span class="comment">// 将外部位置转换为bit位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>libc++</tag>
      </tags>
  </entry>
  <entry>
    <title>废弃std::iterator</title>
    <url>/2020/05/24/c++/%E5%BA%9F%E5%BC%83iterator/</url>
    <content><![CDATA[<p><img src="/2020/05/24/c++/%E5%BA%9F%E5%BC%83iterator/git-change.png" alt="git-change"></p>
<p>在C++14之前，所有的Iterator都是继承自std::iterator类，在这个类中定义了五个type </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Category</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Distance</span> = <span class="type">ptrdiff_t</span>, </span><br><span class="line">         <span class="keyword">class</span> Pointer = T*, <span class="keyword">class</span> Reference = T&amp;&gt; </span><br><span class="line"><span class="keyword">struct</span> iterator </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">typedef</span> T         value_type; </span><br><span class="line">    <span class="keyword">typedef</span> Distance  difference_type; </span><br><span class="line">    <span class="keyword">typedef</span> Pointer   pointer; </span><br><span class="line">    <span class="keyword">typedef</span> Reference reference; </span><br><span class="line">    <span class="keyword">typedef</span> Category  iterator_category; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>这五个type是为了在iterator_traits中提供给外部函数获取iterator的type </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::difference_type difference_type; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::value_type value_type; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::pointer pointer; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::reference reference; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>之前是为了方便，才定义了一个基类，让所有的Iterator来继承。 </p>
<p>在C++14后，废弃了std::iterator，让各自的iterator类自己定义五个type，这也是上面change log的内容； </p>
<p>对于reverse_iterator来说，之前继承了iterator，现在删除后，其offset会发生变化，第一个成员的Offset会从4bit变成0bit； </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Guaranteed copy elision 缺省复制</title>
    <url>/2020/05/24/c++/%E7%BC%BA%E7%9C%81%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>在c++17上，通过对value category修改，glvalue提供要被初始化的对象的地址，prvalue提供initializer。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">A</span>(A &amp;&amp;prev) = <span class="keyword">delete</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  A(A &amp;&amp;prev) &#123; std::cout &lt;&lt; &quot;Print1&quot;; &#125; </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  A a = <span class="built_in">A</span>(); </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;aaa&quot;</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>所以上面的代码，在c++17之前是编译不过的，A a &#x3D; A() 这里调用了move构造，虽然编译器会优化掉，不会真正调用，但是move构造必须留着，不能删除。 </p>
<p>但是在c++17后，是直接在value category层级，就保证了不会调用move构造。 </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>静态库与动态库之间的那些事</title>
    <url>/2020/05/24/c++/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是一种可执行代码的二进制形式，可以被操作系统载入到内存中执行，库根据链接不同分为静态库和动态库。</p>
<p>可执行文件生成的过程为:</p>
<blockquote>
<p>c -&gt; 预编译 -&gt; 编译器 -&gt; 汇编代码 -&gt; 汇编器 -&gt; 目标代码 -&gt; 链接器 -&gt; 可执行代码</p>
</blockquote>
<ul>
<li>预编译：处理宏定义、删除注释、添加行号</li>
<li>编译器：词法分析、语法分析、语义分析、代码优化</li>
<li>汇编器：翻译成二进制</li>
<li>链接器：合并符号表、符号解析、分配地址、重定位符号表</li>
</ul>
<span id="more"></span>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>将多个独立的模块（目标文件、静态库、动态库）链接在一起，建立全局符号表，然后再根据全局符号表修正所有的重定向表。重定向表中保留了当前目标文件中那些未知跳转地址的符号。</p>
<p>在编译a.o目标文件时，如果a库里面引用了其它库的符号，则在a.o的重定位表中该符号是没有对应的地址的，如果强行将a.o链接成可执行文件会出错。 此时就需要链接，假设b.o里面正好有该符号的实现，则将a.o和b.o链接，建立全局符号表，然后修正a.o中的符号对应的地址。</p>
<h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库被链接到可执行程序中采用的是静态链接。</p>
<h5 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h5><p>可执行程序在编译的时候，会将所有被链接的静态库中所有使用到的目标文件都拷贝到可执行文件中，并进行链接，重新修正所有的重定向表。</p>
<h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>动态库被链接到可执行程序中采用的是动态链接。</p>
<h5 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h5><p>动态链接在编译的时候并不会将链接对象的内容拷贝到当前库中，仅仅在其中加入了所调用函数的描述信息用来重定位。直到链接对象被装载到内存中时，才会发生真正的链接，此时才会修正所有的重定向表，将目标文件中的未知符号地址修正。</p>
<h5 id="静态装载"><a href="#静态装载" class="headerlink" title="静态装载"></a>静态装载</h5><p>静态加载的方式通过在编译的时候加上 -l 来指定当前库所依赖的动态库，当可执行程序启动的时候，会自动将-l 依赖的动态库全部加载到内存中，此时加载进来的动态库会进行链接操作。</p>
<h5 id="动态装载"><a href="#动态装载" class="headerlink" title="动态装载"></a>动态装载</h5><p>想要动态加载的动态库，在编译时需要加上 -shared -fPIC来生成与位置无关的代码，生成的代码中使用的都是相对地址。加载使用dlopen函数以指定模式打开指定的动态库，通过dlopen来调用能够确保多个进程调用时内存中只存在一份。</p>
<p>动态加载就是在程序执行的时候，需要用到动态库的函数时，再加载该动态库。</p>
<p><strong>JNI就是通过动态加载来实现的</strong></p>
<h3 id="具体场景分析"><a href="#具体场景分析" class="headerlink" title="具体场景分析"></a>具体场景分析</h3><h4 id="静态库引用静态库"><a href="#静态库引用静态库" class="headerlink" title="静态库引用静态库"></a>静态库引用静态库</h4><p>假设有A、B、C、D四个静态库，其中A引用了C，B引用了D，可执行程序依赖了A、B。</p>
<ul>
<li>当A、B编译的时候，需要依赖C、D</li>
<li>当可执行程序编译的时候，需要依赖A、B、C、D</li>
<li>可执行程序编译完成后，会将A、B、C、D中所有使用到的目标文件copy到可执行文件中</li>
</ul>
<p>所以如果当A、B、C、D中有重名的函数符号时，会被覆盖，第一个被链接的库中的重名函数会成效，而其他库中的会被丢弃。（因为在重定向表中一个符号只会有一个跳转地址）</p>
<h4 id="静态库引用动态库"><a href="#静态库引用动态库" class="headerlink" title="静态库引用动态库"></a>静态库引用动态库</h4><p>假设有A、B两个静态库，C、D两个动态库，其中A引用了C，B引用了D，可执行程序依赖了A、B。</p>
<ul>
<li>当A、B编译的时候，需要依赖C、D</li>
<li>当可执行程序编译的时候，需要依赖A、B (因为A、B在编译的时候已经记录了引用的C、D库信息)</li>
<li>可执行程序编译完成后，会将A、B所有使用到的目标文件copy到可执行文件中</li>
<li>当可执行程序运行的时候，会将C、D库加载到内存中，并链接</li>
</ul>
<p>所以如果当A、B、C、D中有重名的函数符号时，会被覆盖，第一个被链接的库中的重名函数会生效，而其他库中的会被丢弃。（因为在重定向表中一个符号只会有一个跳转地址）</p>
<h4 id="动态库引用静态库"><a href="#动态库引用静态库" class="headerlink" title="动态库引用静态库"></a>动态库引用静态库</h4><p>假设有A、B两个动态库，C、D两个静态库，其中A引用了C，B引用了D，可执行程序依赖了A、B。</p>
<ul>
<li>当A、B编译的时候，需要依赖C、D，此时C、D静态库会被触发链接，将库内被A、B引用的目标文件copy到A、B库中，并修正重定向表。</li>
<li>当可执行程序编译的时候，需要依赖A、B（因为C、D已经包含到了A、B中）</li>
<li>当可执行程序运行的时候，会将A、B库加载到内存中，并链接</li>
</ul>
<p>所以如果A、B中有重名函数符号时，依旧是先链接的先生效，但是如果C、D中有重名函数时，由于在A、B中已经修正了重名名表，所以不会发生冲突。</p>
<h4 id="动态库引用动态库"><a href="#动态库引用动态库" class="headerlink" title="动态库引用动态库"></a>动态库引用动态库</h4><p>假设有A、B两个动态库，C、D两个动态库，其中A引用了C，B引用了D，可执行程序依赖了A、B。</p>
<ul>
<li>当A、B编译的时候，需要依赖C、D</li>
<li>当可执行程序编译的时候，需要依赖A、B</li>
<li>当可执行程序运行的时候，会将A、B、C、D库加载到内存中，并链接</li>
</ul>
<p>动态库的重名覆盖是根据链接的顺序决定的，第一个被链接的库中的重名函数会生效。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>EGL-入门</title>
    <url>/2022/08/06/cg/EGL-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="EGL"><a href="#EGL" class="headerlink" title="EGL"></a>EGL</h1><p>通过Surface对象创建一个EGLSurface，将其连接到Surface的BufferQueue上，EGLSurface将会作为一个生产方，会将OpenGL-ES生产的缓冲区加入到该BufferQueue中，然后由该Surface的消费方进行处理。</p>
<p>Surface是一个生产方，EGLSurface也是一个独立的生产方。</p>
<p>一个Surface一次只能和一个EGLSurface进行连接，可以通过断开，然后重新连接另一个EGLSurface。</p>
<span id="more"></span>

<h2 id="eglGetDisplay"><a href="#eglGetDisplay" class="headerlink" title="eglGetDisplay"></a>eglGetDisplay</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前设备中默认屏幕的handle，display对象可以认为就是一块物理的屏幕，如果没有对应的display，则返回EGL_NO_DISPLAY。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((display = <span class="built_in">eglGetDisplay</span>(EGL_DEFAULT_DISPLAY)) == EGL_NO_DISPLAY) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglGetDisplay&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eglInitialize"><a href="#eglInitialize" class="headerlink" title="eglInitialize"></a>eglInitialize</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对获取的屏幕对egl进行初始化（display，返回的主版本号,返回的次版本号）</span></span><br><span class="line">EGLint major, minor;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglInitialize</span>(display, &amp;major, &amp;minor) || major == <span class="literal">NULL</span> || minor == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglInitialize&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h2 id="eglChooseConfig"><a href="#eglChooseConfig" class="headerlink" title="eglChooseConfig"></a>eglChooseConfig</h2><p> surface类型有三种，window_surface、pbuffer_surface、pixmap_surface，只有window_surface和window有关联，可以在window上显示。</p>
<p>绘制模式有两种，back buffer、single buffer，window_surface使用的是back buffer，back buffer是一块GPU中的buffer，可以通过EGL显示在屏幕上；而single buffer 是保存在内存中的位图，不支持显示在屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> EGLint attribs[] = &#123;</span><br><span class="line">     <span class="comment">// 设置surface类型</span></span><br><span class="line">    EGL_SURFACE_TYPE, EGL_WINDOW_BIT,</span><br><span class="line">    <span class="comment">// 指定opengl-es版本为2.0</span></span><br><span class="line">    EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,</span><br><span class="line">    EGL_BLUE_SIZE, <span class="number">8</span>,</span><br><span class="line">    EGL_GREEN_SIZE, <span class="number">8</span>,</span><br><span class="line">    EGL_RED_SIZE, <span class="number">8</span>,</span><br><span class="line">    EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line">EGLConfig config;</span><br><span class="line">EGLint numConfigs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取设备中支持指定属性的配置集合（display，指定的属性，输出的配置，输出配置的个数，所有支持指定属性的配置的个数）</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglChooseConfig</span>(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs)) &#123;</span><br><span class="line">     <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglChooseConfig&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eglCreateWindowSurface"><a href="#eglCreateWindowSurface" class="headerlink" title="eglCreateWindowSurface"></a>eglCreateWindowSurface</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个提供给opengl-es绘制的surface（display，配置，原生window，指定属性）</span></span><br><span class="line"><span class="keyword">if</span> (!(eglSurface = <span class="built_in">eglCreateWindowSurface</span>(display, config, aNativeWindow, <span class="number">0</span>))) &#123;</span><br><span class="line">    <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglCreateWindowSurface&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// android中创建NativeWindow</span></span><br><span class="line">ANativeWindow *pNativeWindow = <span class="built_in">ANativeWindow_fromSurface</span>(jenv, surface);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="eglCreateContext"><a href="#eglCreateContext" class="headerlink" title="eglCreateContext"></a>eglCreateContext</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> EGLint context_attribs[] = &#123;</span><br><span class="line">    <span class="comment">// 设置context针对的opengl-es的版本，（EGL_NONE设置的是默认值，为1）</span></span><br><span class="line">    <span class="comment">// 此处的版本需要和上面的EGL_RENDERABLE_TYPE 对应</span></span><br><span class="line">    EGL_CONTEXT_CLIENT_VERSION, <span class="number">2</span>, EGL_NONE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建context，在context中保存了opengl-es的状态信息 （display，配置，共享context的handle 一般设为null，属性）</span></span><br><span class="line"><span class="comment">// 一个display可以创建多个context</span></span><br><span class="line"><span class="keyword">if</span> (!(context = <span class="built_in">eglCreateContext</span>(display, config, <span class="number">0</span>, context_attribs))) &#123;</span><br><span class="line">     <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglCreateContext&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eglMakeCurrent"><a href="#eglMakeCurrent" class="headerlink" title="eglMakeCurrent"></a>eglMakeCurrent</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将上面创建的context绑定到当前线程上，并将context与surface进行关联。当makeCurrent执行后，就可以调用opengl-es的api对context中的状态集进行设定，</span></span><br><span class="line"><span class="comment">// 然后进而向surface中绘制内容，再把surface中的内容读取出来。</span></span><br><span class="line"><span class="comment">// 一个线程中enable状态的context只能有一个，如果当前线程已经有了一个enable状态的context，那么会先执行其flush操作，将没有执行完成的命令全部执行完成，然后将其改为disable状态，将新传入的context改为enable状态。</span></span><br><span class="line"><span class="comment">// 如果想要释放当前的context,也就是将当前的context disable,那么将第二个和第三个参数设置为 EGL_NO_SURFACE,第四个参数设置为 EGL_NO_CONTEXT即可。</span></span><br><span class="line"><span class="comment">// context enable后，视口大小和裁剪大小都会被设置为surface的尺寸</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglMakeCurrent</span>(display, eglSurface, eglSurface, context)) &#123;</span><br><span class="line">     <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglMakeCurrent&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="eglSwapBuffers"><a href="#eglSwapBuffers" class="headerlink" title="eglSwapBuffers"></a>eglSwapBuffers</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当opengl-es将内容绘制完成，调用该方法将该缓冲区加入到Surface的BufferQueue中</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">eglSwapBuffers</span>(display, eglSurface)) &#123;</span><br><span class="line">     <span class="built_in">LOGE</span>(<span class="string">&quot;witgao&quot;</span>, <span class="string">&quot;eglSwapBuffers&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>EGL</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>GLSL-入门</title>
    <url>/2022/08/06/cg/GLSL-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="GLSL"><a href="#GLSL" class="headerlink" title="GLSL"></a>GLSL</h1><p>OpenGL的着色器使用GLSL语言编写，类C风格。一个着色器由变量声明和main函数组成， 能声明的变量数量是有限的，具体由硬件决定。</p>
<h2 id="顶点着色器样例"><a href="#顶点着色器样例" class="headerlink" title="顶点着色器样例"></a>顶点着色器样例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="comment">// 定义两个属性，通过location指定该属性的索引值</span></span><br><span class="line">layout(location = <span class="number">0</span>) in vec4 vPosition;</span><br><span class="line">layout(location = <span class="number">1</span>) in vec4 aTextureCoord;</span><br><span class="line"><span class="comment">// 定义一个全局常量</span></span><br><span class="line">uniform mat4 uTextureMatrix;</span><br><span class="line"><span class="comment">// 输出一个属性给片段着色器</span></span><br><span class="line">out vec2 yuvTexCoords;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 输出顶点坐标</span></span><br><span class="line">    gl_Position = uTextureMatrix * vPosition;</span><br><span class="line">    yuvTexCoords = aTextureCoord;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="片段着色器样例"><a href="#片段着色器样例" class="headerlink" title="片段着色器样例"></a>片段着色器样例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="meta">#extension GL_OES_EGL_image_external_essl3 : require</span></span><br><span class="line">precision mediump <span class="type">float</span>;</span><br><span class="line">uniform samplerExternalOES yuvTexSampler;</span><br><span class="line">in vec2 yuvTexCoords;</span><br><span class="line">out vec4 fragColor;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    fragColor = texture(yuvTexSampler,yuvTexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uniform"><a href="#uniform" class="headerlink" title="uniform"></a>uniform</h2><p>Uniform是一种从CPU中向GPU中的着色器发送数据的方式，uniform是全局的，在每个着色器对象中都是独一无二的，可以被任意着色器访问；uniform会一直保存数据直到被更新。</p>
<p>通过glGetUniformLocation获取uniform的位置，使用glUniform4f设置uniform的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> vertexColorLocation = glGetUniformLocation(shaderProgram, <span class="string">&quot;ourColor&quot;</span>);</span><br><span class="line">glUniform4f(vertexColorLocation, <span class="number">0.0f</span>, greenValue, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br></pre></td></tr></table></figure>

<h2 id="in、out"><a href="#in、out" class="headerlink" title="in、out"></a>in、out</h2><p>in关键字表示该变量为着色器的输入，out关键字表示该变量为着色器的输出。借助in、out着色器之间可以发送数据，顶点着色器定义同名的out变量，片段着色器定义同名的in变量就可以接收数据（示例中的yuvTexCoords）。</p>
<h2 id="片段插值（Fragment-Interpolation"><a href="#片段插值（Fragment-Interpolation" class="headerlink" title="片段插值（Fragment Interpolation)"></a>片段插值（Fragment Interpolation)</h2><p>光栅化时会根据每个片段在图元上所处的相对位置决定这些片段的位置，基于这些位置，它会插值所有片段着色器的输入变量。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>GLSL中包含C语言中大部分的基础数据类型: int、float、double、uint、bool。包含两种容器类型Vector、Matrix。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>GLSL中Vector是一个可以包含2、3、4个分量的容器，分量的类型可以是任意的基础数据类型。</p>
<ul>
<li>vecn: 包含n个float分量的向量</li>
<li>bvecn: 包含n个bool分量的向量</li>
<li>ivecn: 包含n个int分量的向量</li>
<li>uvecn: 包含n个uint分量的向量</li>
<li>dvecn: 包含n个double分量的向量</li>
</ul>
<p>向量的分量可以通过vec.x、vec.y、vec.z、vec.w来获取。</p>
<h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><ul>
<li>gl_VertexID: 输入变量，用于保存顶点的整数索引。</li>
<li>gl_InstanceID: 输入变量，用于保存实例化绘图调用中图元的实例编号。</li>
<li>gl_Position: 输出变量，输出顶点位置的裁剪坐标。该值在裁剪和视口阶段用于执行相应的图元裁剪以及从裁剪坐标到屏幕坐标的顶点位置转换。</li>
<li>gl_PointSize: 输出变量，输出点精灵尺寸。</li>
<li>gl_FrontFacing: 不能直接写入，根据顶点位置和图元类型生成。</li>
<li>gl_DepthRange: 窗口坐标的深度范围。<br>  该变量类型为struct gl_DepthRangeParameters{<br>          highp float near;<br>          highp float far;<br>          highp float diff;<br>  }</li>
</ul>
<h3 id="片段着色器："><a href="#片段着色器：" class="headerlink" title="片段着色器："></a>片段着色器：</h3><ul>
<li>gl_FragCoord: 只读变量，保存片段的窗口相对坐标。</li>
<li>gl_FrontFacing: 只读变量，片段是正面图元的一部分时为true，否则为false。</li>
<li>gl_PointCoord: 只读变量，保存点精灵的纹理坐标，该坐标在点光栅化期间自动生成。</li>
<li>gl_FragDepth：输出变量，用于覆盖片段的固定功能深度值。</li>
<li>gl_FragColor：输出变量，输出该片段的颜色。(该变量在3.0中已删除，需要自行定义)</li>
</ul>
<h2 id="精度限定符"><a href="#精度限定符" class="headerlink" title="精度限定符"></a>精度限定符</h2><p>顶点着色器有默认的精度，是highp，但是片段着色器没有默认的精度。</p>
<ul>
<li>highp</li>
<li>mediump</li>
<li>lowp</li>
</ul>
<h2 id="采样器"><a href="#采样器" class="headerlink" title="采样器"></a>采样器</h2><ul>
<li>texture2D(sampler2D, vec2 coord)：从标准纹理中获取纹理数据。</li>
<li>textureCube(samplerCube, vec3 coord：从立方体贴图纹理中获取纹理数据。<br>3.0中上面两个函数被合成了一个函数</li>
<li>texture(sampler,coord): 内建函数，从纹理贴图中读取，sampler是绑定到纹理单元的采样器，制定纹理为读取来源。coord是从纹理贴图中读取的2d纹理坐标。该函数返回一个代表从纹理贴图中读取颜色的vec4，默认格式为RGBA。</li>
</ul>
]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>GLSL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-入门</title>
    <url>/2022/08/05/cg/OpenGL-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>通俗来讲，OpenGL是一个图形库，提供了一系列操作图形图像的API。因为OpenGL只是一个规范，具体的实现一般是由显卡提供。类似的图形库还有Windows平台的DirectX、iOS平台的Metal以及新一代的Vulkan</p>
<h1 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h1><p>图形渲染管线也叫做渲染流水线，指的是将输入的原始图形数据经过渲染管线处理，输出一帧想要的图像的过程。</p>
<p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，所以图形渲染管线主要是在将输入的3D坐标转换成2D坐标，再将2D坐标转换成实际有颜色的像素。(将输入的3D坐标画在3D坐标系中，然后根据视锥范围截取一个2D平面，将截取的平面转换为平面坐标显示)</p>
<blockquote>
<p>2D坐标精确的表示一个点在2D空间的位置；而像素是这个点的近似值，像素的显示受到屏幕分辨率的限制</p>
</blockquote>
<span id="more"></span>

<p>着色器是运行在GPU上的小程序，这些小程序在图形渲染管线的某个特定部分运行，着色器是一个非常独立的程序，是一种把输入转化为输出的程序，着色器与着色器之间无法通信。蓝色部分代表是可以自定义的着色器。<br><img src="/2022/08/05/cg/OpenGL-%E5%85%A5%E9%97%A8/opengl-pipeline.png" alt="OpenGL渲染管线"></p>
<h2 id="顶点着色器（Vertex-Shader"><a href="#顶点着色器（Vertex-Shader" class="headerlink" title="顶点着色器（Vertex Shader)"></a>顶点着色器（Vertex Shader)</h2><p>图形渲染管线的第一部分是顶点着色器，着色器可以看成是一个纯函数，输入的所有顶点，都会依次执行该函数，在该函数中对输入的顶点进行处理，然后输出新的顶点位置。</p>
<h2 id="图元装配（Primitive-Assembly）"><a href="#图元装配（Primitive-Assembly）" class="headerlink" title="图元装配（Primitive Assembly）"></a>图元装配（Primitive Assembly）</h2><p>所谓图元就是几何形状，OpenGL支持的图元有三种：点、线、三角形。而图元装配就是根据定义的图元类型将顶点着色器输出的顶点渲染成单独的图元，然后会图元进行裁剪、透视分割、视口变换。</p>
<p>裁剪：图元根据视锥体进行裁剪。根据视锥体的六个平面进行裁剪，超出视锥体之外的图元都将被裁剪抛弃（并不会真正裁剪，只是标记，x、y、z的绝对值大于1则表示不在视锥体内，会被裁剪）。裁剪后得到的坐标体系为(x，y，z，w)，其中w用来在透视分割是处理远近效果。</p>
<p><img src="/2022/08/05/cg/OpenGL-%E5%85%A5%E9%97%A8/webgl_perspective_projection.png" alt="透视投影-视锥体"></p>
<p><img src="/2022/08/05/cg/OpenGL-%E5%85%A5%E9%97%A8/webgl_orthogonal_projection.png" alt="正交投影-视锥体"></p>
<p>透视分割：将裁剪后的坐标转换为规范化设备坐标。在该转换中会使用w坐标来进行处理，正交投影中w为1，而透视投影中w会根据远近值来生成，越远值越大。透视分割就是讲x、y、z坐标分别除以w，得到新的x、y、z坐标，由于坐标值都是小于w的，所以最终得到的值都是位于[-1，1]之间，这也就是所谓的规范化设备坐标。而对于透视投影来说，w的值越远越大，所以转换后，越远的坐标，转换后值越小，就会形成近大远小的效果。</p>
<p>视口变换：将设备坐标转换为窗口坐标，每个坐标都关联屏幕上的一个点。</p>
<h2 id="几何着色器（Geometry-Shader）"><a href="#几何着色器（Geometry-Shader）" class="headerlink" title="几何着色器（Geometry Shader）"></a>几何着色器（Geometry Shader）</h2><p>几何着色器把图元装配的输出的一系列顶点的集合作为输入，通过产生新顶点构造出新的图元来生成其它形状。</p>
<h2 id="光栅化（Rasterization）"><a href="#光栅化（Rasterization）" class="headerlink" title="光栅化（Rasterization）"></a>光栅化（Rasterization）</h2><p>光栅化接收几何着色器的输出作为输入，把图元映射为最终屏幕上相应的像素，生成对应的片段，每个片段代表着一个指定的像素位置，这些片段就是片段着色器中使用的片段，在片段着色器运行之前会执行裁切，裁切会丢弃超出视图以外的所有像素，用来提升执行效率。</p>
<blockquote>
<blockquote>
<p>片段包含渲染一个像素所需的所有数据</p>
</blockquote>
</blockquote>
<h2 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h2><p>片段着色器的主要目的是计算每个像素应该输出什么颜色，在片段着色器中可以接收到顶点着色器输出的变量。</p>
<h2 id="测试与混合（Tests-And-Blending）"><a href="#测试与混合（Tests-And-Blending）" class="headerlink" title="测试与混合（Tests And Blending）"></a>测试与混合（Tests And Blending）</h2><p>检测片段对应的深度值，用来判断这个像素是其它物体的前面还是后面，决定是否丢弃，这个阶段也会检查alpha值，并对物体进行混合。</p>
]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-片段着色器</title>
    <url>/2022/08/12/cg/OpenGL-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h1><p>片段着色器的主要目的是计算每个像素应该输出什么颜色，在片段着色器中可以接收到顶点着色器输出的变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 ourColor;</span><br><span class="line">in vec2 TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="comment">// texture sampler</span></span><br><span class="line">uniform sampler2D texture1;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	FragColor = texture(texture1, TexCoord);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>片段着色器可以输出指定的颜色，也可以通过采样器从纹理中进行采样。通过接收顶点着色器输出的纹理坐标（此处接收的是片段差值的坐标），使用采样器sampler2D进行纹理的采样，将采样的颜色作为输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- texture(sampler,coord): 内建函数，从纹理贴图中读取，sampler是绑定到纹理单元的采样器，制定纹理为读取来源。coord是从纹理贴图中读取的<span class="number">2</span>d纹理坐标。该函数返回一个代表从纹理贴图中读取颜色的vec4，默认格式为RGBA。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL-顶点着色器</title>
    <url>/2022/08/10/cg/OpenGL-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h1><p>顶点用于图元装配，OpenGL支持的图元有三种：点、线、三角形，对于点只需要一个顶点，对于三角形需要三个顶点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// left  </span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// right </span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>  <span class="comment">// top   </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h2 id="顶点坐标"><a href="#顶点坐标" class="headerlink" title="顶点坐标"></a>顶点坐标</h2><p>OpenGL不是简单的把所有的3D坐标变换成屏幕上的2D像素，仅当3D坐标在3个轴上-1.0到1.0的范围内时才处理它，所有在这个范围内的坐标叫做标准化</p>
<p><img src="/opengl-ndc.png" alt="NDC"><br>(0,0)是坐标的中心，y轴正方向向上，x轴正方向向右。</p>
<span id="more"></span>

<h2 id="VBO（Vertex-Buffer-Objects"><a href="#VBO（Vertex-Buffer-Objects" class="headerlink" title="VBO（Vertex Buffer Objects)"></a>VBO（Vertex Buffer Objects)</h2><p>将顶点数据作为输入发送给顶点着色器后，它会在GPU上创建一块内存用于存储顶点数据。使用顶点缓冲对象可以用来管理这块内存，用缓冲对象可以一次性的发送大量数据到GPU上，CPU到GPU的传输比较慢，所以尽量一次性发送尽可能多的数据。</p>
<p>使用glGenBuffers函数生成一个缓冲对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br></pre></td></tr></table></figure>

<p>OpenGL有很多缓冲对象类型，顶点缓冲对象的类型是GL_ARRAY_BUFFER，OpenGL允许同时绑定多个缓冲，但是缓存类型不能相同，使用glBindBuffer将创建的缓存对象绑定到GL_ARRAY_BUFFER上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);  </span><br></pre></td></tr></table></figure>

<p>绑定之后，任何针对GL_ARRAY_BUFFER的缓存配置都会作用到绑定的缓冲对象上，使用glBufferData函数可以将顶点数据复制到缓对象管理的内存中。如果缓冲中的数据会频繁变化，需要使用GL_DYNAMIC_DRAW，这样GPU会把数据放在能够高速写入的内存部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GL_STATIC_DRAW: 数据不会或几乎不会改变</span></span><br><span class="line"><span class="comment">// GL_DYNAMIC_DRAW: 数据会被改变很多</span></span><br><span class="line"><span class="comment">// GL_STREAM_DRAW: 数据每次绘制都会改变</span></span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<h2 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h2><p>通过VBO上传了顶点数据，编写了顶点着色器后，需要将顶点数据链接到着色器中的in属性上，通过glVertexAttribPointer将当前绑定到GL_ARRAY_BUFFER类型上的VBO中的数据链接到对应位置的顶点in属性上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0: in属性location</span></span><br><span class="line"><span class="comment">// 3: vec3</span></span><br><span class="line"><span class="comment">// 浮点型</span></span><br><span class="line"><span class="comment">// 将顶点数据标准化</span></span><br><span class="line"><span class="comment">// 步长，两个顶点数据的间隔字节数量</span></span><br><span class="line"><span class="comment">// 数据偏移</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">// 默认是禁用</span></span><br></pre></td></tr></table></figure>

<h2 id="VAO（Vertex-Array-Object）"><a href="#VAO（Vertex-Array-Object）" class="headerlink" title="VAO（Vertex Array Object）"></a>VAO（Vertex Array Object）</h2><p>如果有多个顶点属性需要配置，可以使用顶点数组对象，顶点数组对象可以像顶点缓冲对象那边被绑定，可以将多个顶点属性的配置都绑定到VAO上，这样只需要配置一次，切glVertexAttribPointer换不同的属性配置时只需要绑定不同的VAO即可。</p>
<p>创建VAO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure>

<p>绑定VAO，当绑定VAO后，后面调用glVertexAttribPointer对顶点属性进行的配置都会自动存储到VAO中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindVertexArray(VAO);</span><br></pre></td></tr></table></figure>

<h2 id="EBO（Element-Buffer-Object）"><a href="#EBO（Element-Buffer-Object）" class="headerlink" title="EBO（Element Buffer Object）"></a>EBO（Element Buffer Object）</h2><p>元素缓冲对象也叫索引缓冲对象。EBO是一个缓冲区，和VBO一样，存储OpenGL用来决定要绘制哪些顶点的索引，索引定义了顶点的组合方式，顶点可以重复使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[] = &#123;</span><br><span class="line">    <span class="comment">// 注意索引从0开始! </span></span><br><span class="line">    <span class="comment">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span></span><br><span class="line">    <span class="comment">// 这样可以由下标代表顶点组合成矩形</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建EBO</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure>

<p>EBO的类型是GL_ELEMENT_ARRAY_BUFFER，使用glBindBuffer将创建的缓存对象绑定到GL_ELEMENT_ARRAY_BUFFER上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);  </span><br></pre></td></tr></table></figure>

<p>绑定之后，任何针对GL_ELEMENT_ARRAY_BUFFER的缓存配置都会作用到绑定的缓冲对象上，使用glBufferData函数可以将索引数据复制到缓对象管理的内存中。如果缓冲中的数据会频繁变化，需要使用GL_DYNAMIC_DRAW，这样GPU会把数据放在能够高速写入的内存部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>

<p>使用EBO后，需要用glDrawElements替换glDrawArrays。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>EBO也可以绑定到VAO中，只需绑定一次，后续只绑定VAO即可。</p>
<h1 id="顶点着色器（Vertex-Shader"><a href="#顶点着色器（Vertex-Shader" class="headerlink" title="顶点着色器（Vertex Shader)"></a>顶点着色器（Vertex Shader)</h1><p>图形渲染管线的第一部分是顶点着色器，着色器可以看成是一个纯函数，输入的所有顶点，都会依次执行该函数，在该函数中对输入的顶点进行处理，然后输出新的顶点位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec2 aTexCoord;</span><br><span class="line"></span><br><span class="line">out vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 transform;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	gl_Position = transform * vec4(aPos, <span class="number">1.0</span>);</span><br><span class="line">	TexCoord = vec2(aTexCoord.x, aTexCoord.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顶点坐标-1"><a href="#顶点坐标-1" class="headerlink" title="顶点坐标"></a>顶点坐标</h2><p>顶点着色器中通过定义in变量来接收外部定义的顶点数据，通过glVertexAttribPointer将VBO数据绑定到aPos变量上，这个输入的顶点都会依次执行该着色器函数，通过定义一个uniform的矩阵变量可以实时对顶点坐标进行变换。gl_Position输出最终变换过的顶点坐标。</p>
<h2 id="纹理坐标"><a href="#纹理坐标" class="headerlink" title="纹理坐标"></a>纹理坐标</h2><p>通过顶点着色器传递纹理坐标给片段着色器，可在光栅化时对坐标进行片段插值。</p>
]]></content>
      <categories>
        <category>图形图像</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>c++常量</title>
    <url>/2023/01/24/c++/c++%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p>const关键字可以用来防止对象发生变化。一个const对象必须有以下特征:</p>
<ul>
<li>必须已经初始化</li>
<li>不能被修改</li>
<li>是线程安全的</li>
<li>只能调用const成员函数</li>
</ul>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>指向常量的指针，简称常量指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* pci = &amp;ci;</span><br></pre></td></tr></table></figure>

<h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><p>指针本身是一个常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* cpi = &amp;i;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="常量左值引用"><a href="#常量左值引用" class="headerlink" title="常量左值引用"></a>常量左值引用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cir = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cir2 = ci;</span><br><span class="line"><span class="type">int</span>&amp; cr = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; cir3 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="常量右值引用"><a href="#常量右值引用" class="headerlink" title="常量右值引用"></a>常量右值引用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; cri = i; <span class="comment">// error</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; cri2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="修饰函数"><a href="#修饰函数" class="headerlink" title="修饰函数"></a>修饰函数</h2><p>const修饰的成员函数不能修改当前对象的属性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">canNotModify</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        val = <span class="number">13</span>;  <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="物理常量和逻辑常量"><a href="#物理常量和逻辑常量" class="headerlink" title="物理常量和逻辑常量"></a>物理常量和逻辑常量</h3><ul>
<li>物理常量，也叫比特位常量，当前对象的每一个比特都不能被修改，这也是c++对于const的实现。</li>
<li>逻辑常量，有些时候，一个const函数依旧希望能修改某些比特位，但是其从逻辑上讲依旧是const的。</li>
</ul>
<h3 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h3><p>mutable用来打破物理常量的限制，实现逻辑常量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeCounter</span> &#123;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m; </span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    ++counter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; vec;</span><br><span class="line">    ThreadSafeCounter counter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>([&amp;counter] &#123;</span><br><span class="line">            counter.<span class="built_in">inc</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;counter: &quot;</span> &lt;&lt; counter.<span class="built_in">get</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            counter.<span class="built_in">inc</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>const_cast可以添加或删除const&#x2F;volatile修饰符到一个变量上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* )</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcConst</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> myInt&#123;<span class="number">1988</span>&#125;;</span><br><span class="line">    <span class="built_in">func</span>(&amp;myInt); <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span>* myIntPtr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;myInt);</span><br><span class="line">    <span class="built_in">func</span>(myIntPtr);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* myConstIntPtr = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(myIntPtr);</span><br><span class="line">    <span class="built_in">funcConst</span>(myConstIntPtr);</span><br><span class="line">    <span class="built_in">funcConst</span>(myIntPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ca = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* pca = &amp;ca;</span><br><span class="line">    <span class="type">int</span>* pa2 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(pca);</span><br><span class="line">    *pa2 = <span class="number">12</span>; <span class="comment">// undefined behavior</span></span><br><span class="line">    std::cout &lt;&lt; *pa2 &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt; pa2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; *pca &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt; pca &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; ca &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;ca &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>通过const_cast删除常量修饰从而修改常量的行为是未定义的！！</p>
</blockquote>
</blockquote>
<h1 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h1><h2 id="修饰变量-1"><a href="#修饰变量-1" class="headerlink" title="修饰变量"></a>修饰变量</h2><ul>
<li><p>constexpr是隐式const</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  	a = <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">  	b = <span class="number">3</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>constexpr变量只能接收常量表达式（在编译时可以确定值），与const不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> a = c;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b = c; <span class="comment">// error </span></span><br><span class="line">	<span class="keyword">constexpr</span> <span class="type">int</span> b2 = a; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b3 = a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="修饰函数-1"><a href="#修饰函数-1" class="headerlink" title="修饰函数"></a>修饰函数</h2><ul>
<li>constexpr修饰的函数，可以是编译时，也可能是运行时</li>
<li>constexpr函数中不能使用static、thread_local</li>
<li>所有依赖必须都是编译时，函数才会是编译时(允许常量表达式初始化的变量)</li>
<li>被constexpr接收时，函数必须是编译时</li>
<li>如果是编译时运行，是纯函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// static int c = 10; // error </span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不同的编译器实现不同，可能是编译时也可能是运行时</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">add</span>(v, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//constexpr int a = add(v, 3); // error </span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> e = <span class="built_in">add</span>(b, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类函数"><a href="#类函数" class="headerlink" title="类函数"></a>类函数</h3><ul>
<li>至少有一个constexpr修饰的构造函数</li>
<li>类中可以定义constexpr函数和非constexpr函数</li>
<li>constexpr修饰的类对象只能调用constexpr修饰的成员函数<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDouble</span> &#123;</span><br><span class="line">    <span class="type">double</span> myVal;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MyDouble</span><span class="params">(<span class="type">double</span> v)</span> : myVal(v) &#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">double</span> <span class="title">getVal</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> myVal;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="C-20"><a href="#C-20" class="headerlink" title="C++20"></a>C++20</h3><p>从C++20开始，支持在constexpr函数中使用stl（编译时分配的内存必须在编译时释放）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">maxElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector myVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::<span class="built_in">sort</span>(myVec.<span class="built_in">begin</span>(), myVec.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> myVec.<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxValue = <span class="built_in">maxElement</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> maxValue2 = [] &#123;</span><br><span class="line">        std::vector myVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        std::<span class="built_in">sort</span>(myVec.<span class="built_in">begin</span>(), myVec.<span class="built_in">end</span>()) ;</span><br><span class="line">        <span class="keyword">return</span> myVec.<span class="built_in">back</span>();</span><br><span class="line">    &#125;(); </span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;maxValue: &quot;</span> &lt;&lt; maxValue &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;maxValue2: &quot;</span> &lt;&lt; maxValue2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="consteval-c-20"><a href="#consteval-c-20" class="headerlink" title="consteval (c++20)"></a>consteval (c++20)</h1><p>consteval只能修饰函数，被consteval修饰的函数必须是编译时运行的，调用consteval函数返回的一定是编译时常量。</p>
<ul>
<li>不能应用在析构函数上</li>
<li>其它和constexpr一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> r = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> r2 = <span class="built_in">add2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> r3 = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> r4 = <span class="built_in">add2</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// int r5 = add(x, 2); // error</span></span><br><span class="line">    <span class="type">int</span> r6 = <span class="built_in">add2</span>(x, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sqrRunTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">sqrCompileTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sqrRunOrCompileTime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n * n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> prod1 = <span class="built_in">sqrRunTime</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> prod2 = <span class="built_in">sqrCompileTime</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> prod3 = <span class="built_in">sqrRunOrCompileTime</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> prd4 = <span class="built_in">sqrRunTime</span>(x);</span><br><span class="line">    <span class="type">int</span> prod5 = <span class="built_in">sqrCompileTime</span>(x);</span><br><span class="line">    <span class="type">int</span> prod6 = <span class="built_in">sqrRunOrCompileTime</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="constinit-c-20"><a href="#constinit-c-20" class="headerlink" title="constinit (c++20)"></a>constinit (c++20)</h1><p>constinit与const没有关系，constinit修饰的变量并不是常量，是可以被修改的。constinit保证变量一定是静态初始化的。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态变量分为全局静态变量、局部静态变量、类中静态成员变量。<br>按照初始化的类型分为静态初始化（static initialization）和动态初始化(dynamic initialization)。</p>
<h3 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h3><p>指的是用常量来对静态变量进行初始化，包括zero initialization和const initialization；对于静态初始化的变量，是在程序编译时完成的初始化。</p>
<h3 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h3><p>指的是需要调用函数才能完成的初始化，或者是复杂类型的初始化等，对于这种全局静态变量、类的静态成员变量，是在main()函数执行前，加载时调用相应的代码进行初始化的。而对于局部静态变量，是在函数执行至此初始化语句时才开始执行的初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="type">int</span> <span class="title">sqr</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sqr2</span><span class="params">(<span class="type">int</span> n )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sg1 = <span class="built_in">sqr</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sg2 = <span class="built_in">sqr2</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sg3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> g1 = <span class="built_in">sqr</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> g2 = <span class="built_in">sqr2</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> g3 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static-Initialization-Order-Fiasco"><a href="#Static-Initialization-Order-Fiasco" class="headerlink" title="Static Initialization Order Fiasco"></a>Static Initialization Order Fiasco</h3><p>static变量如果是动态初始化，那么编译单元之间的static变量初始化的顺序是不确定的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticA = <span class="built_in">square</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> staticA;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> staticB = staticA; <span class="comment">// 使用局部静态变量解决</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; staticB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用constinit来解决static初始化顺序的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">quad</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> staticA = <span class="built_in">quad</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">constinit</span> <span class="type">int</span> staticA;</span><br><span class="line"><span class="keyword">constinit</span> <span class="type">int</span> staticB = staticA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; staticB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="std-is-constant-evaluated-c-20"><a href="#std-is-constant-evaluated-c-20" class="headerlink" title="std::is_constant_evaluated (c++20)"></a>std::is_constant_evaluated (c++20)</h1><p>判断函数是编译期执行还是运行时执行</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Android硬件编解码-MediaCodec(C-Api)</title>
    <url>/2022/07/14/av/Android%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81-MediaCodec(C-Api)/</url>
    <content><![CDATA[<p>在 Android 平台上，MediaCodec 提供了一套 C API（通常通过 NDK 使用）来进行视频和音频的编解码。这个 API 允许开发者直接在 C&#x2F;C++ 层面操作编解码器，而不是通过 Java 层的 MediaCodec 类。使用 C API 可以更好地控制性能，特别是在需要处理高效率、低延迟的多媒体应用时。</p>
<h1 id="MediaCodec-编解码流程"><a href="#MediaCodec-编解码流程" class="headerlink" title="MediaCodec 编解码流程"></a>MediaCodec 编解码流程</h1><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><h3 id="创建解码器"><a href="#创建解码器" class="headerlink" title="创建解码器"></a>创建解码器</h3><p>使用 <code>AMediaCodec_createDecoderByType</code> 创建解码器实例。</p>
<h4 id="获取解码器名称"><a href="#获取解码器名称" class="headerlink" title="获取解码器名称"></a>获取解码器名称</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string mime_type;</span><br><span class="line"><span class="keyword">switch</span> (src) &#123;</span><br><span class="line">  <span class="keyword">case</span> CodecType::CODEC_TYPE_H264:</span><br><span class="line">    mime_type = <span class="string">&quot;video/avc&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CodecType::CODEC_TYPE_H265:</span><br><span class="line">    mime_type = <span class="string">&quot;video/hevc&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mime_type;</span><br></pre></td></tr></table></figure>

<h4 id="设置解码格式参数"><a href="#设置解码格式参数" class="headerlink" title="设置解码格式参数"></a>设置解码格式参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AMediaFormat* <span class="title">MediaCodecDecoderImpl::CreateMediaFormat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VideoInfo&amp; video_info, <span class="type">const</span> ExtraData&amp; extra_data)</span> </span>&#123;</span><br><span class="line">  std::string mime_type = <span class="built_in">CodecTypeConvert</span>&lt;CodecType, std::string&gt;(video_info.codec_type);</span><br><span class="line"></span><br><span class="line">  AMediaFormat* format = <span class="built_in">AMediaFormat_new</span>();</span><br><span class="line">  <span class="comment">// 设置宽高，解码名称</span></span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_WIDTH, video_info.width);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_HEIGHT, video_info.height);</span><br><span class="line">  <span class="built_in">AMediaFormat_setString</span>(format, AMEDIAFORMAT_KEY_MIME, mime_type.<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="comment">// 设置输出的颜色格式</span></span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_COLOR_FORMAT, pix_fmt);</span><br><span class="line">  <span class="comment">// 通过csd-0 csd-1 csd-2来设置vps sps pps数据</span></span><br><span class="line">  <span class="keyword">switch</span> (video_info.codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CodecType::CODEC_TYPE_H264: &#123;</span><br><span class="line">      <span class="keyword">auto</span>* avc_ps_ = <span class="keyword">new</span> avc::<span class="built_in">ParamSets</span>();</span><br><span class="line">      himawari::avc::<span class="built_in">ParseExtraDataToParamSet</span>(extra_data, *avc_ps_);</span><br><span class="line">      <span class="keyword">if</span> (avc_ps_-&gt;sps_list.<span class="built_in">empty</span>() || avc_ps_-&gt;pps_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">AMediaFormat_setBuffer</span>(format, <span class="string">&quot;csd-0&quot;</span>, avc_ps_-&gt;sps_list[<span class="number">0</span>].data,</span><br><span class="line">                             avc_ps_-&gt;sps_list[<span class="number">0</span>].data_size);</span><br><span class="line">      <span class="built_in">AMediaFormat_setBuffer</span>(format, <span class="string">&quot;csd-1&quot;</span>, avc_ps_-&gt;pps_list[<span class="number">0</span>].data,</span><br><span class="line">                             avc_ps_-&gt;pps_list[<span class="number">0</span>].data_size);</span><br><span class="line">      <span class="keyword">delete</span> avc_ps_;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CodecType::CODEC_TYPE_H265: &#123;</span><br><span class="line">      <span class="keyword">auto</span>* hevc_ps = <span class="keyword">new</span> hevc::<span class="built_in">ParamSets</span>();</span><br><span class="line">      himawari::hevc::<span class="built_in">ParseExtraDataToParamSet</span>(extra_data, *hevc_ps);</span><br><span class="line">      <span class="keyword">if</span> (hevc_ps-&gt;vps_list.<span class="built_in">empty</span>() || hevc_ps-&gt;sps_list.<span class="built_in">empty</span>() ||</span><br><span class="line">          hevc_ps-&gt;pps_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">AMediaFormat_setBuffer</span>(format, <span class="string">&quot;csd-0&quot;</span>, hevc_ps-&gt;vps_list[<span class="number">0</span>].data,</span><br><span class="line">                             hevc_ps-&gt;vps_list[<span class="number">0</span>].data_size);</span><br><span class="line">      <span class="built_in">AMediaFormat_setBuffer</span>(format, <span class="string">&quot;csd-1&quot;</span>, hevc_ps-&gt;sps_list[<span class="number">0</span>].data,</span><br><span class="line">                             hevc_ps-&gt;sps_list[<span class="number">0</span>].data_size);</span><br><span class="line">      <span class="built_in">AMediaFormat_setBuffer</span>(format, <span class="string">&quot;csd-2&quot;</span>, hevc_ps-&gt;pps_list[<span class="number">0</span>].data,</span><br><span class="line">                             hevc_ps-&gt;pps_list[<span class="number">0</span>].data_size);</span><br><span class="line">      <span class="keyword">delete</span> hevc_ps;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> format;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="创建解码器实例"><a href="#创建解码器实例" class="headerlink" title="创建解码器实例"></a>创建解码器实例</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取解码器名称</span></span><br><span class="line">std::string mime_type = <span class="built_in">CodecTypeConvert</span>&lt;CodecType, std::string&gt;(video_info_.codec_type);</span><br><span class="line"><span class="comment">// 创建解码器实例  </span></span><br><span class="line">codec_ = <span class="built_in">AMediaCodec_createDecoderByType</span>(mime_type.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">// 设置解码格式参数</span></span><br><span class="line">format_ = <span class="built_in">CreateMediaFormat</span>(video_info_, extra_data);</span><br><span class="line"><span class="comment">// 配置解码器，并启动</span></span><br><span class="line"><span class="built_in">AMediaCodec_configure</span>(codec_, format_, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">AMediaCodec_start</span>(codec_);</span><br></pre></td></tr></table></figure>



<h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><p><code>AMediaCodec_dequeueInputBuffer</code>、<code>AMediaCodec_queueInputBuffer</code> 和 <code>AMediaCodec_dequeueOutputBuffer</code> 等函数处理数据。</p>
<p>MediaCodec支持Annex-B格式的码流，不支持avc格式的码流，需要提前将packet的格式进行转换，sps pps也需要从avc的ExtraData中提取出来</p>
<h4 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> input_index;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 获取空闲的输入Buffer Index</span></span><br><span class="line">  input_index = <span class="built_in">AMediaCodec_dequeueInputBuffer</span>(codec_, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (input_index &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (packet-&gt;byte_data) &#123;</span><br><span class="line">  <span class="comment">// 获取空闲的输入Buffer</span></span><br><span class="line">  <span class="type">uint8_t</span>* buffer = <span class="built_in">AMediaCodec_getInputBuffer</span>(codec_, input_index, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">    <span class="keyword">return</span> HMError::FAILED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将输入数据拷贝到输入Buffer中</span></span><br><span class="line">  <span class="built_in">memcpy</span>(buffer, packet-&gt;byte_data, packet-&gt;data_size);</span><br><span class="line">  <span class="comment">// 将准备好的输入Buffer Index通知给解码器处理</span></span><br><span class="line">  <span class="built_in">AMediaCodec_queueInputBuffer</span>(codec_, input_index, <span class="number">0</span>, packet-&gt;data_size,</span><br><span class="line">                               packet-&gt;pts, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  send_eos_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 输入数据结束了，需要通知解码器end_of_stream，让解码器把剩余的帧都吐出来，送入空的一帧</span></span><br><span class="line">  <span class="built_in">AMediaCodec_queueInputBuffer</span>(codec_, input_index, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                               AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取输出数据"><a href="#获取输出数据" class="headerlink" title="获取输出数据"></a>获取输出数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AMediaCodecBufferInfo info;</span><br><span class="line"><span class="comment">// 获取解码完毕的输出Buffer</span></span><br><span class="line"><span class="type">ssize_t</span> status = <span class="built_in">AMediaCodec_dequeueOutputBuffer</span>(codec_, &amp;info, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">    <span class="comment">// 最后一帧数据是空的，收到最后一帧表明所有帧都已经解完了</span></span><br><span class="line">    receive_eos_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> HMError::END_OF_STREAM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* buffer = <span class="built_in">AMediaCodec_getOutputBuffer</span>(codec_, status, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">size_t</span> size = info.size;</span><br><span class="line">  <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span> &amp;&amp; size != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取解码后的数据信息，这里只能获取到pts，dts无法获取，所以对于B帧还是不太友好</span></span><br><span class="line">    frame-&gt;timestamp = info.presentationTimeUs;</span><br><span class="line">    <span class="built_in">AMediaFormat_getInt64</span>(format_, AMEDIAFORMAT_KEY_DURATION,</span><br><span class="line">                          &amp;frame-&gt;timespan);</span><br><span class="line">    <span class="built_in">AMediaFormat_getInt32</span>(format_, AMEDIAFORMAT_KEY_WIDTH,</span><br><span class="line">                          &amp;frame-&gt;video_frame_info.width);</span><br><span class="line">    <span class="built_in">AMediaFormat_getInt32</span>(format_, AMEDIAFORMAT_KEY_HEIGHT,</span><br><span class="line">                          &amp;frame-&gt;video_frame_info.height);</span><br><span class="line">    <span class="type">int</span> pix_fmt;</span><br><span class="line">    <span class="built_in">AMediaFormat_getInt32</span>(format_, AMEDIAFORMAT_KEY_COLOR_FORMAT, &amp;pix_fmt);</span><br><span class="line">    frame-&gt;video_frame_info.pix_fmt =</span><br><span class="line">        <span class="built_in">PixFormatConvert</span>&lt;<span class="type">int</span>, PixFormat&gt;(pix_fmt);</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">// 处理解码后的帧数据</span></span><br><span class="line">    err = HMError::OK;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = HMError::WAIT_AGAIN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AMediaCodec_releaseOutputBuffer</span>(codec_, status, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">  <span class="comment">// format发生了改变，需要重新获取新的format</span></span><br><span class="line">  <span class="built_in">AMediaFormat_delete</span>(format_);</span><br><span class="line">  format_ = <span class="built_in">AMediaCodec_getOutputFormat</span>(codec_);</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  err = HMError::FAILED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

<h4 id="处理解码后的帧数据"><a href="#处理解码后的帧数据" class="headerlink" title="处理解码后的帧数据"></a>处理解码后的帧数据</h4><p>Android平台给的解码数据都是packed格式的，不是planar格式，处理时需要注意</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* src_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="keyword">switch</span> (dst-&gt;video_frame_info.pix_fmt) &#123;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_NV12:</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_NV12, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = dst-&gt;video_frame_info.width;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line">    src += len;</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">1</span>] = dst-&gt;video_frame_info.width;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">1</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">1</span>], src_data, len);</span><br><span class="line">    src += len;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_I420:</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_I420, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = dst-&gt;video_frame_info.width;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line">    src += len;</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">1</span>] = dst-&gt;video_frame_info.width / <span class="number">2</span>;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">1</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">1</span>], src_data, len);</span><br><span class="line">    src += len;</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">2</span>] = dst-&gt;video_frame_info.width / <span class="number">2</span>;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">2</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">2</span>], src_data, len);</span><br><span class="line">    src += len;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_ARGB:</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_ARGB, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = dst-&gt;video_frame_info.width;</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = src;</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br></pre></td></tr></table></figure>


<h3 id="停止和释放解码器"><a href="#停止和释放解码器" class="headerlink" title="停止和释放解码器"></a>停止和释放解码器</h3><p>调用 <code>AMediaCodec_stop</code> 和 <code>AMediaCodec_delete</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (format_) &#123;</span><br><span class="line">  <span class="built_in">AMediaFormat_delete</span>(format_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (codec_) &#123;</span><br><span class="line">  <span class="built_in">AMediaCodec_stop</span>(codec_);</span><br><span class="line">  <span class="built_in">AMediaCodec_delete</span>(codec_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="创建编码器"><a href="#创建编码器" class="headerlink" title="创建编码器"></a>创建编码器</h3><h4 id="获取编码器名称"><a href="#获取编码器名称" class="headerlink" title="获取编码器名称"></a>获取编码器名称</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string mime_type;</span><br><span class="line"><span class="keyword">switch</span> (src) &#123;</span><br><span class="line">  <span class="keyword">case</span> CodecType::CODEC_TYPE_H264:</span><br><span class="line">    mime_type = <span class="string">&quot;video/avc&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CodecType::CODEC_TYPE_H265:</span><br><span class="line">    mime_type = <span class="string">&quot;video/hevc&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mime_type;</span><br></pre></td></tr></table></figure>

<h4 id="设置解码格式参数-1"><a href="#设置解码格式参数-1" class="headerlink" title="设置解码格式参数"></a>设置解码格式参数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">AMediaFormat* <span class="title">MediaCodecDecoderImpl::CreateMediaFormat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VideoInfo&amp; video_info, <span class="type">const</span> ExtraData&amp; extra_data)</span> </span>&#123;</span><br><span class="line">  std::string mime_type = <span class="built_in">CodecTypeConvert</span>&lt;CodecType, std::string&gt;(video_info.codec_type);</span><br><span class="line"></span><br><span class="line">  AMediaFormat* format = <span class="built_in">AMediaFormat_new</span>();</span><br><span class="line">  <span class="comment">// 设置宽高和颜色格式</span></span><br><span class="line">  <span class="built_in">AMediaFormat_setString</span>(format, AMEDIAFORMAT_KEY_MIME, mime_type.<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_WIDTH, video_info.width);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_HEIGHT, video_info.height);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_COLOR_FORMAT, pix_fmt);</span><br><span class="line">  <span class="comment">// 设置帧率 码率 GOP</span></span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_BIT_RATE, video_info.bit_rate);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_FRAME_RATE, video_info.fps);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, AMEDIAFORMAT_KEY_I_FRAME_INTERVAL, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, <span class="string">&quot;level&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">AMediaFormat_setInt32</span>(format, <span class="string">&quot;profile&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建编码器实例"><a href="#创建编码器实例" class="headerlink" title="创建编码器实例"></a>创建编码器实例</h4><p>使用 <code>AMediaCodec_createCodecByName</code> 或 <code>AMediaCodec_createEncoderByType</code> 创建一个编码器实例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::string mime_type = <span class="built_in">CodecTypeConvert</span>&lt;CodecType, std::string&gt;(video_info_.codec_type);</span><br><span class="line"><span class="comment">// 创建编码器实例  </span></span><br><span class="line">codec_ = <span class="built_in">AMediaCodec_createEncoderByType</span>(mime_type.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码格式参数  </span></span><br><span class="line">format_ = <span class="built_in">CreateMediaFormat</span>(video_info_);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置编码器配置</span></span><br><span class="line"><span class="built_in">AMediaCodec_configure</span>(codec_, format_, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, AMEDIACODEC_CONFIGURE_FLAG_ENCODE);</span><br><span class="line"><span class="built_in">AMediaCodec_start</span>(codec_);</span><br></pre></td></tr></table></figure>

<h3 id="处理数据-1"><a href="#处理数据-1" class="headerlink" title="处理数据"></a>处理数据</h3><p>MediaCodec支持Annex-B格式的码流，不支持avc格式的码流，输出的packet格式需要注意</p>
<h4 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据"></a>输入数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> input_index;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 获取空闲的输入Buffer Index</span></span><br><span class="line">  input_index = <span class="built_in">AMediaCodec_dequeueInputBuffer</span>(codec_, <span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (input_index &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (frame-&gt;byte_data.data) &#123;</span><br><span class="line">  <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取空闲的输入Buffer</span></span><br><span class="line">  <span class="type">uint8_t</span>* buffer = <span class="built_in">AMediaCodec_getInputBuffer</span>(codec_, input_index, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">    <span class="keyword">return</span> HMError::FAILED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将输入数据拷贝到输入Buffer中</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 将准备好的输入Buffer Index通知给编码器处理</span></span><br><span class="line">  <span class="built_in">AMediaCodec_queueInputBuffer</span>(codec_, input_index, <span class="number">0</span>, size, frame-&gt;timestamp,</span><br><span class="line">                               <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  send_eos_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// 输入数据结束了，需要通知编码器end_of_stream，让编码器把剩余的帧都吐出来，送入空的一帧</span></span><br><span class="line">  <span class="built_in">AMediaCodec_queueInputBuffer</span>(codec_, input_index, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                               AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="将输入数据拷贝到输入Buffer中"><a href="#将输入数据拷贝到输入Buffer中" class="headerlink" title="将输入数据拷贝到输入Buffer中"></a>将输入数据拷贝到输入Buffer中</h4><p>Android平台接收的编码数据都是packed格式的，不是planar格式，处理时需要注意</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* dst_data = dst;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="keyword">switch</span> (src-&gt;video_frame_info.pix_fmt) &#123;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_NV12:</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line">    dst_data += len;</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">1</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">1</span>], len);</span><br><span class="line">    dst_data += len;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_I420:</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line">    dst_data += len;</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">1</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">1</span>], len);</span><br><span class="line">    dst_data += len;</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">2</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">2</span>], len);</span><br><span class="line">    dst_data += len;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_ARGB:</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dst;</span><br></pre></td></tr></table></figure>


<h4 id="获取输出数据-1"><a href="#获取输出数据-1" class="headerlink" title="获取输出数据"></a>获取输出数据</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::error_code err;</span><br><span class="line">AMediaCodecBufferInfo info;</span><br><span class="line"><span class="comment">// 获取编码完毕的输出Buffer</span></span><br><span class="line"><span class="type">ssize_t</span> status = <span class="built_in">AMediaCodec_dequeueOutputBuffer</span>(codec_, &amp;info, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (info.flags &amp; AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">    <span class="comment">// 最后一帧数据是空的，收到最后一帧表明所有帧都已经编码完成了  </span></span><br><span class="line">    receive_eos_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> HMError::END_OF_STREAM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* buffer = <span class="built_in">AMediaCodec_getOutputBuffer</span>(codec_, status, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="type">size_t</span> size = info.size;</span><br><span class="line">  <span class="keyword">if</span> (buffer != <span class="literal">nullptr</span> &amp;&amp; size != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">size_t</span> len = size * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (!packet-&gt;byte_data) &#123;</span><br><span class="line">      packet-&gt;byte_data = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(<span class="built_in">malloc</span>(len));</span><br><span class="line">      <span class="built_in">memset</span>(packet-&gt;byte_data, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取编码后的数据信息，这里只能获取到pts，dts无法获取，所以对于B帧还是不太友好</span></span><br><span class="line">    <span class="built_in">memcpy</span>(packet-&gt;byte_data, buffer, len);</span><br><span class="line">    packet-&gt;data_size = size;</span><br><span class="line">    packet-&gt;pts = info.presentationTimeUs;</span><br><span class="line">    packet-&gt;dts = packet-&gt;pts;</span><br><span class="line">    <span class="comment">//      dst-&gt;duration = src-&gt;duration;</span></span><br><span class="line"></span><br><span class="line">    err = HMError::OK;</span><br><span class="line">    <span class="keyword">if</span> (!extra_data_.extradata) &#123;</span><br><span class="line">      <span class="comment">// 从第一帧中解析vps sps pps信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    err = HMError::WAIT_AGAIN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">AMediaCodec_releaseOutputBuffer</span>(codec_, status, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED) &#123;</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == AMEDIACODEC_INFO_TRY_AGAIN_LATER) &#123;</span><br><span class="line">  err = HMError::WAIT_AGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  err = HMError::FAILED;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>


<h3 id="停止和释放编码器"><a href="#停止和释放编码器" class="headerlink" title="停止和释放编码器"></a>停止和释放编码器</h3><p>调用 <code>AMediaCodec_stop</code> 和 <code>AMediaCodec_delete</code> 来停止和释放编码器资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (format_) &#123;</span><br><span class="line">  <span class="built_in">AMediaFormat_delete</span>(format_);</span><br><span class="line">  format_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (codec_) &#123;</span><br><span class="line">  <span class="built_in">AMediaCodec_stop</span>(codec_);</span><br><span class="line">  <span class="built_in">AMediaCodec_delete</span>(codec_);</span><br><span class="line">  codec_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android硬件编解码-MediaCodec(Java-Api)</title>
    <url>/2020/04/22/av/Android%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81-MediaCodec(Java-Api)/</url>
    <content><![CDATA[<h1 id="MediaCodec介绍"><a href="#MediaCodec介绍" class="headerlink" title="MediaCodec介绍"></a>MediaCodec介绍</h1><p>MediaCodec是Android平台上用来访问编码器和解码器的组件。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/mediacodec-processes.png" alt="mediacodec-processes"></p>
<span id="more"></span>

<p>MediaCodec中维护了两个BufferQueue，一个用来存放输入数据，一个用来存放输出数据。对于编码来说，InputBufferQueue用来接收视频原始YUV数据，经过Codec编码处理后，将编码后的数据放入到OutputBufferQueue中输出。而对于解码来说，InputBufferQueue用来接收视频编码数据，经过Codec解码处理后，将解码后的视频原始YUV数据放入到OutputBufferQueue中输出。</p>
<p>BufferQueue的数量是有限的，每次通过dequeueInputBuffer从InputBufferQueue中获取一个空的buffer索引，将输入数据填充到该buffer，通过queueInputBuffer通知Codec该索引位置的buffer已经填充了数据，可以开始处理了。然后通过dequeueOutputBuffer从OutputBufferQueue中获取处理完毕的buffer索引，获取到该buffer中的数据进行渲染或封装，使用完后，通过releaseOutputBuffer通知Codec释放该buffer中的数据（也可以让Codec进行数据的渲染）。</p>
<p>MediaCodec的数据分为两种，一种是原始音视频数据，一种是压缩数据。上面讲到这两种数据都是使用bytebuffer来处理的，输入层获取到空的buffer后需要将数据copy到该buffer中，而输出层获取到buffer后也需要将数据copy出来进行消费，大量的数据copy是很影响性能的。</p>
<p>针对原始音视频数据，MediaCodec提供了更加高效的方式来避免了数据的copy，那就是Surface。对于解码器来说，可以通过在configure的时候，设置OutputSurface来接收输出的Buffer，这样就不需要从OutputBufferQueue中copy数据了。而对于编码器来说，可以通过createInputSurface方法创建一个用来输入的Surface，这样就不需要往InputBufferQueue里copy数据了。</p>
<p><img src="/mediacodec-surface-processes.png" alt="mediacodec-surface-processes"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h3><p>音频原始数据类型是一个PCM音频数据帧，视频原始数据类型由color_format决定，常用的有以下两种：</p>
<ul>
<li><strong>Surface Format</strong> ：这种类型的format数据，表明使用的GraphicBuffer，这是一个内存共享的缓冲区。（CodecCapabilities#COLOR_FormatSurface ）。</li>
<li><strong>YUV Format</strong> ：YUV颜色格式，支持多种YUV格式（CodecCapabilities#COLOR_FormatYUV420Flexible ）。</li>
</ul>
<blockquote>
<p>在configure的时候，对于编码器来说可以指定编码器输出的数据的format，对于解码器来说可以指定解码器输入的format。</p>
<p>对于编码器，如果输入的时候使用的是Surface，则format需要设置为COLOR_FormatSurface。而对于解码器来说输入的format一般从媒体文件中读取。</p>
</blockquote>
<h3 id="压缩数据"><a href="#压缩数据" class="headerlink" title="压缩数据"></a>压缩数据</h3><p>对于视频来说，buffer中是一帧的压缩数据，对于音频来说，buffer中是一个单元的压缩数据，buffer中包含的都是完整的一帧或一个单元的数据。</p>
<h2 id="组件状态"><a href="#组件状态" class="headerlink" title="组件状态"></a>组件状态</h2><p><img src="/mediacodec-status.png"></p>
<p><strong>Stopped</strong>：创建了一个MediaCodec对象后，默认为Uninitialized状态，调用configure方法后，状态变为Configured，通过reset可以重新配置。</p>
<p><strong>Executing</strong>：调用start方法后，状态就变为了Flushed，第一次调用dequeueInputBuffer时，状态变为Running，当通过queueInputBuffer写入了一个EOS标记后，则状态变为End of Stream，可以通过flush方法重新回到Flushed状态。</p>
<p><strong>Released</strong>：调用release进入到Released状态。</p>
<h1 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h1><h2 id="创建编解码器"><a href="#创建编解码器" class="headerlink" title="创建编解码器"></a>创建编解码器</h2><h3 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h3><p>通过制定的mimeType创建一个编码器，比如 “video&#x2F;avc” ，如果当前设备不支持该type则会抛IllegalArgumentException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mVideoEncoder = MediaCodec.createEncoderByType(<span class="string">&quot;mimeType&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过<strong>MediaCodecList</strong>查询当前设备是否支持该mimeType的编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">numCodecs</span> <span class="operator">=</span> MediaCodecList.getCodecCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCodecs; i++) &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">MediaCodecInfo</span> <span class="variable">codecInfo</span> <span class="operator">=</span> MediaCodecList.getCodecInfoAt(i);</span><br><span class="line">     <span class="keyword">if</span> (!codecInfo.isEncoder()) &#123;   </span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// select first codec that match a specific MIME type and color format</span></span><br><span class="line">     <span class="keyword">final</span> String[] types = codecInfo.getSupportedTypes();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; types.length; j++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (types[j].equalsIgnoreCase(mimeType)) &#123;</span><br><span class="line">          ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h3><p>通过mimeType就可以快速的创建一个解码器，关于媒体文件的mimeType获取可以使用<strong>MediaExtractor.getTrackFormat</strong>，如果当前设备不支持该type则会抛IllegalArgumentException异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mVideoDecoder = MediaCodec.createDecoderByType(<span class="string">&quot;mimeType&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过<strong>MediaCodecList</strong>查询当前设备是否支持该mimeType的解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">numCodecs</span> <span class="operator">=</span> MediaCodecList.getCodecCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCodecs; i++) &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="type">MediaCodecInfo</span> <span class="variable">codecInfo</span> <span class="operator">=</span> MediaCodecList.getCodecInfoAt(i);</span><br><span class="line">     <span class="keyword">if</span> (codecInfo.isEncoder()) &#123;   </span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// select first codec that match a specific MIME type and color format</span></span><br><span class="line">     <span class="keyword">final</span> String[] types = codecInfo.getSupportedTypes();</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; types.length; j++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (types[j].equalsIgnoreCase(mimeType)) &#123;</span><br><span class="line">          ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="编码器-1"><a href="#编码器-1" class="headerlink" title="编码器"></a>编码器</h3><p>在创建完编码器之后，需要对编码器进行confiigure。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> MediaFormat format,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Surface surface, <span class="meta">@Nullable</span> MediaCrypto crypto,</span></span><br><span class="line"><span class="params">            <span class="meta">@ConfigureFlag</span> <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于编码器来说</p>
<p>第一个参数MediaFormat是指定编码器输出的数据格式。这个格式需要我们自己去计算制定，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置编码器输出格式</span></span><br><span class="line">mVideoEncoderFormat = MediaFormat.createVideoFormat(MIME_TYPE, mNewWidth, mNewHeight);</span><br><span class="line"><span class="comment">// 设置color_format，如果使用的是InputSurface，则设置为FormatSurface</span></span><br><span class="line">mVideoEncoderFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line"><span class="comment">// 码率</span></span><br><span class="line">mVideoEncoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, mNewBitRate);</span><br><span class="line"><span class="comment">// 帧率</span></span><br><span class="line">mVideoEncoderFormat.setInteger(MediaFormat.KEY_FRAME_RATE, OUTPUT_FRAME_RATE);</span><br><span class="line"><span class="comment">// gop</span></span><br><span class="line">mVideoEncoderFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, OUTPUT_IFRAME_INTERVAL);</span><br></pre></td></tr></table></figure>

<p>第二个参数是OutputSurface，对于编码器来说忽略。</p>
<p>第三个参数是加密相关，可忽略。</p>
<p>第四个参数是编码标记，编码器需要加上 MediaCodec.CONFIGURE_FLAG_ENCODE 标记。</p>
<h3 id="解码器-1"><a href="#解码器-1" class="headerlink" title="解码器"></a>解码器</h3><p>在创建完解码器之后，需要对解码器进行configure。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> MediaFormat format,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> Surface surface, <span class="meta">@Nullable</span> MediaCrypto crypto,</span></span><br><span class="line"><span class="params">            <span class="meta">@ConfigureFlag</span> <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于解码器来说</p>
<p>第一个参数MediaFormat是指定解码器输入的数据格式。一般来说是通过<strong>MediaExtractor.getTrackFormat</strong>从媒体文件中获取，但是其中有几点需要注意。</p>
<ol>
<li>最好先将KEY_LEVEL的值设置为null（<code>MediaFormat.setString(KEY_LEVEL, null)</code>），因为这个值经常不准。</li>
<li>在5.0的设备上，MediaCodecList.findDecoder<code>/</code>EncoderForFormat<code>不得包含frame rate。使用</code>（<code>MediaFormat.setString(MediaFormat.KEY_FRAME_RATE, null)</code>）清除格式中的任何现有帧率设置。</li>
</ol>
<p>第二个参数是OutputSurface，解码完成后，通过releaseOutputBuffer可将解码后数据直接输出到该Surface中。</p>
<p>第三个参数是加密相关，可忽略。</p>
<p>第四个参数是解码器也可忽略。</p>
<h2 id="Codec-specific-Data"><a href="#Codec-specific-Data" class="headerlink" title="Codec-specific Data"></a>Codec-specific Data</h2><p>对于某些格式，特别是AAC音频和H.264和H.265视频格式要求实际数据前需要包含设置数据或编解码器特定数据的多个缓冲区。 处理这种压缩格式时，必须在<code>start()</code>之后和任何帧数据之前将此数据提交给编解码器。 此类数据必须在输入时<code>queueInputBuffer</code>使用标<strong>BUFFER_FLAG_CODEC_CONFIG</strong>进行标记。</p>
<p>关于CSD，其实在封装篇讲过，在muxer写入第一帧之前，需要写入CSD数据。</p>
<p><img src="/mediacodec-csd.png" alt="mediacodec-csd"></p>
<p>对于解码器来说，<strong>MediaExtractor.getTrackFormat</strong>可以直接获取到媒体文件的CSD信息。</p>
<p>对于编码器来说，在MediaCodec.INFO_OUTPUT_FORMAT_CHANGED回调时，使用mVideoEncoder.getOutputFormat() 可以获取到附带CSD信息的Format。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>根据API历史，MediaCodec提供了三套处理API。</p>
<table>
<thead>
<tr>
<th align="left">Processing Mode</th>
<th align="left">API version &lt;&#x3D; 20</th>
<th align="left">API version &gt;&#x3D; 21</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Synchronous API using buffer arrays</td>
<td align="left">Supported</td>
<td align="left">已过时</td>
</tr>
<tr>
<td align="left">Synchronous API using buffers</td>
<td align="left">Not Available</td>
<td align="left">Supported</td>
</tr>
<tr>
<td align="left">Asynchronous API using buffers</td>
<td align="left">Not Available</td>
<td align="left">Supported</td>
</tr>
</tbody></table>
<h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">MediaCodec</span> <span class="variable">codec</span> <span class="operator">=</span> MediaCodec.createByCodecName(name);</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">codec.configure(format, …);</span><br><span class="line"><span class="type">MediaFormat</span> <span class="variable">outputFormat</span> <span class="operator">=</span> codec.getOutputFormat(); </span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">codec.start();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// 从InputBufferQueue中获取空闲索引</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">inputBufferId</span> <span class="operator">=</span> codec.dequeueInputBuffer(timeoutUs);</span><br><span class="line">  <span class="keyword">if</span> (inputBufferId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取空闲索引对应的buffer</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">inputBuffer</span> <span class="operator">=</span> codec.getInputBuffer(…);</span><br><span class="line">    <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> (inputDown) &#123;</span><br><span class="line">      	<span class="comment">// 输入结束的时候，向InputBufferQueue中写入一个EOS的标记，通知编码器。</span></span><br><span class="line">    		codec.queueInputBuffer(inputBufferId, <span class="number">0</span>, <span class="number">0</span>, 		<span class="number">0L</span>,MediaCodec.BUFFER_FLAG_END_OF_STREAM);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通知Codec数据写入</span></span><br><span class="line">        codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从OutputBufferQueue中获取处理完成的索引</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">outputBufferId</span> <span class="operator">=</span> codec.dequeueOutputBuffer(…);</span><br><span class="line">  <span class="keyword">if</span> (outputBufferId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到处理完成的数据和格式</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">outputBuffer</span> <span class="operator">=</span> codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    <span class="type">MediaFormat</span> <span class="variable">bufferFormat</span> <span class="operator">=</span> codec.getOutputFormat(outputBufferId); </span><br><span class="line">    <span class="comment">// 封装或渲染</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 释放该buffer</span></span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (outputBufferId == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">    <span class="comment">// 数据格式发生变化</span></span><br><span class="line">    outputFormat = codec.getOutputFormat(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure>



<h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">MediaCodec</span> <span class="variable">codec</span> <span class="operator">=</span> MediaCodec.createByCodecName(name);</span><br><span class="line">MediaFormat mOutputFormat; </span><br><span class="line"><span class="comment">// 异步回调</span></span><br><span class="line">codec.setCallback(<span class="keyword">new</span> <span class="title class_">MediaCodec</span>.Callback() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onInputBufferAvailable</span><span class="params">(MediaCodec mc, <span class="type">int</span> inputBufferId)</span> &#123;</span><br><span class="line">    <span class="comment">// InputBufferQueue有空闲buffer回调</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">inputBuffer</span> <span class="operator">=</span> codec.getInputBuffer(inputBufferId);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 通知Codec</span></span><br><span class="line">    codec.queueInputBuffer(inputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onOutputBufferAvailable</span><span class="params">(MediaCodec mc, <span class="type">int</span> outputBufferId, …)</span> &#123;</span><br><span class="line">    <span class="comment">// OutputBufferQueue有处理完成的buffer回调</span></span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">outputBuffer</span> <span class="operator">=</span> codec.getOutputBuffer(outputBufferId);</span><br><span class="line">    <span class="type">MediaFormat</span> <span class="variable">bufferFormat</span> <span class="operator">=</span> codec.getOutputFormat(outputBufferId); </span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 释放buffer</span></span><br><span class="line">    codec.releaseOutputBuffer(outputBufferId, …);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onOutputFormatChanged</span><span class="params">(MediaCodec mc, MediaFormat format)</span> &#123;</span><br><span class="line">    <span class="comment">// Codec数据格式发生变化</span></span><br><span class="line">    mOutputFormat = format;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(…)</span> &#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">codec.configure(format, …);</span><br><span class="line">mOutputFormat = codec.getOutputFormat(); </span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">codec.start();</span><br><span class="line"><span class="comment">// 等待处理</span></span><br><span class="line">…</span><br><span class="line">codec.stop();</span><br><span class="line">codec.release();</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>在输入结束后，需要写入EOS标记，此时buffer可为空，需要注意的是一旦写入EOS标记后，就不可以再向InputBufferQueue中写入数据了。</p>
</li>
<li><p>一旦设置了OutputSurface，则不可以访问OutputBufferQueue，对应API会返回null。</p>
</li>
<li><p>一旦设置了InputSurface，则不可以访问InputBufferQueue，对应API会抛异常或返回null。</p>
</li>
<li><p>在<code>M</code>版本之前，软件解码器在渲染到Surface上时可能未应用旋转。</p>
</li>
<li><p>Codec在处理的第一帧的数据一定要是关键帧。</p>
</li>
</ol>
</blockquote>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="MediaCodec-创建"><a href="#MediaCodec-创建" class="headerlink" title="MediaCodec 创建"></a>MediaCodec 创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line">sp&lt;MediaCodec&gt; <span class="title function_">MediaCodec::CreateByType</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="type">const</span> AString &amp;mime, <span class="type">bool</span> encoder, <span class="type">status_t</span> *err, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">        <span class="type">uid_t</span> uid)</span> &#123;</span><br><span class="line">    Vector&lt;AString&gt; matchingCodecs;</span><br><span class="line">		<span class="comment">// 查找该mimeType对应的编解码器</span></span><br><span class="line">    MediaCodecList::findMatchingCodecs(</span><br><span class="line">            mime.c_str(),</span><br><span class="line">            encoder,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            &amp;matchingCodecs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = NAME_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; matchingCodecs.size(); ++i) &#123;</span><br><span class="line">      	<span class="comment">// 创建MediaCodec</span></span><br><span class="line">        sp&lt;MediaCodec&gt; codec = new MediaCodec(looper, pid, uid);</span><br><span class="line">        AString componentName = matchingCodecs[i];</span><br><span class="line">        <span class="comment">// 初始化编解码器</span></span><br><span class="line">        <span class="type">status_t</span> ret = codec-&gt;init(componentName);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *err = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> codec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="ACode-创建"><a href="#ACode-创建" class="headerlink" title="ACode 创建"></a>ACode 创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">MediaCodec::init</span><span class="params">(<span class="type">const</span> AString &amp;name)</span> &#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line">		<span class="comment">// 编解码器名称</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    AString tmp = name;</span><br><span class="line">  </span><br><span class="line">    <span class="type">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">		...</span><br><span class="line">    <span class="comment">// 查找该编解码器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> AString &amp;codecName : &#123; name, tmp &#125;) &#123;</span><br><span class="line">        <span class="type">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(codecName.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取该编解码器信息</span></span><br><span class="line">        mCodecInfo = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 创建ACodec</span></span><br><span class="line">    mCodec = GetCodecBase(name, mCodecInfo-&gt;getOwnerName());</span><br><span class="line">		...</span><br><span class="line">    mLooper-&gt;registerHandler(this);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setCallback(</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CodecBase::CodecCallback&gt;(</span><br><span class="line">                    new CodecCallback(new AMessage(kWhatCodecNotify, this))));</span><br><span class="line">    mBufferChannel = mCodec-&gt;getBufferChannel();</span><br><span class="line">    mBufferChannel-&gt;setCallback(</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CodecBase::BufferCallback&gt;(</span><br><span class="line">                    new BufferCallback(new AMessage(kWhatCodecNotify, this))));</span><br><span class="line">		<span class="comment">// 创建Init消息</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = new AMessage(kWhatInit, this);</span><br><span class="line">    msg-&gt;setObject(<span class="string">&quot;codecInfo&quot;</span>, mCodecInfo);</span><br><span class="line">    msg-&gt;setString(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">		...</span><br><span class="line">    <span class="type">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Don&#x27;t try to reclaim resource for the first time.</span></span><br><span class="line">            <span class="keyword">if</span> (!mResourceManagerService-&gt;reclaimResource(resources)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        <span class="comment">// 发送Init消息，连接OMX服务，创建解码器实例</span></span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">        <span class="keyword">if</span> (!isResourceError(err)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="OMX-Codec-创建"><a href="#OMX-Codec-创建" class="headerlink" title="OMX Codec 创建"></a>OMX Codec 创建</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ACodec::UninitializedState::onAllocateComponent(<span class="type">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    ALOGV(<span class="string">&quot;onAllocateComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(mCodec-&gt;mOMXNode == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = new AMessage(kWhatOMXMessageList, mCodec);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">&quot;generation&quot;</span>, mCodec-&gt;mNodeGeneration + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">&quot;codecInfo&quot;</span>, &amp;obj));</span><br><span class="line">    sp&lt;MediaCodecInfo&gt; info = (MediaCodecInfo *)obj.get();</span><br><span class="line">    <span class="keyword">if</span> (info == nullptr) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unexpected nullptr for codec information&quot;</span>);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, UNKNOWN_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AString owner = (info-&gt;getOwnerName() == nullptr) ? <span class="string">&quot;default&quot;</span> : info-&gt;getOwnerName();</span><br><span class="line"></span><br><span class="line">    AString componentName;</span><br><span class="line">    CHECK(msg-&gt;findString(<span class="string">&quot;componentName&quot;</span>, &amp;componentName));</span><br><span class="line"></span><br><span class="line">    sp&lt;CodecObserver&gt; observer = new CodecObserver(notify);</span><br><span class="line">    sp&lt;IOMX&gt; omx;</span><br><span class="line">    sp&lt;IOMXNode&gt; omxNode;</span><br><span class="line"></span><br><span class="line">    <span class="type">status_t</span> err = NAME_NOT_FOUND;</span><br><span class="line">    OMXClient client;</span><br><span class="line">    <span class="comment">// 连接OMX服务</span></span><br><span class="line">    <span class="keyword">if</span> (client.connect(owner.c_str()) != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, NO_INIT);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    omx = client.interface();</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> tid = gettid();</span><br><span class="line">    <span class="type">int</span> prevPriority = androidGetThreadPriority(tid);</span><br><span class="line">    androidSetThreadPriority(tid, ANDROID_PRIORITY_FOREGROUND);</span><br><span class="line">  	<span class="comment">// 创建编解码器实例</span></span><br><span class="line">    err = omx-&gt;allocateNode(componentName.c_str(), observer, &amp;omxNode);</span><br><span class="line">    androidSetThreadPriority(tid, prevPriority);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Unable to instantiate codec &#x27;%s&#x27; with err %#x.&quot;</span>, componentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;signalError((OMX_ERRORTYPE)err, makeNoSideEffectStatus(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDeathNotifier = new DeathNotifier(new AMessage(kWhatOMXDied, mCodec));</span><br><span class="line">    <span class="keyword">auto</span> tOmxNode = omxNode-&gt;getHalInterface&lt;IOmxNode&gt;();</span><br><span class="line">    <span class="keyword">if</span> (tOmxNode &amp;&amp; !tOmxNode-&gt;linkToDeath(mDeathNotifier, <span class="number">0</span>)) &#123;</span><br><span class="line">        mDeathNotifier.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++mCodec-&gt;mNodeGeneration;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;mComponentName = componentName;</span><br><span class="line">    mCodec-&gt;mRenderTracker.setComponentName(componentName);</span><br><span class="line">    mCodec-&gt;mFlags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (componentName.endsWith(<span class="string">&quot;.secure&quot;</span>)) &#123;</span><br><span class="line">        mCodec-&gt;mFlags |= kFlagIsSecure;</span><br><span class="line">        mCodec-&gt;mFlags |= kFlagIsGrallocUsageProtected;</span><br><span class="line">        mCodec-&gt;mFlags |= kFlagPushBlankBuffersToNativeWindowOnShutdown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;mOMX = omx;</span><br><span class="line">    mCodec-&gt;mOMXNode = omxNode;</span><br><span class="line">    mCodec-&gt;mCallback-&gt;onComponentAllocated(mCodec-&gt;mComponentName.c_str());</span><br><span class="line">    mCodec-&gt;changeState(mCodec-&gt;mLoadedState);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Omx 创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Omx::Omx() :</span><br><span class="line">    mMaster(new OMXMaster()),</span><br><span class="line">    mParser() &#123;</span><br><span class="line">    (<span class="type">void</span>)mParser.parseXmlFilesInSearchDirs();</span><br><span class="line">    (<span class="type">void</span>)mParser.parseXmlPath(mParser.defaultProfilingResultsXmlPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>OMXMaster 创建</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	OMXMaster::OMXMaster() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = getpid();</span><br><span class="line">    <span class="type">char</span> filename[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename), <span class="string">&quot;/proc/%d/comm&quot;</span>, pid);</span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      ALOGW(<span class="string">&quot;couldn&#x27;t determine process name&quot;</span>);</span><br><span class="line">      strlcpy(mProcessName, <span class="string">&quot;&lt;unknown&gt;&quot;</span>, <span class="keyword">sizeof</span>(mProcessName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">ssize_t</span> len = read(fd, mProcessName, <span class="keyword">sizeof</span>(mProcessName));</span><br><span class="line">      <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">&quot;couldn&#x27;t determine process name&quot;</span>);</span><br><span class="line">        strlcpy(mProcessName, <span class="string">&quot;&lt;unknown&gt;&quot;</span>, <span class="keyword">sizeof</span>(mProcessName));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the name is newline terminated, so erase the newline</span></span><br><span class="line">        mProcessName[len - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addVendorPlugin();</span><br><span class="line">    addPlatformPlugin();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OMXMaster::addVendorPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">    addPlugin(<span class="string">&quot;libstagefrighthw.so&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OMXMaster::addPlatformPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">    addPlugin(<span class="string">&quot;libstagefright_softomx_plugin.so&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OMXMaster::addPlugin</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *libname)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *libHandle = android_load_sphal_library(libname, RTLD_NOW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (libHandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> OMXPluginBase *(*CreateOMXPluginFunc)();</span><br><span class="line">    CreateOMXPluginFunc createOMXPlugin =</span><br><span class="line">        (CreateOMXPluginFunc)dlsym(</span><br><span class="line">                libHandle, <span class="string">&quot;createOMXPlugin&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!createOMXPlugin)</span><br><span class="line">        createOMXPlugin = (CreateOMXPluginFunc)dlsym(</span><br><span class="line">                libHandle, <span class="string">&quot;_ZN7android15createOMXPluginEv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    OMXPluginBase *plugin = nullptr;</span><br><span class="line">    <span class="keyword">if</span> (createOMXPlugin) &#123;</span><br><span class="line">        plugin = (*createOMXPlugin)();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (plugin) &#123;</span><br><span class="line">        mPlugins.push_back(&#123; plugin, libHandle &#125;);</span><br><span class="line">        addPlugin(plugin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        android_unload_sphal_library(libHandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>创建 编解码器实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Return&lt;<span class="type">void</span>&gt; <span class="title function_">Omx::allocateNode</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">const</span> hidl_string&amp; name,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> sp&lt;IOmxObserver&gt;&amp; observer,</span></span><br><span class="line"><span class="params">        allocateNode_cb _hidl_cb)</span> &#123;</span><br><span class="line"></span><br><span class="line">    using ::android::IOMXNode;</span><br><span class="line">    using ::android::IOMXObserver;</span><br><span class="line"></span><br><span class="line">    sp&lt;OMXNodeInstance&gt; instance;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock <span class="title function_">autoLock</span><span class="params">(mLock)</span>;</span><br><span class="line">        <span class="keyword">if</span> (mLiveNodes.size() == kMaxNodeInstances) &#123;</span><br><span class="line">            _hidl_cb(toStatus(NO_MEMORY), nullptr);</span><br><span class="line">            <span class="keyword">return</span> Void();</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">// 创建编解码器实例</span></span><br><span class="line">        instance = new OMXNodeInstance(</span><br><span class="line">                this, new LWOmxObserver(observer), name.c_str());</span><br><span class="line"></span><br><span class="line">        OMX_COMPONENTTYPE *handle;</span><br><span class="line">      	<span class="comment">// 生成实例</span></span><br><span class="line">        OMX_ERRORTYPE err = mMaster-&gt;makeComponentInstance(</span><br><span class="line">                name.c_str(), &amp;OMXNodeInstance::kCallbacks,</span><br><span class="line">                instance.get(), &amp;handle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OMX_ErrorNone) &#123;</span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">&quot;Failed to allocate omx component &quot;</span></span><br><span class="line">                    <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; name.c_str() &lt;&lt; <span class="string">&quot;&#x27; &quot;</span></span><br><span class="line">                    <span class="string">&quot; err=&quot;</span> &lt;&lt; asString(err) &lt;&lt;</span><br><span class="line">                    <span class="string">&quot;(0x&quot;</span> &lt;&lt; <span class="built_in">std</span>::hex &lt;&lt; <span class="type">unsigned</span>(err) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            _hidl_cb(toStatus(StatusFromOMXError(err)), nullptr);</span><br><span class="line">            <span class="keyword">return</span> Void();</span><br><span class="line">        &#125;</span><br><span class="line">        instance-&gt;setHandle(handle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find quirks from mParser</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; codec = mParser.getCodecMap().find(name.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codec == mParser.getCodecMap().cend()) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt; <span class="string">&quot;Failed to obtain quirks for omx component &quot;</span></span><br><span class="line">                    <span class="string">&quot;&#x27;&quot;</span> &lt;&lt; name.c_str() &lt;&lt; <span class="string">&quot;&#x27; &quot;</span></span><br><span class="line">                    <span class="string">&quot;from XML files&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">uint32_t</span> quirks = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; quirk : codec-&gt;second.quirkSet) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quirk == <span class="string">&quot;quirk::requires-allocate-on-input-ports&quot;</span>) &#123;</span><br><span class="line">                    quirks |= OMXNodeInstance::</span><br><span class="line">                            kRequiresAllocateBufferOnInputPorts;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (quirk == <span class="string">&quot;quirk::requires-allocate-on-output-ports&quot;</span>) &#123;</span><br><span class="line">                    quirks |= OMXNodeInstance::</span><br><span class="line">                            kRequiresAllocateBufferOnOutputPorts;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instance-&gt;setQuirks(quirks);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLiveNodes.add(observer.get(), instance);</span><br><span class="line">        mNode2Observer.add(instance.get(), observer.get());</span><br><span class="line">    &#125;</span><br><span class="line">    observer-&gt;linkToDeath(this, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    _hidl_cb(toStatus(OK), new TWOmxNode(instance));</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS硬件编解码-VideoToolbox</title>
    <url>/2022/07/14/av/iOS%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81-VideoToolbox/</url>
    <content><![CDATA[<p>在 iOS 平台上，VideoToolbox 是 Apple 提供的一个强大的框架，用于执行硬件加速的视频编解码。它支持广泛的视频编码格式，包括但不限于 H.264 和 HEVC。使用 VideoToolbox 可以提高编解码的性能，同时降低 CPU 使用率。</p>
<h1 id="VideoToolbox-编解码流程"><a href="#VideoToolbox-编解码流程" class="headerlink" title="VideoToolbox 编解码流程"></a>VideoToolbox 编解码流程</h1><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><h3 id="创建解码器"><a href="#创建解码器" class="headerlink" title="创建解码器"></a>创建解码器</h3><h4 id="设置视频描述信息"><a href="#设置视频描述信息" class="headerlink" title="设置视频描述信息"></a>设置视频描述信息</h4><p>将vps sps pps信息读取出来设置到CMVideoFormatDescriptionRef中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CMVideoFormatDescriptionRef <span class="title">VideoToolBoxDecoderImpl::CreateVideoFormatDesc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VideoInfo &amp;video_info, <span class="type">const</span> ExtraData &amp;extra_data)</span> </span>&#123;</span><br><span class="line">  OSStatus status;</span><br><span class="line">  CMFormatDescriptionRef format_desc;</span><br><span class="line">  <span class="keyword">switch</span> (video_info.codec_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CodecType::CODEC_TYPE_H264: &#123;</span><br><span class="line">      <span class="keyword">auto</span> *avc_ps_ = <span class="keyword">new</span> avc::<span class="built_in">ParamSets</span>();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 准备好sps pps数据</span></span><br><span class="line">      <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> parameterSetPointers[] = &#123;avc_ps_-&gt;sps_list[<span class="number">0</span>].data,</span><br><span class="line">                                                     avc_ps_-&gt;pps_list[<span class="number">0</span>].data&#125;;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> parameterSetSizes[] = &#123;</span><br><span class="line">          (<span class="type">size_t</span>)avc_ps_-&gt;sps_list[<span class="number">0</span>].data_size,</span><br><span class="line">          (<span class="type">size_t</span>)avc_ps_-&gt;pps_list[<span class="number">0</span>].data_size&#125;;</span><br><span class="line">      status = <span class="built_in">CMVideoFormatDescriptionCreateFromH264ParameterSets</span>(</span><br><span class="line">          kCFAllocatorDefault, <span class="number">2</span>, parameterSetPointers, parameterSetSizes, <span class="number">4</span>,</span><br><span class="line">          &amp;format_desc);</span><br><span class="line">      <span class="keyword">delete</span> avc_ps_;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CodecType::CODEC_TYPE_H265: &#123;</span><br><span class="line">      <span class="keyword">auto</span> *hevc_ps = <span class="keyword">new</span> hevc::<span class="built_in">ParamSets</span>();</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 准备好vps sps pps数据</span></span><br><span class="line">      <span class="keyword">if</span> (hevc_ps-&gt;vps_list.<span class="built_in">empty</span>() || hevc_ps-&gt;sps_list.<span class="built_in">empty</span>() ||</span><br><span class="line">          hevc_ps-&gt;pps_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">const</span> <span class="type">uint8_t</span> *<span class="type">const</span> parameterSetPointers[] = &#123;hevc_ps-&gt;vps_list[<span class="number">0</span>].data,</span><br><span class="line">                                                     hevc_ps-&gt;sps_list[<span class="number">0</span>].data,</span><br><span class="line">                                                     hevc_ps-&gt;pps_list[<span class="number">0</span>].data&#125;;</span><br><span class="line">      <span class="type">const</span> <span class="type">size_t</span> parameterSetSizes[] = &#123;</span><br><span class="line">          (<span class="type">size_t</span>)hevc_ps-&gt;vps_list[<span class="number">0</span>].data_size,</span><br><span class="line">          (<span class="type">size_t</span>)hevc_ps-&gt;sps_list[<span class="number">0</span>].data_size,</span><br><span class="line">          (<span class="type">size_t</span>)hevc_ps-&gt;pps_list[<span class="number">0</span>].data_size&#125;;</span><br><span class="line">      status = <span class="built_in">CMVideoFormatDescriptionCreateFromHEVCParameterSets</span>(</span><br><span class="line">          kCFAllocatorDefault, <span class="number">3</span>, parameterSetPointers, parameterSetSizes, <span class="number">4</span>,</span><br><span class="line">          nil, &amp;format_desc);</span><br><span class="line">      <span class="keyword">delete</span> hevc_ps;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> format_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="设置缓冲区属性"><a href="#设置缓冲区属性" class="headerlink" title="设置缓冲区属性"></a>设置缓冲区属性</h4><p>可以通过kCVPixelBufferPixelFormatTypeKey设置输出的颜色格式，内部会进行格式转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CFDictionaryRef <span class="title">VideoToolBoxDecoderImpl::CreateVideoBufferAttr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VideoInfo &amp;video_info)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  CFNumberRef w = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type,</span><br><span class="line">                                 &amp;video_info.width);</span><br><span class="line">  CFNumberRef h = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type,</span><br><span class="line">                                 &amp;video_info.height);</span><br><span class="line"></span><br><span class="line">  OSType pix_fmt = <span class="built_in">PixFormatConvert</span>&lt;PixFormat, OSType&gt;(video_info.pix_fmt);</span><br><span class="line">  <span class="keyword">if</span> (pix_fmt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CFNumberRef cv_pix_fmt =</span><br><span class="line">      <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;pix_fmt);</span><br><span class="line"></span><br><span class="line">  CFMutableDictionaryRef buffer_attributes = <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">      kCFAllocatorDefault, <span class="number">5</span>, &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">      &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">  CFMutableDictionaryRef io_surface_properties = <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">      kCFAllocatorDefault, <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">      &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CPU、GUP共享内存，后续可以直接上传纹理</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferIOSurfacePropertiesKey,</span><br><span class="line">                       io_surface_properties);</span><br><span class="line">  <span class="comment">// 设置输出颜色格式和分辨率</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferPixelFormatTypeKey,</span><br><span class="line">                       cv_pix_fmt);</span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferWidthKey, w);</span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferHeightKey, h);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes,</span><br><span class="line">                       kCVPixelBufferOpenGLESCompatibilityKey, kCFBooleanTrue);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes,</span><br><span class="line">                       kCVPixelBufferIOSurfaceOpenGLTextureCompatibilityKey,</span><br><span class="line">                       kCFBooleanTrue);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CFRelease</span>(io_surface_properties);</span><br><span class="line">  <span class="built_in">CFRelease</span>(cv_pix_fmt);</span><br><span class="line">  <span class="built_in">CFRelease</span>(w);</span><br><span class="line">  <span class="built_in">CFRelease</span>(h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="创建解压缩会话"><a href="#创建解压缩会话" class="headerlink" title="创建解压缩会话"></a>创建解压缩会话</h4><p>(<code>VTDecompressionSessionCreate</code>)：根据视频流的格式信息创建解码会话。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VTDecompressionSessionRef session;</span><br><span class="line"><span class="comment">// 设置视频描述信息</span></span><br><span class="line">CMVideoFormatDescriptionRef format_desc = <span class="built_in">CreateVideoFormatDesc</span>(video_info_, extra_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置缓冲区属性 </span></span><br><span class="line">CFDictionaryRef buf_attr = <span class="built_in">CreateVideoBufferAttr</span>(video_info_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码回调</span></span><br><span class="line">VTDecompressionOutputCallbackRecord decoder_cb;</span><br><span class="line">decoder_cb.decompressionOutputCallback =</span><br><span class="line">    [](<span class="type">void</span> *opaque, <span class="type">void</span> *sourceFrameRefCon, OSStatus status,</span><br><span class="line">       VTDecodeInfoFlags flags, CVImageBufferRef image_buffer, CMTime pts,</span><br><span class="line">       CMTime duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status != noErr) &#123;</span><br><span class="line">         <span class="built_in">LOG</span>(<span class="string">&quot;VTDecompressionSessionDecodeFrame failed status = %d&quot;</span>, status);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line">decoder_cb.decompressionOutputRefCon = <span class="keyword">this</span>;</span><br><span class="line"><span class="comment">// 创建解码会话</span></span><br><span class="line">OSStatus status = <span class="built_in">VTDecompressionSessionCreate</span>(kCFAllocatorDefault, format_desc, <span class="literal">nullptr</span>,</span><br><span class="line">                                 buf_attr, &amp;decoder_cb, &amp;session);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(buf_attr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">  <span class="built_in">CFRelease</span>(format_desc);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><p>VideoToolbox支持的avc格式的码流，不支持Annex-B格式的码流，需要提前处理好</p>
<h4 id="创建SampleBuffer"><a href="#创建SampleBuffer" class="headerlink" title="创建SampleBuffer"></a>创建SampleBuffer</h4><p>用来保存压缩数据和对应时间戳的 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CMSampleBufferRef <span class="title">VideoToolBoxDecoderImpl::CreateSampleBuffer</span><span class="params">(Packet &amp;packet)</span> </span>&#123;</span><br><span class="line">  CMSampleBufferRef sample_buf;</span><br><span class="line">  CMBlockBufferRef block_buf;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  使用 CMBlockBufferCreateWithMemoryBlock 接口将 NALU unit 封装成</span></span><br><span class="line">  <span class="comment">//  CMBlockBuffer</span></span><br><span class="line">  <span class="comment">// 将数据拷贝到Buffer中</span></span><br><span class="line">  OSStatus status = <span class="built_in">CMBlockBufferCreateWithMemoryBlock</span>(</span><br><span class="line">      kCFAllocatorDefault, packet.byte_data, packet.data_size, kCFAllocatorNull,</span><br><span class="line">      <span class="literal">nullptr</span>, <span class="number">0</span>, packet.data_size, <span class="number">0</span>, &amp;block_buf);</span><br><span class="line">  <span class="keyword">if</span> (status) &#123;</span><br><span class="line">    <span class="keyword">return</span> sample_buf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CMSampleTimingInfo timingInfo = kCMTimingInfoInvalid;</span><br><span class="line">  <span class="comment">// 将时间戳存入</span></span><br><span class="line">  timingInfo.presentationTimeStamp = <span class="built_in">CMTimeMake</span>(packet.pts, <span class="number">1000</span>);</span><br><span class="line">  timingInfo.duration = <span class="built_in">CMTimeMake</span>(packet.duration, <span class="number">1000</span>);</span><br><span class="line">  timingInfo.decodeTimeStamp = <span class="built_in">CMTimeMake</span>(packet.dts, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">//  通过 CMSampleBufferCreate 将 CMBlockBuffer + CMVideoFormatDescription +</span></span><br><span class="line">  <span class="comment">//  CMTime 创建成 CMSampleBuffer</span></span><br><span class="line">  status = <span class="built_in">CMSampleBufferCreate</span>(kCFAllocatorDefault, block_buf, TRUE, <span class="literal">nullptr</span>,</span><br><span class="line">                                <span class="literal">nullptr</span>, format_desc_, <span class="number">1</span>, <span class="number">1</span>, &amp;timingInfo, <span class="number">0</span>,</span><br><span class="line">                                <span class="literal">nullptr</span>, &amp;sample_buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (block_buf) &#123;</span><br><span class="line">    <span class="built_in">CFRelease</span>(block_buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status ? <span class="literal">nullptr</span> : sample_buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解码视频帧"><a href="#解码视频帧" class="headerlink" title="解码视频帧"></a>解码视频帧</h4><p>(<code>VTDecompressionSessionDecodeFrame</code>)：将编码的视频帧数据送入解码器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">OSStatus status;</span><br><span class="line">CMSampleBufferRef sample_buf = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (packet.<span class="built_in">get</span>()-&gt;byte_data) &#123;</span><br><span class="line">  sample_buf = <span class="built_in">CreateSampleBuffer</span>(*packet);</span><br><span class="line">  <span class="keyword">if</span> (sample_buf == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> HMError::FAILED;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将SampleBuffer送人解码器进行解码  </span></span><br><span class="line">status = <span class="built_in">VTDecompressionSessionDecodeFrame</span>(session_, sample_buf, <span class="number">0</span>, <span class="literal">nullptr</span>,</span><br><span class="line">                                           <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (sample_buf) &#123;</span><br><span class="line">  <span class="built_in">CFRelease</span>(sample_buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="帧排序"><a href="#帧排序" class="headerlink" title="帧排序"></a>帧排序</h4><p>当存在B帧时，VideoToolbox并不会进行帧排序，所以其输出的视频顺序是按照dts的顺序输出，需要应用层自身来解决；<br>可以通过维护一个队列，当解析到非B帧，也就是I或者P帧时，就表明上一个非B帧时间戳自身以及之前的所有帧都准备好了，通过排序后，按照顺序向外输出即可；<br>也就是每解完一个连续的B帧序列都可以向外输出当前序列，队列最多缓存16+1帧；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (packet-&gt;byte_data) &#123;</span><br><span class="line">  std::<span class="built_in">sort</span>(frame_queue_.<span class="built_in">begin</span>(), frame_queue_.<span class="built_in">end</span>(),</span><br><span class="line">            [](<span class="keyword">auto</span> f1, <span class="keyword">auto</span> f2) &#123; <span class="keyword">return</span> f1-&gt;timestamp &lt; f2-&gt;timestamp; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (packet-&gt;slice_type != SliceType::B_FRAME) &#123;</span><br><span class="line">    <span class="keyword">if</span> (last_nonb_pts &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      current_pts_ = last_nonb_pts;</span><br><span class="line">    &#125;</span><br><span class="line">    last_nonb_pts = packet-&gt;pts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="处理解码输出"><a href="#处理解码输出" class="headerlink" title="处理解码输出"></a>处理解码输出</h4><p>通过回调函数处理解码后的视频帧，比如显示到屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">decoder_cb.decompressionOutputCallback =</span><br><span class="line">    [](<span class="type">void</span> *opaque, <span class="type">void</span> *sourceFrameRefCon, OSStatus status,</span><br><span class="line">       VTDecodeInfoFlags flags, CVImageBufferRef image_buffer, CMTime pts,</span><br><span class="line">       CMTime duration) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status != noErr) &#123;</span><br><span class="line">        <span class="built_in">AVLOG</span>(<span class="string">&quot;VTDecompressionSessionDecodeFrame failed status = %d&quot;</span>, status);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读取解码输出的ImageBuffer</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="读取解码数据"><a href="#读取解码数据" class="headerlink" title="读取解码数据"></a>读取解码数据</h4><p>从ImageBuffer中读取不同格式的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CVPixelBufferLockBaseAddress</span>(src, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dst-&gt;video_frame_info.width = <span class="built_in">CVPixelBufferGetWidth</span>(src);</span><br><span class="line">dst-&gt;video_frame_info.height = <span class="built_in">CVPixelBufferGetHeight</span>(src);</span><br><span class="line"></span><br><span class="line">OSType format = <span class="built_in">CVPixelBufferGetPixelFormatType</span>(src);</span><br><span class="line"><span class="type">uint8_t</span>* src_data = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line">  <span class="keyword">case</span> kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange: &#123;</span><br><span class="line">    dst-&gt;video_frame_info.pix_fmt = PixFormat::PIX_FMT_NV12;</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_NV12, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">1</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">1</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">1</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">1</span>], src_data, len);</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> kCVPixelFormatType_420YpCbCr8Planar: &#123;</span><br><span class="line">    dst-&gt;video_frame_info.pix_fmt = PixFormat::PIX_FMT_I420;</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_I420, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">1</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">1</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">1</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">1</span>], src_data, len);</span><br><span class="line"></span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">2</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">2</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">2</span>] * (dst-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">2</span>], src_data, len);</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> kCVPixelFormatType_32ARGB:</span><br><span class="line">    dst-&gt;video_frame_info.pix_fmt = PixFormat::PIX_FMT_ARGB;</span><br><span class="line">    <span class="keyword">if</span> (!dst-&gt;byte_data.data) &#123;</span><br><span class="line">      <span class="built_in">FrameDataAlloc</span>(&amp;dst-&gt;byte_data, PixFormat::PIX_FMT_ARGB, dst-&gt;video_frame_info.width,</span><br><span class="line">                     dst-&gt;video_frame_info.height);</span><br><span class="line">    &#125;</span><br><span class="line">    dst-&gt;byte_data.linesize[<span class="number">0</span>] = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    len = dst-&gt;byte_data.linesize[<span class="number">0</span>] * dst-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    src_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(src, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;byte_data.data[<span class="number">0</span>], src_data, len);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CVPixelBufferUnlockBaseAddress</span>(src, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="end-of-stream"><a href="#end-of-stream" class="headerlink" title="end_of_stream"></a>end_of_stream</h4><p>当输入的解码结束后，需要将解码器中剩余的帧全部吐出来，告诉解码器已经end_of_stream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (send_eos_) &#123;</span><br><span class="line">  <span class="built_in">VTDecompressionSessionWaitForAsynchronousFrames</span>(session_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束解码会话"><a href="#结束解码会话" class="headerlink" title="结束解码会话"></a>结束解码会话</h3><p>解码完成后，释放会话和相关资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (session_) &#123;</span><br><span class="line">  <span class="built_in">VTDecompressionSessionInvalidate</span>(session_);</span><br><span class="line">  <span class="built_in">CFRelease</span>(session_);</span><br><span class="line">  session_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (format_desc_) &#123;</span><br><span class="line">  <span class="built_in">CFRelease</span>(format_desc_);</span><br><span class="line">  format_desc_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="创建编码器"><a href="#创建编码器" class="headerlink" title="创建编码器"></a>创建编码器</h3><h4 id="设置缓冲区属性-1"><a href="#设置缓冲区属性-1" class="headerlink" title="设置缓冲区属性"></a>设置缓冲区属性</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CFDictionaryRef <span class="title">VideoToolBoxEncoderImpl::CreateVideoBufferAttr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> VideoInfo &amp;video_info)</span> </span>&#123;</span><br><span class="line">  CFNumberRef w = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type,</span><br><span class="line">                                 &amp;video_info.width);</span><br><span class="line">  CFNumberRef h = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type,</span><br><span class="line">                                 &amp;video_info.height);</span><br><span class="line"></span><br><span class="line">  OSType pix_fmt = <span class="built_in">PixFormatConvert</span>&lt;PixFormat, OSType&gt;(video_info.pix_fmt);</span><br><span class="line">  <span class="keyword">if</span> (pix_fmt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CFNumberRef cv_pix_fmt =</span><br><span class="line">      <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;pix_fmt);</span><br><span class="line"></span><br><span class="line">  CFMutableDictionaryRef buffer_attributes = <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">      kCFAllocatorDefault, <span class="number">5</span>, &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">      &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">  CFMutableDictionaryRef io_surface_properties = <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">      kCFAllocatorDefault, <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">      &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CPU、GUP共享内存</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferIOSurfacePropertiesKey,</span><br><span class="line">                       io_surface_properties);</span><br><span class="line">  <span class="comment">// 输出格式和分辨率</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferPixelFormatTypeKey,</span><br><span class="line">                       cv_pix_fmt);</span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferWidthKey, w);</span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes, kCVPixelBufferHeightKey, h);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TARGET_OS_IPHONE</span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes,</span><br><span class="line">                       kCVPixelBufferOpenGLESCompatibilityKey, kCFBooleanTrue);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="built_in">CFDictionarySetValue</span>(buffer_attributes,</span><br><span class="line">                       kCVPixelBufferIOSurfaceOpenGLTextureCompatibilityKey,</span><br><span class="line">                       kCFBooleanTrue);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">CFRelease</span>(io_surface_properties);</span><br><span class="line">  <span class="built_in">CFRelease</span>(cv_pix_fmt);</span><br><span class="line">  <span class="built_in">CFRelease</span>(w);</span><br><span class="line">  <span class="built_in">CFRelease</span>(h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建编码会话"><a href="#创建编码会话" class="headerlink" title="创建编码会话"></a>创建编码会话</h4><p>(<code>VTCompressionSessionCreate</code>)：设置视频编码参数，创建一个用于视频压缩的会话。设置编码器的各种属性，如码率、帧率、分辨率等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VTCompressionSessionRef session;</span><br><span class="line"></span><br><span class="line">CFDictionaryRef buf_attr = <span class="built_in">CreateVideoBufferAttr</span>(video_info_);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建PixelBuffer缓存池，用于统一管理接收编码输入数据  </span></span><br><span class="line"><span class="built_in">CVPixelBufferPoolCreate</span>(kCFAllocatorDefault, <span class="literal">nullptr</span>, buf_attr, &amp;pool);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码回调  </span></span><br><span class="line">VTCompressionOutputCallback encoder_cb =</span><br><span class="line">    [](<span class="type">void</span> *outputCallbackRefCon, <span class="type">void</span> *sourceFrameRefCon, OSStatus status,</span><br><span class="line">       VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status != noErr) &#123;</span><br><span class="line">        <span class="built_in">AVLOG</span>(<span class="string">&quot;VTCompressionSessionEncodeFrame failed status = %d&quot;</span>, status);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">CMVideoCodecType codec_type = <span class="built_in">CodecTypeConvert</span>&lt;CodecType, CMVideoCodecType&gt;(video_info_.codec_type);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建编码会话，指定宽高，编码协议</span></span><br><span class="line">OSStatus status = <span class="built_in">VTCompressionSessionCreate</span>(</span><br><span class="line">    kCFAllocatorDefault, video_info_.width, video_info_.height, codec_type,</span><br><span class="line">    <span class="literal">nullptr</span>, buf_attr, <span class="literal">nullptr</span>, encoder_cb, <span class="keyword">this</span>, &amp;session);</span><br><span class="line"></span><br><span class="line">CFMutableDictionaryRef props = <span class="built_in">CFDictionaryCreateMutable</span>(</span><br><span class="line">    kCFAllocatorDefault, <span class="number">5</span>, &amp;kCFTypeDictionaryKeyCallBacks,</span><br><span class="line">    &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line"></span><br><span class="line">CFNumberRef fps = <span class="built_in">CFNumberCreate</span>(kCFAllocatorDefault, kCFNumberSInt32Type,</span><br><span class="line">                                 &amp;video_info_.fps);</span><br><span class="line">CFNumberRef bit_rate = <span class="built_in">CFNumberCreate</span>(</span><br><span class="line">    kCFAllocatorDefault, kCFNumberSInt32Type, &amp;video_info_.bit_rate);</span><br><span class="line"><span class="comment">// 设置编码帧率，码率  </span></span><br><span class="line"><span class="built_in">CFDictionarySetValue</span>(props, kVTCompressionPropertyKey_ExpectedFrameRate, fps);</span><br><span class="line"><span class="built_in">CFDictionarySetValue</span>(props, kVTCompressionPropertyKey_AverageBitRate,</span><br><span class="line">                     bit_rate);</span><br><span class="line"><span class="comment">// 默认开启B帧                  </span></span><br><span class="line"><span class="built_in">CFDictionarySetValue</span>(props, kVTCompressionPropertyKey_AllowFrameReordering,</span><br><span class="line">                     kCFBooleanTrue);</span><br><span class="line"></span><br><span class="line"><span class="built_in">VTSessionSetProperties</span>(session, props);</span><br><span class="line"></span><br><span class="line"><span class="built_in">VTCompressionSessionPrepareToEncodeFrames</span>(session);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRelease</span>(props);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session_ = session;</span><br></pre></td></tr></table></figure>

<h3 id="处理数据-1"><a href="#处理数据-1" class="headerlink" title="处理数据"></a>处理数据</h3><p>VideoToolbox输出的是avc格式的码流，所以需要将sps pps数据格式包装为avc格式的ExtraData</p>
<h4 id="写入输入数据"><a href="#写入输入数据" class="headerlink" title="写入输入数据"></a>写入输入数据</h4><p>向ImageBuffer中写入不同格式的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CVPixelBufferLockBaseAddress</span>(dst, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* dst_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"><span class="keyword">switch</span> (src-&gt;video_frame_info.pix_fmt) &#123;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_I420:</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">1</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">1</span>], len);</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">2</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">2</span>], len);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_NV12: &#123;</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">0</span>);</span><br><span class="line">    <span class="type">size_t</span> i = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(dst, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line"></span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">1</span>] * (src-&gt;video_frame_info.height / <span class="number">2</span>) * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> i1 = <span class="built_in">CVPixelBufferGetBytesPerRowOfPlane</span>(dst, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">1</span>], len);</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PixFormat::PIX_FMT_ARGB:</span><br><span class="line">    len = src-&gt;byte_data.linesize[<span class="number">0</span>] * src-&gt;video_frame_info.height * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">    dst_data = (<span class="type">uint8_t</span>*)<span class="built_in">CVPixelBufferGetBaseAddressOfPlane</span>(dst, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(dst_data, src-&gt;byte_data.data[<span class="number">0</span>], len);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CVPixelBufferUnlockBaseAddress</span>(dst, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="编码帧数据"><a href="#编码帧数据" class="headerlink" title="编码帧数据"></a>编码帧数据</h4><p>(<code>VTCompressionSessionEncodeFrame</code>)：将原始视频帧送入编码器进行编码。<br>从Buffer池子中创建CVImageBufferRef用来接收编码输入数据，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CVImageBufferRef pixel_buffer = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">CVPixelBufferPoolCreatePixelBuffer</span>(kCFAllocatorDefault, pool, &amp;pixel_buffer);</span><br><span class="line"><span class="keyword">if</span> (!pixel_buffer) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入到ImageBuffer中</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">CMTime timestamp = <span class="built_in">CMTimeMake</span>(frame-&gt;timestamp, COMMON_TIME_BASE);</span><br><span class="line">CMTime timespan = <span class="built_in">CMTimeMake</span>(frame-&gt;timespan, COMMON_TIME_BASE);</span><br><span class="line">VTEncodeInfoFlags flags = kVTEncodeInfo_Asynchronous;</span><br><span class="line"><span class="comment">// 向编码器中送入一帧以及对应的时间戳</span></span><br><span class="line">OSStatus status = <span class="built_in">VTCompressionSessionEncodeFrame</span>(</span><br><span class="line">    session_, frame-&gt;byte_data.data ? pixel_buffer : <span class="literal">nullptr</span>, timestamp,</span><br><span class="line">    timespan, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;flags);</span><br><span class="line"><span class="keyword">if</span> (pixel_buffer) &#123;</span><br><span class="line">  <span class="built_in">CFRelease</span>(pixel_buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>


<h4 id="处理压缩输出"><a href="#处理压缩输出" class="headerlink" title="处理压缩输出"></a>处理压缩输出</h4><p>使用回调函数处理压缩后的数据，通常是将其写入文件或网络传输。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VTCompressionOutputCallback encoder_cb =</span><br><span class="line">    [](<span class="type">void</span> *outputCallbackRefCon, <span class="type">void</span> *sourceFrameRefCon, OSStatus status,</span><br><span class="line">       VTEncodeInfoFlags infoFlags, CMSampleBufferRef sampleBuffer) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status != noErr) &#123;</span><br><span class="line">        <span class="built_in">AVLOG</span>(<span class="string">&quot;VTCompressionSessionEncodeFrame failed status = %d&quot;</span>, status);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 读取编码输出的SampleBuffer</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，VideoToolbox在有B帧的情况下，并没有对dts进行偏移，会导致后续muxer有问题，所以需要进行处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> packet = std::<span class="built_in">make_unique</span>&lt;Packet&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> CMTime &amp;pts = <span class="built_in">CMSampleBufferGetPresentationTimeStamp</span>(sampleBuffer);</span><br><span class="line"><span class="type">const</span> CMTime &amp;dts = <span class="built_in">CMSampleBufferGetDecodeTimeStamp</span>(sampleBuffer);</span><br><span class="line"><span class="type">const</span> CMTime &amp;duration = <span class="built_in">CMSampleBufferGetDuration</span>(sampleBuffer);</span><br><span class="line">packet-&gt;pts = pts.value;</span><br><span class="line">packet-&gt;dts = dts.value - (<span class="number">2</span> * duration.value); <span class="comment">// dts偏移</span></span><br><span class="line">packet-&gt;duration = duration.value;</span><br><span class="line"></span><br><span class="line">CMBlockBufferRef blockBuffer = <span class="built_in">CMSampleBufferGetDataBuffer</span>(sampleBuffer);</span><br><span class="line"><span class="type">size_t</span> length, totalLength;</span><br><span class="line"><span class="type">char</span> *dataPointer;</span><br><span class="line"></span><br><span class="line">OSStatus statusCodeRet = <span class="built_in">CMBlockBufferGetDataPointer</span>(</span><br><span class="line">    blockBuffer, <span class="number">0</span>, &amp;length, &amp;totalLength, &amp;dataPointer);</span><br><span class="line"><span class="keyword">if</span> (statusCodeRet == noErr) &#123;</span><br><span class="line">  <span class="comment">// 获取到SampleBuffer的数据，将其拷贝出来</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> len = totalLength * <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">  packet-&gt;byte_data = <span class="built_in">static_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(<span class="built_in">malloc</span>(len));</span><br><span class="line">  <span class="built_in">memset</span>(packet-&gt;byte_data, <span class="number">0</span>, len);</span><br><span class="line">  <span class="built_in">memcpy</span>(packet-&gt;byte_data, dataPointer, len);</span><br><span class="line">  packet-&gt;data_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(totalLength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">packet_queue_.<span class="built_in">push_back</span>(packet.<span class="built_in">release</span>());</span><br></pre></td></tr></table></figure>

<h4 id="dts偏移"><a href="#dts偏移" class="headerlink" title="dts偏移"></a>dts偏移</h4><p>输出的帧pts和dts都是从0开始累计的，所以会导致dts大于pts的情况，需要进行dts偏移，否则在使用ffmpeg做muxer时会被丢弃</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I b b b b P</span><br><span class="line">1 2 3 4 5 6 pts</span><br><span class="line">1 3 4 5 6 2 dts</span><br><span class="line">0 2 3 4 5 1 dts</span><br><span class="line"></span><br><span class="line">当存在B帧时，由于后向参考帧需要提前编码，所以会前移，从而导致PTS与DTS会不一样；</span><br><span class="line">如上图，第6帧是前面四帧的后向参考，所以在编码时需要排到它们前面；从而导致dts为第二列所示，但是这又导致一个问题，同一帧的dts会大于pts，这从播放角度来将是不合理的，当这帧已经到了播放的时间，但是其解码时间缺没有到，所以如果用ffmpeg进行muxer会被抛弃。ffmpeg不接受dts&gt;pts的帧；</span><br><span class="line">因此需要进行dts偏移；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当没有B参考帧时，只会有P帧会被前移，所以dts向前偏移1帧即可，如第三列所示；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> I b b B b P</span><br><span class="line"> 1 2 3 4 5 6 pts</span><br><span class="line"> 1 4 5 3 6 2 dts</span><br><span class="line">-1 2 3 1 4 0 dts</span><br><span class="line"></span><br><span class="line">当存在B参考帧时，除了P帧会被前移，B参考帧也会被前移，所以dts向前偏移2帧才行，如果上图第三列所示；</span><br></pre></td></tr></table></figure>


<h4 id="获取sps-pps信息"><a href="#获取sps-pps信息" class="headerlink" title="获取sps pps信息"></a>获取sps pps信息</h4><p>从第一帧中获取sps pps信息，后续muxer要用到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isKeyFrame = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">auto</span> dict = <span class="built_in">static_cast</span>&lt;CFDictionaryRef&gt;(<span class="built_in">CFArrayGetValueAtIndex</span>(</span><br><span class="line">    <span class="built_in">CMSampleBufferGetSampleAttachmentsArray</span>(sampleBuffer, <span class="literal">true</span>), <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (dict) &#123;</span><br><span class="line">  isKeyFrame = !<span class="built_in">CFDictionaryContainsKey</span>(dict, kCMSampleAttachmentKey_NotSync);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isKeyFrame &amp;&amp; !extra_data_.extradata) &#123;</span><br><span class="line">  CMFormatDescriptionRef formatDescription =</span><br><span class="line">      <span class="built_in">CMSampleBufferGetFormatDescription</span>(sampleBuffer);</span><br><span class="line">  <span class="type">int</span> NALUnitHeaderLengthOut = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span> *vpsParmeterSet;</span><br><span class="line">  <span class="type">size_t</span> vpsParameterSetSize, vpsParameterCount;</span><br><span class="line">  <span class="built_in">CMVideoFormatDescriptionGetHEVCParameterSetAtIndex</span>(</span><br><span class="line">      formatDescription, <span class="number">0</span>, &amp;vpsParmeterSet, &amp;vpsParameterSetSize,</span><br><span class="line">      &amp;vpsParameterCount, &amp;NALUnitHeaderLengthOut);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span> *spsParameterSet;</span><br><span class="line">  <span class="type">size_t</span> spsParameterSetSize, spsParameterCount;</span><br><span class="line">  <span class="built_in">CMVideoFormatDescriptionGetHEVCParameterSetAtIndex</span>(</span><br><span class="line">      formatDescription, <span class="number">1</span>, &amp;spsParameterSet, &amp;spsParameterSetSize,</span><br><span class="line">      &amp;spsParameterCount, &amp;NALUnitHeaderLengthOut);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">uint8_t</span> *ppsParmeterSet;</span><br><span class="line">  <span class="type">size_t</span> ppsParameterSetSize, ppsParameterCount;</span><br><span class="line">  <span class="built_in">CMVideoFormatDescriptionGetHEVCParameterSetAtIndex</span>(</span><br><span class="line">      formatDescription, <span class="number">2</span>, &amp;ppsParmeterSet, &amp;ppsParameterSetSize,</span><br><span class="line">      &amp;ppsParameterCount, &amp;NALUnitHeaderLengthOut);</span><br><span class="line"></span><br><span class="line">  hevc::ParamSets ps = &#123;&#125;;</span><br><span class="line">  ps.nal_unit_header_length = NALUnitHeaderLengthOut;</span><br><span class="line">  hevc::VPS vps = &#123;&#125;;</span><br><span class="line">  <span class="built_in">memcpy</span>(vps.data, vpsParmeterSet, vpsParameterSetSize);</span><br><span class="line">  vps.data_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vpsParameterSetSize);</span><br><span class="line">  ps.vps_list.<span class="built_in">push_back</span>(vps);</span><br><span class="line">  hevc::SPS sps = &#123;&#125;;</span><br><span class="line">  <span class="built_in">memcpy</span>(sps.data, spsParameterSet, spsParameterSetSize);</span><br><span class="line">  sps.data_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(spsParameterSetSize);</span><br><span class="line">  ps.sps_list.<span class="built_in">push_back</span>(sps);</span><br><span class="line">  hevc::PPS pps = &#123;&#125;;</span><br><span class="line">  <span class="built_in">memcpy</span>(pps.data, ppsParmeterSet, ppsParameterSetSize);</span><br><span class="line">  pps.data_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(ppsParameterSetSize);</span><br><span class="line">  ps.pps_list.<span class="built_in">push_back</span>(pps);</span><br><span class="line">  hevc::<span class="built_in">ParseParamSetToExtraData</span>(ps, extra_data_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="end-of-stream-1"><a href="#end-of-stream-1" class="headerlink" title="end_of_stream"></a>end_of_stream</h4><p>当输入的编码结束后，需要将编码器中剩余的帧全部编码吐出来，告诉编码器已经end_of_stream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (send_eos_) &#123;</span><br><span class="line">  <span class="built_in">VTCompressionSessionCompleteFrames</span>(session_, kCMTimeInvalid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结束编码会话"><a href="#结束编码会话" class="headerlink" title="结束编码会话"></a>结束编码会话</h3><p>编码完成后，清理并释放会话资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (session_) &#123;</span><br><span class="line">  <span class="built_in">VTCompressionSessionInvalidate</span>(session_);</span><br><span class="line">  <span class="built_in">CFRelease</span>(session_);</span><br><span class="line">  session_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Web硬件编解码-WebCodec</title>
    <url>/2023/08/20/av/Web%E7%A1%AC%E4%BB%B6%E7%BC%96%E8%A7%A3%E7%A0%81-WebCodec/</url>
    <content><![CDATA[<p>WebCodec 是一个较新的 Web API，它为网页应用提供了接近硬件级的编解码能力。使用 WebCodec，开发者可以在浏览器中直接对音频和视频数据进行高效编解码，这对于实现复杂的媒体应用（如实时视频通信、视频编辑和游戏流）非常有用。</p>
<h1 id="WebCodec-编解码流程"><a href="#WebCodec-编解码流程" class="headerlink" title="WebCodec 编解码流程"></a>WebCodec 编解码流程</h1><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><h3 id="创建解码器"><a href="#创建解码器" class="headerlink" title="创建解码器"></a>创建解码器</h3><h4 id="设置解码器名称"><a href="#设置解码器名称" class="headerlink" title="设置解码器名称"></a>设置解码器名称</h4><p>WebCodec设置上参数与其它平台不同的一点，在于其名称字段比较繁琐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (VideoType == H264)</span><br><span class="line">   &#123;</span><br><span class="line">    ...</span><br><span class="line">       std::stringstream stream;</span><br><span class="line">       stream &lt;&lt; <span class="string">&quot;avc1.&quot;</span>;</span><br><span class="line">       stream &lt;&lt; <span class="built_in">decimalToHex</span>(profile_idc);</span><br><span class="line">       stream &lt;&lt; <span class="built_in">decimalToHex</span>(constraint_set_flags);</span><br><span class="line">       stream &lt;&lt; <span class="built_in">decimalToHex</span>(level_idc);</span><br><span class="line">       codecName = stream.<span class="built_in">str</span>();</span><br><span class="line">       <span class="comment">// codecName = &quot;avc1.640020&quot;;</span></span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(VideoType == H265)</span><br><span class="line">&#123;</span><br><span class="line">       std::stringstream stream;</span><br><span class="line">       stream &lt;&lt; <span class="string">&quot;hev1.&quot;</span>;</span><br><span class="line">	<span class="keyword">switch</span> (general_profile_space) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">           stream &lt;&lt; <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">           stream &lt;&lt; <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">           stream &lt;&lt; <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       stream &lt;&lt; general_profile_idc;</span><br><span class="line">       stream &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">       </span><br><span class="line">	MUInt32 val = (MUInt32)general_profile_compatibility_flag;</span><br><span class="line">       <span class="type">int</span> reversed = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           reversed |= val &amp; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">31</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           reversed &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           val &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       stream &lt;&lt; <span class="built_in">decimalToHex</span>(reversed, <span class="number">0</span>);</span><br><span class="line">       stream &lt;&lt; <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">       <span class="keyword">if</span> (general_tier_flag == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           stream &lt;&lt; <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           stream &lt;&lt; <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       stream &lt;&lt; general_level_idc;</span><br><span class="line">       MBool hasByte = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">       std::string constraint_string = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (general_constraint_indicator_flags[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               val = general_constraint_indicator_flags[i];</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="keyword">if</span> (val != <span class="number">0</span> || hasByte)</span><br><span class="line">           &#123;</span><br><span class="line">               constraint_string = <span class="string">&quot;.&quot;</span> + <span class="built_in">decimalToHex</span>(val, <span class="number">0</span>) + constraint_string;</span><br><span class="line">               hasByte = <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       stream &lt;&lt; constraint_string;</span><br><span class="line">       codecName = stream.<span class="built_in">str</span>();</span><br><span class="line">       <span class="comment">// codecName = &quot;hev1.1.6.L120.90&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="创建解码器实例"><a href="#创建解码器实例" class="headerlink" title="创建解码器实例"></a>创建解码器实例</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">VideoDecoder</span>(&#123;</span><br><span class="line">  <span class="title function_">output</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 解码成功回调</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">error</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 解码失败回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="配置解码器"><a href="#配置解码器" class="headerlink" title="配置解码器"></a>配置解码器</h4><p>WebCodec支持Annex-B格式和avc格式的码流，如果设置了description，则表示传入的是avc格式的码流，如果不传，则表示传入的是Annex-B格式的码流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> config = &#123;</span><br><span class="line">       <span class="attr">codec</span>: codecName,</span><br><span class="line">       <span class="attr">codedHeight</span>: height,</span><br><span class="line">       <span class="attr">codedWidth</span>: width,</span><br><span class="line">       <span class="attr">description</span>: description,</span><br><span class="line">       <span class="attr">hardwareAcceleration</span>: <span class="string">&quot;prefer-hardware&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">decoder.<span class="title function_">configure</span>(config);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h3><h4 id="输入解码数据"><a href="#输入解码数据" class="headerlink" title="输入解码数据"></a>输入解码数据</h4><p>使用 <code>decode</code> 方法将压缩的视频数据（通常是 <code>EncodedVideoChunk</code>）送入解码器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chunk = <span class="keyword">new</span> <span class="title class_">EncodedVideoChunk</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: is_sync ? <span class="string">&quot;key&quot;</span> : <span class="string">&quot;delta&quot;</span>,</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">  <span class="attr">duration</span>: duration,</span><br><span class="line">  <span class="attr">data</span>: data</span><br><span class="line">&#125;);</span><br><span class="line">decoder.<span class="title function_">decode</span>(chunk);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="处理输出解码"><a href="#处理输出解码" class="headerlink" title="处理输出解码"></a>处理输出解码</h4><p>VideoFrame包含了解码后的一帧数据，可以通过copyTo函数将输入拷贝到cpu中（比较耗时），也可以直接通过texImage2D直接绑定到纹理上。VideoFrame是一个Transferable objects，可以通过postMessage发送到其它Worker中使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">output</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 绑定纹理</span></span><br><span class="line">  gl.<span class="title function_">texImage2D</span>(gl.<span class="property">TEXTURE_2D</span>, <span class="number">0</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">RGBA</span>, gl.<span class="property">UNSIGNED_BYTE</span>, frame);</span><br><span class="line">  <span class="comment">// 下载数据</span></span><br><span class="line">  frame.<span class="title function_">copyTo</span>(buffer);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>解码完成后，调用 <code>close</code> 或 <code>flush</code> 释放解码器资源。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> decoder.<span class="title function_">flush</span>();</span><br><span class="line">decoder.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="创建编码器"><a href="#创建编码器" class="headerlink" title="创建编码器"></a>创建编码器</h3><h4 id="设置解码器名称-1"><a href="#设置解码器名称-1" class="headerlink" title="设置解码器名称"></a>设置解码器名称</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (VideoType == H264)</span><br><span class="line">&#123;</span><br><span class="line">    stream &lt;&lt; <span class="string">&quot;avc1.&quot;</span>;</span><br><span class="line">	<span class="keyword">switch</span> (Profile)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">case</span> H264_PROFILE_BASELINE:</span><br><span class="line">	    &#123;</span><br><span class="line">	        stream &lt;&lt; <span class="string">&quot;4200&quot;</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_PROFILE_MAIN:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;4d00&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_PROFILE_HIGH:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;6400&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;4200&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (Level)</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">case</span> H264_LEVEL_30:</span><br><span class="line">	    &#123;</span><br><span class="line">	        stream &lt;&lt; <span class="string">&quot;1e&quot;</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_LEVEL_31:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;1f&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_LEVEL_40:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;28&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_LEVEL_41:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;29&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_LEVEL_50:</span><br><span class="line">		&#123;</span><br><span class="line">               stream &lt;&lt; <span class="string">&quot;32&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> H264_LEVEL_51:</span><br><span class="line">		&#123;</span><br><span class="line">               stream &lt;&lt; <span class="string">&quot;33&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;1e&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (VideoType == H265)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Profile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> HEVC_PROFILE_MAIN:</span><br><span class="line">        &#123;</span><br><span class="line">            stream &lt;&lt; <span class="string">&quot;hev1.1.6.L93.B0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HEVC_PROFILE_MAIN10:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;hev1.2.4.L120.B0&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">		    stream &lt;&lt; <span class="string">&quot;hev1.1.6.L93.B0&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建编码器实例"><a href="#创建编码器实例" class="headerlink" title="创建编码器实例"></a>创建编码器实例</h4><p>使用 <code>VideoEncoder</code> 类创建一个视频编码器实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> <span class="title class_">VideoEncoder</span>(&#123;</span><br><span class="line">  <span class="title function_">output</span>(<span class="params">chunk, metadata</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">error</span>(<span class="params">e</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="配置解码器-1"><a href="#配置解码器-1" class="headerlink" title="配置解码器"></a>配置解码器</h4><p>WebCodec支持Annex-B格式和avc格式的码流，可以在config中指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">      <span class="attr">bitrateMode</span>: bitPref,</span><br><span class="line">      <span class="attr">codec</span>: codec,</span><br><span class="line">      <span class="attr">width</span>: width,</span><br><span class="line">      <span class="attr">height</span>: height,</span><br><span class="line">      <span class="attr">hardwareAcceleration</span>: hw,</span><br><span class="line">      <span class="attr">bitrate</span>: bitrate, </span><br><span class="line">      <span class="attr">framerate</span>: frameRate,</span><br><span class="line">      <span class="attr">keyInterval</span>: keyInterval,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(codec_type)&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;H264&quot;</span>:</span><br><span class="line">        config.<span class="property">avc</span> = &#123; <span class="attr">format</span>: <span class="string">&quot;annexb&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;H265&quot;</span>:</span><br><span class="line">        config.<span class="property">hevc</span> = &#123; <span class="attr">format</span>: <span class="string">&quot;annexb&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  encoder.<span class="title function_">configure</span>(config);</span><br></pre></td></tr></table></figure>

<h3 id="处理数据-1"><a href="#处理数据-1" class="headerlink" title="处理数据"></a>处理数据</h3><h4 id="输入编码数据"><a href="#输入编码数据" class="headerlink" title="输入编码数据"></a>输入编码数据</h4><p>通过 <code>encode</code> 方法将 <code>VideoFrame</code> 对象送入编码器进行编码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> init = &#123;</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">  <span class="attr">duration</span>: duration,</span><br><span class="line">  <span class="attr">codedWidth</span>: frameWidth,</span><br><span class="line">  <span class="attr">codedHeight</span>: frameHeight,</span><br><span class="line">  <span class="attr">format</span>: <span class="string">&quot;I420&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">  <span class="keyword">let</span> videoFrame = <span class="keyword">new</span> <span class="title class_">VideoFrame</span>(dst, init);</span><br><span class="line">  encoder.<span class="title function_">encode</span>(videoFrame,&#123;<span class="attr">keyFrame</span>:key_flag&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="处理输出解码-1"><a href="#处理输出解码-1" class="headerlink" title="处理输出解码"></a>处理输出解码</h4><p>通过copyTo可以拷贝编码结果到一个buffer中，调用muxer的write将其写入到文件中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">output</span>(<span class="params">chunk, metadata</span>) &#123;</span><br><span class="line">  <span class="comment">// metadata 包含sps pps数据</span></span><br><span class="line">  <span class="comment">// chunk 编码结果</span></span><br><span class="line">  chunk.<span class="title function_">copyTo</span>(buffer)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="释放资源-1"><a href="#释放资源-1" class="headerlink" title="释放资源"></a>释放资源</h3><p>编码完成后，调用 <code>close</code> 或 <code>flush</code> 释放编码器资源。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> encoder.<span class="title function_">flush</span>();</span><br><span class="line">encoder.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>std::declval 的作用</title>
    <url>/2023/03/16/c++/std::declval%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="std-declval-的作用"><a href="#std-declval-的作用" class="headerlink" title="std::declval 的作用"></a><code>std::declval</code> 的作用</h3><p><code>std::declval</code> 是 C++ 标准库中的一个工具，用于在不创建对象的情况下获得一个类型的引用。其主要作用是在编译时期在表达式中使用一个类型的实例而不实际构造对象。这在模板元编程和 SFINAE 中尤其有用，因为它允许我们在编译时对类型的潜在成员进行推断和检查。</p>
<p><code>std::declval</code> 在 <code>&lt;utility&gt;</code> 头文件中定义，并且仅在 unevaluated context（未求值上下文，例如 sizeof 和 decltype 中）是合法的，这意味着它不能用于在运行时创建对象。</p>
<h3 id="std-declval-的使用场景"><a href="#std-declval-的使用场景" class="headerlink" title="std::declval 的使用场景"></a><code>std::declval</code> 的使用场景</h3><h4 id="1-类型推导"><a href="#1-类型推导" class="headerlink" title="1. 类型推导"></a>1. 类型推导</h4><p>最常见的场景是在使用 <code>decltype</code> 来推导表达式的类型时，尤其是当你需要推导一个类的成员函数的返回类型，但又不想或不能创建这个类的实例。</p>
<p>例如，下面的代码展示了如何使用 <code>std::declval</code> 来推导成员函数的返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要创建 MyClass 的实例</span></span><br><span class="line"><span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;MyClass&gt;().<span class="built_in">myFunction</span>()) myVar;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>decltype</code> 用来确定 <code>myFunction</code> 的返回类型，而 <code>std::declval&lt;MyClass&gt;()</code> “假装” 有一个 <code>MyClass</code> 的对象来允许我们调用成员函数。</p>
<h4 id="2-SFINAE-和类型萃取"><a href="#2-SFINAE-和类型萃取" class="headerlink" title="2. SFINAE 和类型萃取"></a>2. SFINAE 和类型萃取</h4><p>在 SFINAE（替换失败并非错误）或写类型萃取（trait）时，<code>std::declval</code> 能够确保在没有默认构造函数的情况下依然能进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="type">int</span>;</span><br><span class="line">    <span class="function">value_type <span class="title">myFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用于萃取成员函数返回类型的类型萃取</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReturnType</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">decltype</span>(std::<span class="built_in">declval</span>&lt;T&gt;().<span class="built_in">myFunction</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(std::is_same&lt;ReturnType&lt;MyClass&gt;::type, <span class="type">int</span>&gt;::value, <span class="string">&quot;Type must be int&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，即使 <code>MyClass</code> 没有默认构造函数，我们也能用 <code>std::declval</code> 来进行编译时检查。</p>
<h4 id="3-重载决策"><a href="#3-重载决策" class="headerlink" title="3. 重载决策"></a>3. 重载决策</h4><p>在某些复杂的重载决策场景中，你可能希望根据类型是否支持某个操作来选择不同的函数重载。<code>std::declval</code> 可以在不创建对象的情况下 “假设” 该对象的存在，以便进行这样的检查。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::print&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_member_function_pointer&lt;<span class="keyword">decltype</span>(&amp;T::print)&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">testPrint</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPrint</span><span class="params">(T&amp;&amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;No print function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="built_in">testPrint</span>(a);  <span class="comment">// 输出 &quot;No print function&quot;</span></span><br><span class="line">    <span class="built_in">testPrint</span>(b);  <span class="comment">// 输出 &quot;B::print&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>std::declval</code> 在编译时帮助确定 <code>T</code> 类型是否有一个名为 <code>print</code> 的成员函数。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><code>std::declval</code> 是模板编程中一个极为有用的工具，它能够让程序员在不实例化对象的情况下引用任意类型，特别是在仅仅需要类型信息而不需要对象的场合。它通常与 <code>decltype</code> 结合使用，以便在编译时对表达式类型进行操作和推导。由于 <code>std::declval</code> 仅在未求值上下文中有效，因此它</p>
<p>主要用于模板元编程和编译时类型推导，而不是在实际运行时代码中创建对象。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>什么是 SFINAE?</title>
    <url>/2023/02/10/c++/%E4%BB%80%E4%B9%88%E6%98%AF%20SFINAE/</url>
    <content><![CDATA[<h3 id="什么是-SFINAE"><a href="#什么是-SFINAE" class="headerlink" title="什么是 SFINAE?"></a>什么是 SFINAE?</h3><p>SFINAE 是 “Substitution Failure Is Not An Error” 的缩写。这是 C++ 模板元编程中的一个重要概念，它允许在模板类型推导过程中，如果某个替换失败，这个失败不会立即导致编译错误。而是使得编译器简单地放弃这次替换，并尝试其他重载或模板特化。</p>
<h3 id="SFINAE-的用途"><a href="#SFINAE-的用途" class="headerlink" title="SFINAE 的用途"></a>SFINAE 的用途</h3><p>SFINAE 最常见的用途包括：</p>
<ul>
<li><strong>编写类型特征</strong>：检查类型是否具有某个成员函数、成员类型或操作符。</li>
<li><strong>函数模板重载决策</strong>：在多个函数模板重载之间选择最适合的一个。</li>
<li><strong>类模板特化</strong>：在多个类模板特化之间选择最适合的一个。</li>
</ul>
<h3 id="如何使用-SFINAE"><a href="#如何使用-SFINAE" class="headerlink" title="如何使用 SFINAE"></a>如何使用 SFINAE</h3><p>在 C++11 及其之后的版本中，SFINAE 最常见的实现方式是使用 <code>decltype</code>、<code>std::enable_if</code> 和类型特征（如 <code>std::is_integral</code> 等）。下面是一些使用 SFINAE 的例子：</p>
<h4 id="例子-1：使用-std-enable-if-禁用某些函数重载"><a href="#例子-1：使用-std-enable-if-禁用某些函数重载" class="headerlink" title="例子 1：使用 std::enable_if 禁用某些函数重载"></a>例子 1：使用 <code>std::enable_if</code> 禁用某些函数重载</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Integral version: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::<span class="function">type</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Floating point version: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">10</span>);    <span class="comment">// Calls the integral version</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>);  <span class="comment">// Calls the floating point version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>foo</code> 函数模板有两个重载。通过 <code>std::enable_if</code>，我们能够让编译器在模板类型是整型时选择第一个重载，在模板类型是浮点型时选择第二个重载。</p>
<h4 id="例子-2：检查类型是否有成员函数"><a href="#例子-2：检查类型是否有成员函数" class="headerlink" title="例子 2：检查类型是否有成员函数"></a>例子 2：检查类型是否有成员函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_serialize</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_serialize</span>&lt;C, <span class="built_in">Ret</span>(Args...)&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 如果C类型中，包含serialize函数，并且参数符合Args...，则匹配这条规则</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">check</span><span class="params">(T*)</span></span></span><br><span class="line"><span class="function">        -&gt; <span class="keyword">typename</span> std::is_same&lt;</span></span><br><span class="line"><span class="function">            <span class="title">decltype</span><span class="params">(std::declval&lt;T&gt;().serialize(std::declval&lt;Args&gt;()...))</span>,</span></span><br><span class="line"><span class="function">            Ret    </span></span><br><span class="line"><span class="function">        &gt;::type</span>; <span class="comment">// 当返回类型为auto时，在参数后通过-&gt;来指定返回类型</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 否则匹配这条规则</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span></span><br><span class="line"><span class="function">    <span class="type">static</span> <span class="keyword">constexpr</span> std::false_type <span class="title">check</span><span class="params">(...)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到C类型check后的结果类型，false_type or true_type</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(check&lt;C&gt;(<span class="number">0</span>))</span> type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = type::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyType</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; has_serialize&lt;MyType, <span class="built_in">void</span>(<span class="type">int</span>)&gt;::value &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用模板特化和 <code>decltype</code> 来检查 <code>MyType</code> 是否有一个接受 <code>int</code> 参数的 <code>serialize</code> 成员函数，<code>decltype</code>检测函数返回类型时，函数只需声明即可，无需实现。</p>
<h3 id="C-17-中的-SFINAE-友好的特性"><a href="#C-17-中的-SFINAE-友好的特性" class="headerlink" title="C++17 中的 SFINAE 友好的特性"></a>C++17 中的 SFINAE 友好的特性</h3><p>C++17 引入了 <code>if constexpr</code> 和 <code>auto</code> 类型推导的新特性，让 SFINAE 使用起来更为方便。</p>
<h4 id="例子-3：使用-if-constexpr"><a href="#例子-3：使用-if-constexpr" class="headerlink" title="例子 3：使用 if constexpr"></a>例子 3：使用 <code>if constexpr</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Integral version: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (std::is_floating_point_v&lt;T&gt;) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Floating point version: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">static_assert</span>(<span class="literal">false</span>, <span class="string">&quot;Unsupported type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子演示了如何在函数模板内部使用 &#96;</p>
<p>if constexpr&#96; 来在编译时选择执行路径，这样可以在不生成错误的情况下根据类型条件编译代码。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SFINAE 是 C++ 模板编程中一项强大的技术，可以用来在编译时根据类型特性来选择不同的代码路径。虽然 SFINAE 可以使代码变得非常灵活，但它也可能使得代码难以阅读和维护。随着 C++ 标准的发展，引入了更简洁的特性如 <code>if constexpr</code> 和概念（C++20 中的 concepts），它们可以使得之前需要 SFINAE 来实现的功能变得更简单和直观。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
